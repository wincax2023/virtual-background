(() => { "use strict"; var __webpack_modules__ = { 126: (__unused_webpack_module, exports) => { eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nvar NodeType;\n\n(function (NodeType) {\n  NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n  NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n  NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n  NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nfunction isShadowRoot(n) {\n  var _a;\n\n  var host = (_a = n) === null || _a === void 0 ? void 0 : _a.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nfunction maskInputValue(_a) {\n  var maskInputOptions = _a.maskInputOptions,\n      tagName = _a.tagName,\n      type = _a.type,\n      value = _a.value,\n      maskInputFn = _a.maskInputFn,\n      classList = _a.classList;\n  var text = value || '';\n\n  if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n    if (maskInputFn) {\n      text = maskInputFn(text, classList);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n\n  return text;\n}\n\nfunction base64Encode(arrayBuffer) {\n  var base64 = '';\n  var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var bytes = new Uint8Array(arrayBuffer);\n  var byteLength = bytes.byteLength;\n  var byteRemainder = byteLength % 3;\n  var mainLength = byteLength - byteRemainder;\n  var a, b, c, d;\n  var chunk;\n\n  for (var i = 0; i < mainLength; i = i + 3) {\n    chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n    a = (chunk & 16515072) >> 18;\n    b = (chunk & 258048) >> 12;\n    c = (chunk & 4032) >> 6;\n    d = chunk & 63;\n    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n  }\n\n  if (byteRemainder == 1) {\n    chunk = bytes[mainLength];\n    a = (chunk & 252) >> 2;\n    b = (chunk & 3) << 4;\n    base64 += encodings[a] + encodings[b] + '==';\n  } else if (byteRemainder == 2) {\n    chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n    a = (chunk & 64512) >> 10;\n    b = (chunk & 1008) >> 4;\n    c = (chunk & 15) << 2;\n    base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n  }\n\n  return base64;\n}\n\nfunction getFontFaceProperty(str) {\n  var regex = /([\\w-]*)\\s*:\\s*([^;]*)/g;\n  var match,\n      properties = {};\n\n  while (match = regex.exec(str)) {\n    if (match[1] === 'src') {\n      var hasWoff = match[2].includes(\".woff\\\"\");\n      var urls = match[2].split(',') || [];\n\n      for (var index = 0; index < urls.length; index++) {\n        var url = urls[index];\n\n        if (hasWoff) {\n          if (url.includes(\".woff\") && !url.includes(\".woff2\")) {\n            var woffs = url.match(/https:.*?.woff/g);\n            properties[match[1]] = woffs && woffs[0] ? woffs[0] : '';\n            properties['format'] = 'woff';\n            break;\n          }\n        } else {\n          if (url.includes(\".woff2\")) {\n            var woffs = url.match(/https:.*?.woff2/g);\n            properties[match[1]] = woffs && woffs[0] ? woffs[0] : '';\n            properties['format'] = 'woff2';\n            break;\n          } else if (url.includes(\".ttf\")) {\n            var woffs = url.match(/https:.*?.ttf/g);\n            properties[match[1]] = woffs && woffs[0] ? woffs[0] : '';\n            properties['format'] = 'truetype';\n            break;\n          }\n        }\n      }\n    } else {\n      properties[match[1]] = match[2].trim();\n    }\n  }\n\n  return properties;\n}\n\nfunction getFontFaceString(str) {\n  if (!str || str.length <= 0) return [];\n  var regex = /@font-face.*?}/g;\n  return str.match(regex);\n}\n\nvar ORIGINAL_ATTRIBUTE_NAME$2 = '__rrweb_original__';\n\nfunction is2DCanvasBlank$1(canvas) {\n  var ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n  var chunkSize = 50;\n\n  for (var x = 0; x < canvas.width; x += chunkSize) {\n    for (var y = 0; y < canvas.height; y += chunkSize) {\n      var getImageData = ctx.getImageData;\n      var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME$2 in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME$2] : getImageData;\n      var pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n      if (pixelBuffer.some(function (pixel) {\n        return pixel !== 0;\n      })) return false;\n    }\n  }\n\n  return true;\n}\n\nvar _id = 1;\nvar tagNameRegex = new RegExp('[^a-z0-9-_:]');\nvar IGNORED_NODE = -2;\n\nfunction genId() {\n  return _id++;\n}\n\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  var processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s) {\n  try {\n    var rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule) {\n  var cssStringified = rule.cssText;\n\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch (_a) {}\n  }\n\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule) {\n  return 'styleSheet' in rule;\n}\n\nfunction stringifyStyleSheet(sheet) {\n  return sheet.cssRules ? Array.from(sheet.cssRules).map(function (rule) {\n    return rule.cssText || '';\n  }).join('') : '';\n}\n\nfunction extractOrigin(url) {\n  var origin = '';\n\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nvar canvasService;\nvar canvasCtx;\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nvar DATA_URI2 = /^(data\\\\:)([^,]*),(.*)/i;\n\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || '').replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {\n    var filePath = path1 || path2 || path3;\n    var maybeQuote = quote1 || quote2 || '';\n\n    if (!filePath) {\n      return origin;\n    }\n\n    if (!RELATIVE_PATH.test(filePath)) {\n      return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n    }\n\n    if (DATA_URI.test(filePath)) {\n      return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n    }\n\n    if (DATA_URI2.test(filePath)) {\n      return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n    }\n\n    if (filePath[0] === '/') {\n      return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n    }\n\n    var stack = href.split('/');\n    var parts = filePath.split('/');\n    stack.pop();\n\n    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n      var part = parts_1[_i];\n\n      if (part === '.') {\n        continue;\n      } else if (part === '..') {\n        stack.pop();\n      } else {\n        stack.push(part);\n      }\n    }\n\n    return \"url(\" + maybeQuote + stack.join('/') + maybeQuote + \")\";\n  });\n}\n\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\n\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  var pos = 0;\n\n  function collectCharacters(regEx) {\n    var chars;\n    var match = regEx.exec(attributeValue.substring(pos));\n\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n\n    return '';\n  }\n\n  var output = [];\n\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n\n    if (pos >= attributeValue.length) {\n      break;\n    }\n\n    var url = collectCharacters(SRCSET_NOT_SPACES);\n\n    if (url.slice(-1) === ',') {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      var descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      var inParens = false;\n\n      while (true) {\n        var c = attributeValue.charAt(pos);\n\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n\n  return output.join(', ');\n}\n\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  var a = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\n}\n\nfunction getHref() {\n  var a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nfunction transformAttribute(doc, tagName, name, value) {\n  if (name === 'src' || name === 'href' && value) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'background' && value && (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data' && value) {\n    return absoluteToDoc(doc, value);\n  } else {\n    return value;\n  }\n}\n\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n  if (typeof blockClass === 'string') {\n    if (!blockClass || blockClass.length <= 0) {\n      return false;\n    }\n\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    var matched = false;\n\n    for (var eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      var className = element.classList[eIndex];\n\n      if (blockClass.test(className)) {\n        matched = true;\n        return true;\n      }\n    }\n\n    return matched;\n  }\n\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nfunction _isIgnoredElement(element, ignoreClass) {\n  if (typeof ignoreClass === 'string') {\n    if (element.classList.contains(ignoreClass)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction needMaskingText(node, maskTextClass, maskTextSelector) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if (node.classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      var matched = false;\n\n      for (var eIndex = 0; eIndex < node.classList.length; eIndex++) {\n        var className = node.classList.item(eIndex) || '';\n\n        if (maskTextClass.test(className)) {\n          matched = true;\n          return true;\n        }\n      }\n\n      return matched;\n    }\n\n    if (maskTextSelector) {\n      if (node.matches(maskTextSelector)) {\n        return true;\n      }\n    }\n\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\nfunction _needMaskingText(node, maskTextClass, maskTextSelector) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if (node.classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      var matched_1 = false;\n      node.classList.forEach(function (className) {\n        if (maskTextClass.test(className)) {\n          matched_1 = true;\n          return true;\n        }\n      });\n      return matched_1;\n    }\n\n    if (maskTextSelector) {\n      if (node.matches(maskTextSelector)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    return _needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n\n  return _needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  var win = iframeEl.contentWindow;\n\n  if (!win) {\n    return;\n  }\n\n  var fired = false;\n  var readyState;\n\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n\n  if (readyState !== 'complete') {\n    var timer_1 = setTimeout(function () {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', function () {\n      clearTimeout(timer_1);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n\n  var blankUrl = 'about:blank';\n\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === '') {\n    setTimeout(listener, 0);\n    return;\n  }\n\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(n, options) {\n  var _a;\n\n  var doc = options.doc,\n      blockClass = options.blockClass,\n      blockSelector = options.blockSelector,\n      maskTextClass = options.maskTextClass,\n      maskTextSelector = options.maskTextSelector,\n      inlineStylesheet = options.inlineStylesheet,\n      _b = options.maskInputOptions,\n      maskInputOptions = _b === void 0 ? {} : _b,\n      maskTextFn = options.maskTextFn,\n      maskInputFn = options.maskInputFn,\n      _c = options.dataURLOptions,\n      dataURLOptions = _c === void 0 ? {} : _c,\n      inlineImages = options.inlineImages,\n      recordCanvas = options.recordCanvas,\n      keepIframeSrcFn = options.keepIframeSrcFn,\n      disableRemoteControlFn = options.disableRemoteControlFn;\n  var rootId;\n\n  if (doc.__sn) {\n    var docId = doc.__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if (n.compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: n.compatMode,\n          rootId: rootId\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId: rootId\n        };\n      }\n\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: n.name,\n        publicId: n.publicId,\n        systemId: n.systemId,\n        rootId: rootId\n      };\n\n    case n.ELEMENT_NODE:\n      if (disableRemoteControlFn) {\n        if (_isDisableRemoteControlElement(n)) {\n          disableRemoteControlFn(window.location.href, true);\n        } else {\n          disableRemoteControlFn(window.location.href, false);\n        }\n      }\n\n      var needIgnore = _isIgnoredElement(n, 'rr-ignore');\n\n      if (needIgnore) {\n        return false;\n      }\n\n      var needBlock = _isBlockedElement(n, blockClass, blockSelector);\n\n      var needMask = needMaskingText(n, maskTextClass, maskTextSelector);\n      var tagName = getValidTagName(n);\n      var attributes_1 = {};\n\n      for (var _i = 0, _d = Array.from(n.attributes); _i < _d.length; _i++) {\n        var _e = _d[_i],\n            name_1 = _e.name,\n            value = _e.value;\n        attributes_1[name_1] = transformAttribute(doc, tagName, name_1, value);\n      }\n\n      if (tagName === 'link' && inlineStylesheet) {\n        var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n          return s.href === n.href;\n        });\n        var cssText = null;\n\n        if (stylesheet) {\n          cssText = getCssRulesString(stylesheet);\n        }\n\n        if (cssText) {\n          delete attributes_1.rel;\n          delete attributes_1.href;\n          attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n        }\n      }\n\n      if (tagName === 'style' && n.sheet && !(n.innerText || n.textContent || '').trim().length) {\n        var cssText = getCssRulesString(n.sheet);\n\n        if (cssText) {\n          attributes_1._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n\n      if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\n        var value = n.value;\n\n        if (attributes_1.type !== 'radio' && attributes_1.type !== 'checkbox' && attributes_1.type !== 'submit' && attributes_1.type !== 'button' && value) {\n          var classList = '';\n\n          if (n.nodeType === n.ELEMENT_NODE) {\n            classList = n.classList.value;\n          }\n\n          if (n.nodeType === n.TEXT_NODE) {\n            classList = n.parentNode.classList.value;\n          }\n\n          attributes_1.value = maskInputValue({\n            type: attributes_1.type,\n            tagName: tagName,\n            value: value,\n            maskInputOptions: maskInputOptions,\n            maskInputFn: maskInputFn,\n            classList: classList\n          });\n        } else if (n.checked) {\n          attributes_1.checked = n.checked;\n        }\n      }\n\n      if (tagName === 'option') {\n        if (n.selected && !maskInputOptions['select']) {\n          attributes_1.selected = true;\n        } else {\n          delete attributes_1.selected;\n        }\n      }\n\n      if (tagName === 'canvas' && recordCanvas) {\n        if (n.__context === '2d') {\n          if (!is2DCanvasBlank$1(n)) {\n            attributes_1.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n          }\n        } else if (!('__context' in n)) {\n          var canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n          var blankCanvas = document.createElement('canvas');\n          blankCanvas.width = n.width;\n          blankCanvas.height = n.height;\n          var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n\n          if (canvasDataURL !== blankCanvasDataURL) {\n            attributes_1.rr_dataURL = canvasDataURL;\n          }\n        }\n      }\n\n      if (tagName === 'img' && inlineImages) {\n        if (!canvasService) {\n          canvasService = doc.createElement('canvas');\n          canvasCtx = canvasService.getContext('2d');\n        }\n\n        var image_1 = n;\n        var oldValue_1 = image_1.crossOrigin;\n        image_1.crossOrigin = 'anonymous';\n\n        var recordInlineImage = function () {\n          try {\n            canvasService.width = image_1.naturalWidth;\n            canvasService.height = image_1.naturalHeight;\n            canvasCtx.drawImage(image_1, 0, 0);\n            attributes_1.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n          } catch (err) {\n            console.warn(\"Cannot inline img src=\" + image_1.currentSrc + \"! Error: \" + err);\n          }\n\n          oldValue_1 ? attributes_1.crossOrigin = oldValue_1 : delete attributes_1.crossOrigin;\n        };\n\n        if (image_1.complete && image_1.naturalWidth !== 0) recordInlineImage();else image_1.onload = recordInlineImage;\n      }\n\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes_1.rr_mediaState = n.paused ? 'paused' : 'played';\n        attributes_1.rr_mediaCurrentTime = n.currentTime;\n      }\n\n      if (n.scrollLeft) {\n        attributes_1.rr_scrollLeft = n.scrollLeft;\n      }\n\n      if (n.scrollTop) {\n        attributes_1.rr_scrollTop = n.scrollTop;\n      }\n\n      if (needBlock) {\n        var rect = n.getBoundingClientRect();\n        var width = rect.width,\n            height = rect.height;\n\n        if ((height <= 0 || width <= 0) && tagName === 'img') {\n          if (width <= 0) {\n            width = n.naturalWidth;\n          }\n\n          if (height <= 0) {\n            height = n.naturalHeight;\n          }\n\n          console.warn('serializeNode : ', tagName, width, height, n);\n        }\n\n        var className = attributes_1[\"class\"];\n\n        if (className && !className.includes('rr-block')) {\n          className += ' rr-block';\n        }\n\n        if (tagName === 'span' || tagName === 'p' || tagName === 'input') {\n          attributes_1[\"class\"] = className;\n          attributes_1.rr_width = width + \"px\";\n          attributes_1.rr_height = height + \"px\";\n          attributes_1.rr_background_image = \"repeating-linear-gradient(45deg, #fff, #fff 10px, #ccc 10px, #ccc 20px)\";\n        } else {\n          attributes_1 = {\n            \"class\": className,\n            rr_width: width + \"px\",\n            rr_height: height + \"px\",\n            rr_background_image: \"repeating-linear-gradient(45deg, #fff, #fff 10px, #ccc 10px, #ccc 20px)\"\n          };\n        }\n      }\n\n      if (needMask) {\n        var rect = n.getBoundingClientRect();\n        var width = rect.width;\n        var className = attributes_1[\"class\"];\n\n        if (className && !className.includes('rr-mask')) {\n          className += ' rr-mask';\n        }\n\n        attributes_1[\"class\"] = className;\n        attributes_1.rr_width = width + \"px\";\n      }\n\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes_1.src)) {\n        if (!n.contentDocument) {\n          attributes_1.rr_src = attributes_1.src;\n        }\n\n        delete attributes_1.src;\n      }\n\n      return {\n        type: NodeType.Element,\n        tagName: tagName,\n        attributes: attributes_1,\n        childNodes: [],\n        isSVG: isSVGElement(n) || undefined,\n        needBlock: needBlock,\n        rootId: rootId\n      };\n\n    case n.TEXT_NODE:\n      var parentTagName = n.parentNode && n.parentNode.tagName;\n      var textContent_1 = n.textContent;\n      var isStyle = parentTagName === 'STYLE' ? true : undefined;\n      var isScript = parentTagName === 'SCRIPT' ? true : undefined;\n\n      if (isStyle && textContent_1) {\n        try {\n          if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\n            textContent_1 = stringifyStyleSheet(n.parentNode.sheet);\n          }\n        } catch (err) {\n          console.warn(\"Cannot get CSS styles from text's parentNode. Error: \" + err, n);\n        }\n\n        textContent_1 = absoluteToStylesheet(textContent_1, getHref());\n      }\n\n      if (isScript) {\n        textContent_1 = 'SCRIPT_PLACEHOLDER';\n      }\n\n      var _needMask = false;\n\n      if (!isStyle && !isScript && textContent_1) {\n        _needMask = _needMaskingText(n.parentNode, maskTextClass, maskTextSelector);\n      }\n\n      if (!isStyle && !isScript && _needMask && textContent_1) {\n        var classList = '';\n        var parentNode = n.parentNode;\n        classList = parentNode.classList.value;\n        textContent_1 = maskTextFn ? maskTextFn(textContent_1, classList) : textContent_1.replace(/[\\S]/g, '*');\n      }\n\n      if ((textContent_1 === null || textContent_1 === void 0 ? void 0 : textContent_1.includes('@font-face')) && (textContent_1 === null || textContent_1 === void 0 ? void 0 : textContent_1.includes(location.origin))) {\n        var fontFaceStrings = getFontFaceString(textContent_1) || [];\n        fontFaceStrings.map(function (fontFaceString) {\n          try {\n            var property = getFontFaceProperty(fontFaceString);\n            var fontFamily_1 = property ? property['font-family'] : 'unknow';\n            var fontFace = localStorage.getItem(fontFamily_1);\n\n            if (fontFace && fontFace.length > 0 && textContent_1) {\n              textContent_1 = textContent_1.replace(fontFaceString, fontFace);\n            } else {\n              var src = property['src'];\n              var format_1 = property['format'];\n              var fontStyle_1 = property['font-style'];\n              var fontWeight_1 = property[\"font-weight\"];\n              var xhr = new XMLHttpRequest();\n              xhr.responseType = 'arraybuffer';\n              xhr.open(\"GET\", src, true);\n\n              xhr.onload = function (e) {\n                if (xhr.readyState != 4 || xhr.status != 200) {\n                  return;\n                }\n\n                if (xhr.readyState === 4) {\n                  if (xhr.status === 200) {\n                    var base64EncodedFont = base64Encode(xhr.response);\n\n                    if (base64EncodedFont && base64EncodedFont.length > 0) {\n                      var fontCode = \"@font-face { font-family: \" + fontFamily_1 + \"; src: url(\\\"data:application/font-woff;base64,\" + base64EncodedFont + \"\\\") format(\\\"\" + format_1 + \"\\\"); font-style: \" + fontStyle_1 + \"; font-weight: \" + fontWeight_1 + \" }\";\n                      localStorage.setItem(fontFamily_1, fontCode);\n                      var styleElement = document.createElement(\"style\");\n                      styleElement.type = \"text/css\";\n                      styleElement.innerHTML = fontCode;\n                      document.head.appendChild(styleElement);\n                    }\n                  } else {\n                    console.error(xhr.statusText);\n                  }\n                }\n              };\n\n              xhr.onerror = function (e) {\n                console.error(xhr.statusText);\n              };\n\n              xhr.send(null);\n            }\n          } catch (error) {\n            console.error(error);\n          }\n        });\n      }\n\n      return {\n        type: NodeType.Text,\n        textContent: textContent_1 || '',\n        isStyle: isStyle,\n        rootId: rootId\n      };\n\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId: rootId\n      };\n\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: n.textContent || '',\n        rootId: rootId\n      };\n\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (slimDOMOptions.script && (sn.tagName === 'script' || sn.tagName === 'link' && sn.attributes.rel === 'preload' && sn.attributes.as === 'script' || sn.tagName === 'link' && sn.attributes.rel === 'prefetch' && typeof sn.attributes.href === 'string' && sn.attributes.href.endsWith('.js'))) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon' || sn.tagName === 'meta' && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === 'application-name' || lowerIfExists(sn.attributes.rel) === 'icon' || lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' || lowerIfExists(sn.attributes.rel) === 'shortcut icon'))) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === 'pinterest')) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === 'robots' || lowerIfExists(sn.attributes.name) === 'googlebot' || lowerIfExists(sn.attributes.name) === 'bingbot')) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes['http-equiv'] !== undefined) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === 'author' || lowerIfExists(sn.attributes.name) === 'generator' || lowerIfExists(sn.attributes.name) === 'framework' || lowerIfExists(sn.attributes.name) === 'publisher' || lowerIfExists(sn.attributes.name) === 'progid' || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === 'google-site-verification' || lowerIfExists(sn.attributes.name) === 'yandex-verification' || lowerIfExists(sn.attributes.name) === 'csrf-token' || lowerIfExists(sn.attributes.name) === 'p:domain_verify' || lowerIfExists(sn.attributes.name) === 'verify-v1' || lowerIfExists(sn.attributes.name) === 'verification' || lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction serializeNodeWithId(n, options) {\n  var doc = options.doc,\n      map = options.map,\n      blockClass = options.blockClass,\n      blockSelector = options.blockSelector,\n      maskTextClass = options.maskTextClass,\n      maskTextSelector = options.maskTextSelector,\n      _a = options.skipChild,\n      skipChild = _a === void 0 ? false : _a,\n      _b = options.inlineStylesheet,\n      inlineStylesheet = _b === void 0 ? true : _b,\n      _c = options.maskInputOptions,\n      maskInputOptions = _c === void 0 ? {} : _c,\n      maskTextFn = options.maskTextFn,\n      maskInputFn = options.maskInputFn,\n      slimDOMOptions = options.slimDOMOptions,\n      _d = options.dataURLOptions,\n      dataURLOptions = _d === void 0 ? {} : _d,\n      _e = options.inlineImages,\n      inlineImages = _e === void 0 ? false : _e,\n      _f = options.recordCanvas,\n      recordCanvas = _f === void 0 ? false : _f,\n      onSerialize = options.onSerialize,\n      onIframeLoad = options.onIframeLoad,\n      _g = options.iframeLoadTimeout,\n      iframeLoadTimeout = _g === void 0 ? 5000 : _g,\n      _h = options.keepIframeSrcFn,\n      keepIframeSrcFn = _h === void 0 ? function () {\n    return false;\n  } : _h,\n      disableRemoteControlFn = options.disableRemoteControlFn;\n  var _j = options.preserveWhiteSpace,\n      preserveWhiteSpace = _j === void 0 ? true : _j;\n\n  var _serializedNode = serializeNode(n, {\n    doc: doc,\n    blockClass: blockClass,\n    blockSelector: blockSelector,\n    maskTextClass: maskTextClass,\n    maskTextSelector: maskTextSelector,\n    inlineStylesheet: inlineStylesheet,\n    maskInputOptions: maskInputOptions,\n    maskTextFn: maskTextFn,\n    maskInputFn: maskInputFn,\n    dataURLOptions: dataURLOptions,\n    inlineImages: inlineImages,\n    recordCanvas: recordCanvas,\n    keepIframeSrcFn: keepIframeSrcFn,\n    disableRemoteControlFn: disableRemoteControlFn\n  });\n\n  if (!_serializedNode) {\n    return null;\n  }\n\n  var id;\n\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n\n  var serializedNode = Object.assign(_serializedNode, {\n    id: id\n  });\n  n.__sn = serializedNode;\n\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n\n  map[id] = n;\n\n  if (onSerialize) {\n    onSerialize(n);\n  }\n\n  var recordChild = !skipChild;\n\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    delete serializedNode.needBlock;\n    if (n.shadowRoot) serializedNode.isShadowHost = true;\n  }\n\n  if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && _serializedNode.type === NodeType.Element && _serializedNode.tagName === 'head') {\n      preserveWhiteSpace = false;\n    }\n\n    var bypassOptions = {\n      doc: doc,\n      map: map,\n      blockClass: blockClass,\n      blockSelector: blockSelector,\n      maskTextClass: maskTextClass,\n      maskTextSelector: maskTextSelector,\n      skipChild: skipChild,\n      inlineStylesheet: inlineStylesheet,\n      maskInputOptions: maskInputOptions,\n      maskTextFn: maskTextFn,\n      maskInputFn: maskInputFn,\n      slimDOMOptions: slimDOMOptions,\n      dataURLOptions: dataURLOptions,\n      inlineImages: inlineImages,\n      recordCanvas: recordCanvas,\n      preserveWhiteSpace: preserveWhiteSpace,\n      onSerialize: onSerialize,\n      onIframeLoad: onIframeLoad,\n      iframeLoadTimeout: iframeLoadTimeout,\n      keepIframeSrcFn: keepIframeSrcFn,\n      disableRemoteControlFn: disableRemoteControlFn\n    };\n\n    for (var _i = 0, _k = Array.from(n.childNodes); _i < _k.length; _i++) {\n      var childN = _k[_i];\n      var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (var _l = 0, _m = Array.from(n.shadowRoot.childNodes); _l < _m.length; _l++) {\n        var childN = _m[_l];\n        var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (serializedNode.type === NodeType.Element && serializedNode.tagName === 'iframe') {\n    onceIframeLoaded(n, function () {\n      var iframeDoc = n.contentDocument;\n\n      if (iframeDoc && onIframeLoad) {\n        var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n          doc: iframeDoc,\n          map: map,\n          blockClass: blockClass,\n          blockSelector: blockSelector,\n          maskTextClass: maskTextClass,\n          maskTextSelector: maskTextSelector,\n          skipChild: false,\n          inlineStylesheet: inlineStylesheet,\n          maskInputOptions: maskInputOptions,\n          maskTextFn: maskTextFn,\n          maskInputFn: maskInputFn,\n          slimDOMOptions: slimDOMOptions,\n          dataURLOptions: dataURLOptions,\n          inlineImages: inlineImages,\n          recordCanvas: recordCanvas,\n          preserveWhiteSpace: preserveWhiteSpace,\n          onSerialize: onSerialize,\n          onIframeLoad: onIframeLoad,\n          iframeLoadTimeout: iframeLoadTimeout,\n          keepIframeSrcFn: keepIframeSrcFn,\n          disableRemoteControlFn: disableRemoteControlFn\n        });\n\n        if (serializedIframeNode) {\n          onIframeLoad(n, serializedIframeNode);\n        }\n      }\n    }, iframeLoadTimeout);\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(n, options) {\n  var _a = options || {},\n      _b = _a.blockClass,\n      blockClass = _b === void 0 ? 'rr-block' : _b,\n      _c = _a.blockSelector,\n      blockSelector = _c === void 0 ? null : _c,\n      _d = _a.maskTextClass,\n      maskTextClass = _d === void 0 ? 'rr-mask' : _d,\n      _e = _a.maskTextSelector,\n      maskTextSelector = _e === void 0 ? null : _e,\n      _f = _a.inlineStylesheet,\n      inlineStylesheet = _f === void 0 ? true : _f,\n      _g = _a.inlineImages,\n      inlineImages = _g === void 0 ? false : _g,\n      _h = _a.recordCanvas,\n      recordCanvas = _h === void 0 ? false : _h,\n      _j = _a.maskAllInputs,\n      maskAllInputs = _j === void 0 ? false : _j,\n      maskTextFn = _a.maskTextFn,\n      maskInputFn = _a.maskInputFn,\n      _k = _a.slimDOM,\n      slimDOM = _k === void 0 ? false : _k,\n      dataURLOptions = _a.dataURLOptions,\n      preserveWhiteSpace = _a.preserveWhiteSpace,\n      onSerialize = _a.onSerialize,\n      onIframeLoad = _a.onIframeLoad,\n      iframeLoadTimeout = _a.iframeLoadTimeout,\n      _l = _a.keepIframeSrcFn,\n      keepIframeSrcFn = _l === void 0 ? function () {\n    return false;\n  } : _l,\n      disableRemoteControlFn = _a.disableRemoteControlFn;\n\n  var idNodeMap = {};\n  var maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    'datetime-local': true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    password: true\n  } : maskAllInputs === false ? {\n    password: true\n  } : maskAllInputs;\n  var slimDOMOptions = slimDOM === true || slimDOM === 'all' ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaDescKeywords: slimDOM === 'all',\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaAuthorship: true,\n    headMetaVerification: true\n  } : slimDOM === false ? {} : slimDOM;\n  return [serializeNodeWithId(n, {\n    doc: n,\n    map: idNodeMap,\n    blockClass: blockClass,\n    blockSelector: blockSelector,\n    maskTextClass: maskTextClass,\n    maskTextSelector: maskTextSelector,\n    skipChild: false,\n    inlineStylesheet: inlineStylesheet,\n    maskInputOptions: maskInputOptions,\n    maskTextFn: maskTextFn,\n    maskInputFn: maskInputFn,\n    slimDOMOptions: slimDOMOptions,\n    dataURLOptions: dataURLOptions,\n    inlineImages: inlineImages,\n    recordCanvas: recordCanvas,\n    preserveWhiteSpace: preserveWhiteSpace,\n    onSerialize: onSerialize,\n    onIframeLoad: onIframeLoad,\n    iframeLoadTimeout: iframeLoadTimeout,\n    keepIframeSrcFn: keepIframeSrcFn,\n    disableRemoteControlFn: disableRemoteControlFn\n  }), idNodeMap];\n}\n\nfunction _isDisableRemoteControlElement(element) {\n  var disableClass = 'cosee-disable-remote-control';\n\n  if (element.classList.contains(disableClass)) {\n    return true;\n  }\n\n  return false;\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nfunction parse(css, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var lineno = 1;\n  var column = 1;\n\n  function updatePosition(str) {\n    var lines = str.match(/\\n/g);\n\n    if (lines) {\n      lineno += lines.length;\n    }\n\n    var i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  function position() {\n    var start = {\n      line: lineno,\n      column: column\n    };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  var Position = function () {\n    function Position(start) {\n      this.start = start;\n      this.end = {\n        line: lineno,\n        column: column\n      };\n      this.source = options.source;\n    }\n\n    return Position;\n  }();\n\n  Position.prototype.content = css;\n  var errorsList = [];\n\n  function error(msg) {\n    var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  function stylesheet() {\n    var rulesList = rules();\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList\n      }\n    };\n  }\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  function close() {\n    return match(/^}/);\n  }\n\n  function rules() {\n    var node;\n    var rules = [];\n    whitespace();\n    comments(rules);\n\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n\n    return rules;\n  }\n\n  function match(re) {\n    var m = re.exec(css);\n\n    if (!m) {\n      return;\n    }\n\n    var str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  function comments(rules) {\n    if (rules === void 0) {\n      rules = [];\n    }\n\n    var c;\n\n    while (c = comment()) {\n      if (c !== false) {\n        rules.push(c);\n      }\n\n      c = comment();\n    }\n\n    return rules;\n  }\n\n  function comment() {\n    var pos = position();\n\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    var i = 2;\n\n    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\n      ++i;\n    }\n\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n    return pos({\n      type: 'comment',\n      comment: str\n    });\n  }\n\n  function selector() {\n    var m = match(/^([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n\n    return trim(m[0]).replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '').replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\n      return m.replace(/,/g, '\\u200C');\n    }).split(/\\s*(?![^(]*\\)),\\s*/).map(function (s) {\n      return s.replace(/\\u200C/g, ',');\n    });\n  }\n\n  function declaration() {\n    var pos = position();\n    var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n\n    if (!propMatch) {\n      return;\n    }\n\n    var prop = trim(propMatch[0]);\n\n    if (!match(/^:\\s*/)) {\n      return error(\"property missing ':'\");\n    }\n\n    var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n    var ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : ''\n    });\n    match(/^[;\\s]*/);\n    return ret;\n  }\n\n  function declarations() {\n    var decls = [];\n\n    if (!open()) {\n      return error(\"missing '{'\");\n    }\n\n    comments(decls);\n    var decl;\n\n    while (decl = declaration()) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(\"missing '}'\");\n    }\n\n    return decls;\n  }\n\n  function keyframe() {\n    var m;\n    var vals = [];\n    var pos = position();\n\n    while (m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/)) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations()\n    });\n  }\n\n  function atkeyframes() {\n    var pos = position();\n    var m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    var vendor = m[1];\n    m = match(/^([-\\w]+)\\s*/);\n\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n\n    var name = m[1];\n\n    if (!open()) {\n      return error(\"@keyframes missing '{'\");\n    }\n\n    var frame;\n    var frames = comments();\n\n    while (frame = keyframe()) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(\"@keyframes missing '}'\");\n    }\n\n    return pos({\n      type: 'keyframes',\n      name: name,\n      vendor: vendor,\n      keyframes: frames\n    });\n  }\n\n  function atsupports() {\n    var pos = position();\n    var m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n\n    var supports = trim(m[1]);\n\n    if (!open()) {\n      return error(\"@supports missing '{'\");\n    }\n\n    var style = comments().concat(rules());\n\n    if (!close()) {\n      return error(\"@supports missing '}'\");\n    }\n\n    return pos({\n      type: 'supports',\n      supports: supports,\n      rules: style\n    });\n  }\n\n  function athost() {\n    var pos = position();\n    var m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(\"@host missing '{'\");\n    }\n\n    var style = comments().concat(rules());\n\n    if (!close()) {\n      return error(\"@host missing '}'\");\n    }\n\n    return pos({\n      type: 'host',\n      rules: style\n    });\n  }\n\n  function atmedia() {\n    var pos = position();\n    var m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n\n    var media = trim(m[1]);\n\n    if (!open()) {\n      return error(\"@media missing '{'\");\n    }\n\n    var style = comments().concat(rules());\n\n    if (!close()) {\n      return error(\"@media missing '}'\");\n    }\n\n    return pos({\n      type: 'media',\n      media: media,\n      rules: style\n    });\n  }\n\n  function atcustommedia() {\n    var pos = position();\n    var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2])\n    });\n  }\n\n  function atpage() {\n    var pos = position();\n    var m = match(/^@page */);\n\n    if (!m) {\n      return;\n    }\n\n    var sel = selector() || [];\n\n    if (!open()) {\n      return error(\"@page missing '{'\");\n    }\n\n    var decls = comments();\n    var decl;\n\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(\"@page missing '}'\");\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls\n    });\n  }\n\n  function atdocument() {\n    var pos = position();\n    var m = match(/^@([-\\w]+)?document *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n\n    var vendor = trim(m[1]);\n    var doc = trim(m[2]);\n\n    if (!open()) {\n      return error(\"@document missing '{'\");\n    }\n\n    var style = comments().concat(rules());\n\n    if (!close()) {\n      return error(\"@document missing '}'\");\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor: vendor,\n      rules: style\n    });\n  }\n\n  function atfontface() {\n    var pos = position();\n    var m = match(/^@font-face\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(\"@font-face missing '{'\");\n    }\n\n    var decls = comments();\n    var decl;\n\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(\"@font-face missing '}'\");\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls\n    });\n  }\n\n  var atimport = _compileAtrule('import');\n\n  var atcharset = _compileAtrule('charset');\n\n  var atnamespace = _compileAtrule('namespace');\n\n  function _compileAtrule(name) {\n    var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return function () {\n      var pos = position();\n      var m = match(re);\n\n      if (!m) {\n        return;\n      }\n\n      var ret = {\n        type: name\n      };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();\n  }\n\n  function rule() {\n    var pos = position();\n    var sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n\n    comments();\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations()\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\nfunction trim(str) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\nfunction addParent(obj, parent) {\n  var isNode = obj && typeof obj.type === 'string';\n  var childParent = isNode ? obj : parent;\n\n  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n    var k = _a[_i];\n    var value = obj[k];\n\n    if (Array.isArray(value)) {\n      value.forEach(function (v) {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent(value, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n\n  return obj;\n}\n\nvar tagMap = {\n  script: 'noscript',\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient'\n};\n\nfunction getTagName(n) {\n  var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n\n  return tagName;\n}\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nvar HOVER_SELECTOR = /([^\\\\]):hover/;\nvar HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\n\nfunction addHoverClass(cssText, cache) {\n  var cachedStyle = cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n  var ast = parse(cssText, {\n    silent: true\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  var selectors = [];\n  ast.stylesheet.rules.forEach(function (rule) {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach(function (selector) {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  var selectorMatcher = new RegExp(selectors.filter(function (selector, index) {\n    return selectors.indexOf(selector) === index;\n  }).sort(function (a, b) {\n    return b.length - a.length;\n  }).map(function (selector) {\n    return escapeRegExp(selector);\n  }).join('|'), 'g');\n  var result = cssText.replace(selectorMatcher, function (selector) {\n    var newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return selector + \", \" + newSelector;\n  });\n  cache === null || cache === void 0 ? void 0 : cache.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nfunction createCache() {\n  var stylesWithHoverClass = new Map();\n  return {\n    stylesWithHoverClass: stylesWithHoverClass\n  };\n}\n\nfunction buildNode(n, options) {\n  var doc = options.doc,\n      hackCss = options.hackCss,\n      cache = options.cache;\n\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(n.name || 'html', n.publicId, n.systemId);\n\n    case NodeType.Element:\n      var tagName = getTagName(n);\n      var node_1;\n\n      if (n.isSVG) {\n        node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node_1 = doc.createElement(tagName);\n      }\n\n      var _loop_1 = function (name_1) {\n        if (!n.attributes.hasOwnProperty(name_1)) {\n          return \"continue\";\n        }\n\n        var value = n.attributes[name_1];\n\n        if (tagName === 'option' && name_1 === 'selected' && value === false) {\n          return \"continue\";\n        }\n\n        value = typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n\n        if (!name_1.startsWith('rr_')) {\n          var isTextarea = tagName === 'textarea' && name_1 === 'value';\n          var isRemoteOrDynamicCss = tagName === 'style' && name_1 === '_cssText';\n\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n\n          if (isTextarea || isRemoteOrDynamicCss) {\n            var child = doc.createTextNode(value);\n\n            for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\n              var c = _a[_i];\n\n              if (c.nodeType === node_1.TEXT_NODE) {\n                node_1.removeChild(c);\n              }\n            }\n\n            node_1.appendChild(child);\n            return \"continue\";\n          }\n\n          try {\n            if (n.isSVG && name_1 === 'xlink:href') {\n              node_1.setAttributeNS('http://www.w3.org/1999/xlink', name_1, value);\n            } else if (name_1 === 'onload' || name_1 === 'onclick' || name_1.substring(0, 7) === 'onmouse') {\n              node_1.setAttribute('_' + name_1, value);\n            } else if (tagName === 'meta' && n.attributes['http-equiv'] === 'Content-Security-Policy' && name_1 === 'content') {\n              node_1.setAttribute('csp-content', value);\n              return \"continue\";\n            } else if (tagName === 'link' && n.attributes.rel === 'preload' && n.attributes.as === 'script') {} else if (tagName === 'link' && n.attributes.rel === 'prefetch' && typeof n.attributes.href === 'string' && n.attributes.href.endsWith('.js')) {} else if (tagName === 'img' && n.attributes.srcset && n.attributes.rr_dataURL) {\n              node_1.setAttribute('rrweb-original-srcset', n.attributes.srcset);\n            } else {\n              node_1.setAttribute(name_1, value);\n            }\n          } catch (error) {}\n        } else {\n          if (tagName === 'canvas' && name_1 === 'rr_dataURL') {\n            var image_1 = document.createElement('img');\n            image_1.src = value;\n\n            image_1.onload = function () {\n              var ctx = node_1.getContext('2d');\n\n              if (ctx) {\n                ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n              }\n            };\n          } else if (tagName === 'img' && name_1 === 'rr_dataURL') {\n            var image = node_1;\n\n            if (!image.currentSrc.startsWith('data:')) {\n              image.setAttribute('rrweb-original-src', n.attributes.src);\n              image.src = value;\n            }\n          }\n\n          if (name_1 === 'rr_width') {\n            node_1.style.width = value;\n          } else if (name_1 === 'rr_height') {\n            node_1.style.height = value;\n          } else if (name_1 === 'rr_mediaCurrentTime') {\n            node_1.currentTime = n.attributes.rr_mediaCurrentTime;\n          } else if (name_1 === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                node_1.play()[\"catch\"](function (e) {\n                  return console.warn('media playback error', e);\n                });\n                break;\n\n              case 'paused':\n                node_1.pause();\n                break;\n            }\n          } else if (name_1 === 'rr_display') {\n            node_1.style.display = value;\n          } else if (name_1 === 'rr_background') {\n            node_1.style.background = value;\n          } else if (name_1 === 'rr_background_image') {\n            node_1.style.backgroundImage = value;\n            node_1.style.backgroundRepeat = 'no-repeat';\n          }\n        }\n      };\n\n      for (var name_1 in n.attributes) {\n        _loop_1(name_1);\n      }\n\n      if (n.isShadowHost) {\n        if (!node_1.shadowRoot) {\n          try {\n            node_1.attachShadow({\n              mode: 'open'\n            });\n          } catch (error) {\n            console.error('attachShadow error : ', error);\n          }\n        } else {\n          while (node_1.shadowRoot.firstChild) {\n            node_1.shadowRoot.removeChild(node_1.shadowRoot.firstChild);\n          }\n        }\n      }\n\n      return node_1;\n\n    case NodeType.Text:\n      return doc.createTextNode(n.isStyle && hackCss ? addHoverClass(n.textContent, cache) : n.textContent);\n\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n\n    default:\n      return null;\n  }\n}\n\nfunction buildNodeWithSN(n, options) {\n  var doc = options.doc,\n      map = options.map,\n      _a = options.skipChild,\n      skipChild = _a === void 0 ? false : _a,\n      _b = options.hackCss,\n      hackCss = _b === void 0 ? true : _b,\n      afterAppend = options.afterAppend,\n      cache = options.cache;\n  var node = buildNode(n, {\n    doc: doc,\n    hackCss: hackCss,\n    cache: cache\n  });\n\n  if (!node) {\n    return null;\n  }\n\n  if (n.rootId) {\n    console.assert(map[n.rootId] === doc, 'Target document should has the same root id.');\n  }\n\n  if (n.type === NodeType.Document) {\n    doc.close();\n    doc.open();\n\n    if (n.compatMode === 'BackCompat' && n.childNodes && n.childNodes[0].type !== NodeType.DocumentType) {\n      if (n.childNodes[0].type === NodeType.Element && 'xmlns' in n.childNodes[0].attributes && n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml') {\n        doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">');\n      } else {\n        doc.write('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">');\n      }\n    }\n\n    node = doc;\n  }\n\n  node.__sn = n;\n  map[n.id] = node;\n\n  if ((n.type === NodeType.Document || n.type === NodeType.Element) && !skipChild) {\n    for (var _i = 0, _c = n.childNodes; _i < _c.length; _i++) {\n      var childN = _c[_i];\n      var childNode = buildNodeWithSN(childN, {\n        doc: doc,\n        map: map,\n        skipChild: false,\n        hackCss: hackCss,\n        afterAppend: afterAppend,\n        cache: cache\n      });\n\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node;\n}\n\nfunction visit(idNodeMap, onVisit) {\n  function walk(node) {\n    onVisit(node);\n  }\n\n  for (var key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node) {\n  var n = node.__sn;\n\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n\n  var el = node;\n\n  for (var name_2 in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name_2) && name_2.startsWith('rr_'))) {\n      continue;\n    }\n\n    var value = n.attributes[name_2];\n\n    if (name_2 === 'rr_scrollLeft') {\n      el.scrollLeft = value;\n    }\n\n    if (name_2 === 'rr_scrollTop') {\n      el.scrollTop = value;\n    }\n  }\n}\n\nfunction rebuild(n, options) {\n  var doc = options.doc,\n      onVisit = options.onVisit,\n      _a = options.hackCss,\n      hackCss = _a === void 0 ? true : _a,\n      afterAppend = options.afterAppend,\n      cache = options.cache;\n  var idNodeMap = {};\n  var node = buildNodeWithSN(n, {\n    doc: doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss: hackCss,\n    afterAppend: afterAppend,\n    cache: cache\n  });\n  visit(idNodeMap, function (visitedNode) {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexports.tw = void 0;\n\n(function (EventType) {\n  EventType[EventType[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType[EventType[\"Load\"] = 1] = \"Load\";\n  EventType[EventType[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType[EventType[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType[EventType[\"Meta\"] = 4] = \"Meta\";\n  EventType[EventType[\"Custom\"] = 5] = \"Custom\";\n  EventType[EventType[\"Plugin\"] = 6] = \"Plugin\";\n})(exports.tw || (exports.tw = {}));\n\nexports.yh = void 0;\n\n(function (IncrementalSource) {\n  IncrementalSource[IncrementalSource[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource[IncrementalSource[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource[IncrementalSource[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource[IncrementalSource[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource[IncrementalSource[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource[IncrementalSource[\"Input\"] = 5] = \"Input\";\n  IncrementalSource[IncrementalSource[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource[IncrementalSource[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource[IncrementalSource[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource[IncrementalSource[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource[IncrementalSource[\"Font\"] = 10] = \"Font\";\n  IncrementalSource[IncrementalSource[\"Log\"] = 11] = \"Log\";\n  IncrementalSource[IncrementalSource[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource[IncrementalSource[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n})(exports.yh || (exports.yh = {}));\n\nexports.Y2 = void 0;\n\n(function (MouseInteractions) {\n  MouseInteractions[MouseInteractions[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions[MouseInteractions[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions[MouseInteractions[\"Click\"] = 2] = \"Click\";\n  MouseInteractions[MouseInteractions[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions[MouseInteractions[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions[MouseInteractions[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions[MouseInteractions[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions[MouseInteractions[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions[MouseInteractions[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions[MouseInteractions[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions[MouseInteractions[\"TouchCancel\"] = 10] = \"TouchCancel\";\n})(exports.Y2 || (exports.Y2 = {}));\n\nvar CanvasContext;\n\n(function (CanvasContext) {\n  CanvasContext[CanvasContext[\"2D\"] = 0] = \"2D\";\n  CanvasContext[CanvasContext[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext[CanvasContext[\"WebGL2\"] = 2] = \"WebGL2\";\n})(CanvasContext || (CanvasContext = {}));\n\nvar MediaInteractions;\n\n(function (MediaInteractions) {\n  MediaInteractions[MediaInteractions[\"Play\"] = 0] = \"Play\";\n  MediaInteractions[MediaInteractions[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions[MediaInteractions[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions[MediaInteractions[\"VolumeChange\"] = 3] = \"VolumeChange\";\n})(MediaInteractions || (MediaInteractions = {}));\n\nexports.SA = void 0;\n\n(function (ReplayerEvents) {\n  ReplayerEvents[\"Start\"] = \"start\";\n  ReplayerEvents[\"Pause\"] = \"pause\";\n  ReplayerEvents[\"Resume\"] = \"resume\";\n  ReplayerEvents[\"Resize\"] = \"resize\";\n  ReplayerEvents[\"Finish\"] = \"finish\";\n  ReplayerEvents[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents[\"Flush\"] = \"flush\";\n  ReplayerEvents[\"StateChange\"] = \"state-change\";\n  ReplayerEvents[\"PlayBack\"] = \"play-back\";\n})(exports.SA || (exports.SA = {}));\n\nfunction on(type, fn, target) {\n  if (target === void 0) {\n    target = document;\n  }\n\n  var options = {\n    capture: true,\n    passive: type === 'scroll' ? true : false\n  };\n  target.addEventListener(type, fn, options);\n  return function () {\n    return target.removeEventListener(type, fn, options);\n  };\n}\n\nfunction createMirror() {\n  return {\n    map: {},\n    getId: function (n) {\n      if (!n || !n.__sn) {\n        return -1;\n      }\n\n      return n.__sn.id;\n    },\n    getNode: function (id) {\n      return this.map[id] || null;\n    },\n    removeNodeFromMap: function (n) {\n      var _this = this;\n\n      var id = n.__sn && n.__sn.id;\n      delete this.map[id];\n\n      if (n.childNodes) {\n        n.childNodes.forEach(function (child) {\n          return _this.removeNodeFromMap(child);\n        });\n      }\n    },\n    has: function (id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset: function () {\n      this.map = {};\n    }\n  };\n}\n\nvar DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' + '\\r\\n' + 'now you can use replayer.getMirror() to access the mirror instance of a replayer,' + '\\r\\n' + 'or you can use record.mirror to access the mirror instance during recording.';\nexports.hD = {\n  map: {},\n  getId: function () {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode: function () {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap: function () {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has: function () {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset: function () {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\n\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  exports.hD = new Proxy(exports.hD, {\n    get: function (target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\n\nfunction throttle(func, wait, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var timeout = null;\n  var previous = 0;\n  return function (arg) {\n    var now = Date.now();\n\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n\n    var remaining = wait - (now - previous);\n    var context = this;\n    var args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nfunction hookSetter(target, key, d, isRevoked, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(target, key, isRevoked ? d : {\n    set: function (value) {\n      var _this = this;\n\n      setTimeout(function () {\n        d.set.call(_this, value);\n      }, 0);\n\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    }\n  });\n  return function () {\n    return hookSetter(target, key, original || {}, true);\n  };\n}\n\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return function () {};\n    }\n\n    var original_1 = source[name];\n    var wrapped = replacement(original_1);\n\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original_1\n        }\n      });\n    }\n\n    source[name] = wrapped;\n    return function () {\n      source[name] = original_1;\n    };\n  } catch (_a) {\n    return function () {};\n  }\n}\n\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\n\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\n\nfunction isBlocked(node, blockClass) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    var needBlock_1 = false;\n\n    if (typeof blockClass === 'string') {\n      if (node.closest !== undefined) {\n        return node.closest('.' + blockClass) !== null;\n      } else {\n        needBlock_1 = node.classList.contains(blockClass);\n      }\n    } else {\n      node.classList.forEach(function (className) {\n        if (blockClass.test(className)) {\n          needBlock_1 = true;\n        }\n      });\n    }\n\n    return needBlock_1 || isBlocked(node.parentNode, blockClass);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    return isBlocked(node.parentNode, blockClass);\n  }\n\n  return isBlocked(node.parentNode, blockClass);\n}\n\nfunction isIgnored(n) {\n  if (!n || n.__sn) {\n    return false;\n  }\n\n  if ('__sn' in n) {\n    return n.__sn.id === IGNORED_NODE;\n  }\n\n  return false;\n}\n\nfunction isAncestorRemoved(target, mirror) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n\n  var id = mirror.getId(target);\n\n  if (!mirror.has(id)) {\n    return true;\n  }\n\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n\n  if (!target.parentNode) {\n    return true;\n  }\n\n  return isAncestorRemoved(target.parentNode, mirror);\n}\n\nfunction isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\n\nfunction polyfill$1(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n\n      return false;\n    };\n  }\n}\n\nvar TreeIndex = function () {\n  function TreeIndex() {\n    this.reset();\n  }\n\n  TreeIndex.prototype.add = function (mutation) {\n    var parentTreeNode = this.indexes.get(mutation.parentId);\n    var treeNode = {\n      id: mutation.node.id,\n      mutation: mutation,\n      children: [],\n      texts: [],\n      attributes: []\n    };\n\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n\n    this.indexes.set(treeNode.id, treeNode);\n  };\n\n  TreeIndex.prototype.remove = function (mutation, mirror) {\n    var _this = this;\n\n    var parentTreeNode = this.indexes.get(mutation.parentId);\n    var treeNode = this.indexes.get(mutation.id);\n\n    var deepRemoveFromMirror = function (id) {\n      _this.removeIdSet.add(id);\n\n      var node = mirror.getNode(id);\n      node === null || node === void 0 ? void 0 : node.childNodes.forEach(function (childNode) {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(childNode.__sn.id);\n        }\n      });\n    };\n\n    var deepRemoveFromTreeIndex = function (node) {\n      _this.removeIdSet.add(node.id);\n\n      Object.values(node.children).forEach(function (n) {\n        return deepRemoveFromTreeIndex(n);\n      });\n\n      var _treeNode = _this.indexes.get(node.id);\n\n      if (_treeNode) {\n        var _parentTreeNode = _treeNode.parent;\n\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n\n          _this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  };\n\n  TreeIndex.prototype.text = function (mutation) {\n    var treeNode = this.indexes.get(mutation.id);\n\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  };\n\n  TreeIndex.prototype.attribute = function (mutation) {\n    var treeNode = this.indexes.get(mutation.id);\n\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  };\n\n  TreeIndex.prototype.scroll = function (d) {\n    this.scrollMap.set(d.id, d);\n  };\n\n  TreeIndex.prototype.input = function (d) {\n    this.inputMap.set(d.id, d);\n  };\n\n  TreeIndex.prototype.flush = function () {\n    var e_1, _a, e_2, _b;\n\n    var _this = this;\n\n    var _c = this,\n        tree = _c.tree,\n        removeNodeMutations = _c.removeNodeMutations,\n        textMutations = _c.textMutations,\n        attributeMutations = _c.attributeMutations;\n\n    var batchMutationData = {\n      source: exports.yh.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: []\n    };\n\n    var walk = function (treeNode, removed) {\n      if (removed) {\n        _this.removeIdSet.add(treeNode.id);\n      }\n\n      batchMutationData.texts = batchMutationData.texts.concat(removed ? [] : treeNode.texts).filter(function (m) {\n        return !_this.removeIdSet.has(m.id);\n      });\n      batchMutationData.attributes = batchMutationData.attributes.concat(removed ? [] : treeNode.attributes).filter(function (m) {\n        return !_this.removeIdSet.has(m.id);\n      });\n\n      if (!_this.removeIdSet.has(treeNode.id) && !_this.removeIdSet.has(treeNode.mutation.parentId) && !removed) {\n        batchMutationData.adds.push(treeNode.mutation);\n\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach(function (n) {\n            return walk(n, false);\n          });\n        }\n      } else {\n        Object.values(treeNode.children).forEach(function (n) {\n          return walk(n, true);\n        });\n      }\n    };\n\n    Object.values(tree).forEach(function (n) {\n      return walk(n, false);\n    });\n\n    try {\n      for (var _d = __values(this.scrollMap.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var id = _e.value;\n\n        if (this.removeIdSet.has(id)) {\n          this.scrollMap.delete(id);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    try {\n      for (var _f = __values(this.inputMap.keys()), _g = _f.next(); !_g.done; _g = _f.next()) {\n        var id = _g.value;\n\n        if (this.removeIdSet.has(id)) {\n          this.inputMap.delete(id);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var scrollMap = new Map(this.scrollMap);\n    var inputMap = new Map(this.inputMap);\n    this.reset();\n    return {\n      mutationData: batchMutationData,\n      scrollMap: scrollMap,\n      inputMap: inputMap\n    };\n  };\n\n  TreeIndex.prototype.reset = function () {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  };\n\n  TreeIndex.prototype.idRemoved = function (id) {\n    return this.removeIdSet.has(id);\n  };\n\n  return TreeIndex;\n}();\n\nfunction queueToResolveTrees(queue) {\n  var e_3, _a;\n\n  var queueNodeMap = {};\n\n  var putIntoMap = function (m, parent) {\n    var nodeInTree = {\n      value: m,\n      parent: parent,\n      children: []\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  var queueNodeTrees = [];\n\n  try {\n    for (var queue_1 = __values(queue), queue_1_1 = queue_1.next(); !queue_1_1.done; queue_1_1 = queue_1.next()) {\n      var mutation = queue_1_1.value;\n      var nextId = mutation.nextId,\n          parentId = mutation.parentId;\n\n      if (nextId && nextId in queueNodeMap) {\n        var nextInTree = queueNodeMap[nextId];\n\n        if (nextInTree.parent) {\n          var idx = nextInTree.parent.children.indexOf(nextInTree);\n          nextInTree.parent.children.splice(idx, 0, putIntoMap(mutation, nextInTree.parent));\n        } else {\n          var idx = queueNodeTrees.indexOf(nextInTree);\n          queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n        }\n\n        continue;\n      }\n\n      if (parentId in queueNodeMap) {\n        var parentInTree = queueNodeMap[parentId];\n        parentInTree.children.push(putIntoMap(mutation, parentInTree));\n        continue;\n      }\n\n      queueNodeTrees.push(putIntoMap(mutation, null));\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (queue_1_1 && !queue_1_1.done && (_a = queue_1.return)) _a.call(queue_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return queueNodeTrees;\n}\n\nfunction iterateResolveTree(tree, cb) {\n  cb(tree.value);\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\nfunction isIframeINode(node) {\n  if ('__sn' in node) {\n    return node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe';\n  }\n\n  return false;\n}\n\nfunction getBaseDimension(node, rootIframe) {\n  var _a, _b;\n\n  var frameElement = (_b = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.frameElement;\n\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1\n    };\n  }\n\n  var frameDimension = frameElement.getBoundingClientRect();\n  var frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  var relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x: frameDimension.x * frameBaseDimension.relativeScale + frameBaseDimension.x,\n    y: frameDimension.y * frameBaseDimension.relativeScale + frameBaseDimension.y,\n    relativeScale: relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale\n  };\n}\n\nfunction hasShadowRoot(n) {\n  return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\n}\n\nfunction debounce(func, waitMilliseconds, options) {\n  if (options === void 0) {\n    options = {\n      isImmediate: false,\n      isTrailing: false\n    };\n  }\n\n  var timeoutId;\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var context = this;\n\n    var doLater = function () {\n      timeoutId = undefined;\n\n      if (!options.isImmediate || options.isTrailing) {\n        func.apply(context, args);\n      }\n    };\n\n    var shouldCallNow = options.isImmediate && timeoutId === undefined;\n\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(doLater, waitMilliseconds);\n\n    if (shouldCallNow) {\n      func.apply(context, args);\n    }\n  };\n}\n\nvar ORIGINAL_ATTRIBUTE_NAME$1 = '__rrweb_original__';\n\nfunction is2DCanvasBlank(canvas) {\n  var ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n  var chunkSize = 50;\n\n  for (var x = 0; x < canvas.width; x += chunkSize) {\n    for (var y = 0; y < canvas.height; y += chunkSize) {\n      var getImageData = ctx.getImageData;\n      var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME$1 in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME$1] : getImageData;\n      var pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n      if (pixelBuffer.some(function (pixel) {\n        return pixel !== 0;\n      })) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDisableRemoteControl(node) {\n  if (!node) {\n    return false;\n  }\n\n  var disableClass = 'cosee-disable-remote-control';\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    var needDisable = false;\n\n    if (node.closest !== undefined) {\n      return node.closest('.' + disableClass) !== null;\n    } else {\n      needDisable = node.classList.contains(disableClass);\n    }\n\n    return needDisable || isDisableRemoteControl(node.parentNode);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    return isDisableRemoteControl(node.parentNode);\n  }\n\n  return isDisableRemoteControl(node.parentNode);\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  on: on,\n  createMirror: createMirror,\n\n  get _mirror() {\n    return exports.hD;\n  },\n\n  throttle: throttle,\n  hookSetter: hookSetter,\n  patch: patch,\n  getWindowHeight: getWindowHeight,\n  getWindowWidth: getWindowWidth,\n  isBlocked: isBlocked,\n  isIgnored: isIgnored,\n  isAncestorRemoved: isAncestorRemoved,\n  isTouchEvent: isTouchEvent,\n  polyfill: polyfill$1,\n  TreeIndex: TreeIndex,\n  queueToResolveTrees: queueToResolveTrees,\n  iterateResolveTree: iterateResolveTree,\n  isIframeINode: isIframeINode,\n  getBaseDimension: getBaseDimension,\n  hasShadowRoot: hasShadowRoot,\n  debounce: debounce,\n  is2DCanvasBlank: is2DCanvasBlank,\n  isDisableRemoteControl: isDisableRemoteControl\n});\n\nfunction isNodeInLinkedList(n) {\n  return '__ln' in n;\n}\n\nvar DoubleLinkedList = function () {\n  function DoubleLinkedList() {\n    this.length = 0;\n    this.head = null;\n  }\n\n  DoubleLinkedList.prototype.get = function (position) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    var current = this.head;\n\n    for (var index = 0; index < position; index++) {\n      current = (current === null || current === void 0 ? void 0 : current.next) || null;\n    }\n\n    return current;\n  };\n\n  DoubleLinkedList.prototype.addNode = function (n) {\n    var node = {\n      value: n,\n      previous: null,\n      next: null\n    };\n    n.__ln = node;\n\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      var current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n      var current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n\n      node.next = this.head;\n      this.head = node;\n    }\n\n    this.length++;\n  };\n\n  DoubleLinkedList.prototype.removeNode = function (n) {\n    var current = n.__ln;\n\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n\n    if (n.__ln) {\n      delete n.__ln;\n    }\n\n    this.length--;\n  };\n\n  return DoubleLinkedList;\n}();\n\nvar moveKey = function (id, parentId) {\n  return \"\".concat(id, \"@\").concat(parentId);\n};\n\nfunction isINode(n) {\n  return '__sn' in n;\n}\n\nvar MutationBuffer = function () {\n  function MutationBuffer() {\n    var _this = this;\n\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = new Set();\n    this.movedSet = new Set();\n    this.droppedSet = new Set();\n\n    this.processMutations = function (mutations) {\n      mutations.forEach(_this.processMutation);\n\n      _this.emit();\n    };\n\n    this.emit = function () {\n      var e_1, _a, e_2, _b;\n\n      if (_this.frozen || _this.locked) {\n        return;\n      }\n\n      var adds = [];\n      var addList = new DoubleLinkedList();\n\n      var getNextId = function (n) {\n        var ns = n;\n        var nextId = IGNORED_NODE;\n\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && _this.mirror.getId(ns);\n        }\n\n        return nextId;\n      };\n\n      var pushAdd = function (n) {\n        var _a, _b, _c, _d, _e;\n\n        var shadowHost = n.getRootNode ? (_a = n.getRootNode()) === null || _a === void 0 ? void 0 : _a.host : null;\n        var rootShadowHost = shadowHost;\n\n        while ((_c = (_b = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _b === void 0 ? void 0 : _b.call(rootShadowHost)) === null || _c === void 0 ? void 0 : _c.host) rootShadowHost = ((_e = (_d = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _d === void 0 ? void 0 : _d.call(rootShadowHost)) === null || _e === void 0 ? void 0 : _e.host) || null;\n\n        var notInDoc = !_this.doc.contains(n) && (!rootShadowHost || !_this.doc.contains(rootShadowHost));\n\n        if (!n.parentNode || notInDoc) {\n          return;\n        }\n\n        var parentId = isShadowRoot(n.parentNode) ? _this.mirror.getId(shadowHost) : _this.mirror.getId(n.parentNode);\n        var nextId = getNextId(n);\n\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n);\n        }\n\n        var sn = serializeNodeWithId(n, {\n          doc: _this.doc,\n          map: _this.mirror.map,\n          blockClass: _this.blockClass,\n          blockSelector: _this.blockSelector,\n          maskTextClass: _this.maskTextClass,\n          maskTextSelector: _this.maskTextSelector,\n          skipChild: true,\n          inlineStylesheet: _this.inlineStylesheet,\n          maskInputOptions: _this.maskInputOptions,\n          maskTextFn: _this.maskTextFn,\n          maskInputFn: _this.maskInputFn,\n          slimDOMOptions: _this.slimDOMOptions,\n          recordCanvas: _this.recordCanvas,\n          inlineImages: _this.inlineImages,\n          onSerialize: function (currentN) {\n            if (isIframeINode(currentN)) {\n              _this.iframeManager.addIframe(currentN);\n            }\n\n            if (hasShadowRoot(n)) {\n              _this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n            }\n          },\n          onIframeLoad: function (iframe, childSn) {\n            _this.iframeManager.attachIframe(iframe, childSn);\n\n            _this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          disableRemoteControlFn: _this.disableRemoteControlFn\n        });\n\n        if (sn) {\n          adds.push({\n            parentId: parentId,\n            nextId: nextId,\n            node: sn\n          });\n        }\n      };\n\n      while (_this.mapRemoves.length) {\n        _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n      }\n\n      try {\n        for (var _c = __values(_this.movedSet), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var n = _d.value;\n\n          if (isParentRemoved(_this.removes, n, _this.mirror) && !_this.movedSet.has(n.parentNode)) {\n            continue;\n          }\n\n          pushAdd(n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _e = __values(_this.addedSet), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var n = _f.value;\n\n          if (!isAncestorInSet(_this.droppedSet, n) && !isParentRemoved(_this.removes, n, _this.mirror)) {\n            pushAdd(n);\n          } else if (isAncestorInSet(_this.movedSet, n)) {\n            pushAdd(n);\n          } else {\n            _this.droppedSet.add(n);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      var needSnapshot = false;\n      var candidate = null;\n\n      while (addList.length) {\n        var node = null;\n\n        if (candidate) {\n          var parentId = _this.mirror.getId(candidate.value.parentNode);\n\n          var nextId = getNextId(candidate.value);\n\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n\n        if (!node) {\n          for (var index = addList.length - 1; index >= 0; index--) {\n            var _node = addList.get(index);\n\n            if (_node) {\n              var parentId = _this.mirror.getId(_node.value.parentNode);\n\n              var nextId = getNextId(_node.value);\n\n              if (parentId !== -1 && nextId !== -1) {\n                node = _node;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n\n          if (adds.length <= 0 || adds.length < _this.addedSet.size) {\n            needSnapshot = true;\n          }\n\n          break;\n        }\n\n        if (node) {\n          candidate = node.previous;\n          addList.removeNode(node.value);\n          pushAdd(node.value);\n        }\n      }\n\n      if (needSnapshot) {\n        _this.texts = [];\n        _this.attributes = [];\n        _this.removes = [];\n        _this.addedSet = new Set();\n        _this.movedSet = new Set();\n        _this.droppedSet = new Set();\n        _this.movedMap = {};\n\n        _this.takeFullSnapshot();\n\n        console.warn('mutation : take snapshot');\n        return;\n      }\n\n      var payload = {\n        texts: _this.texts.map(function (text) {\n          return {\n            id: _this.mirror.getId(text.node),\n            value: text.value\n          };\n        }).filter(function (text) {\n          return _this.mirror.has(text.id);\n        }),\n        attributes: _this.attributes.map(function (attribute) {\n          return {\n            id: _this.mirror.getId(attribute.node),\n            attributes: attribute.attributes\n          };\n        }).filter(function (attribute) {\n          return _this.mirror.has(attribute.id);\n        }),\n        removes: _this.removes,\n        adds: adds\n      };\n\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n\n      _this.texts = [];\n      _this.attributes = [];\n      _this.removes = [];\n      _this.addedSet = new Set();\n      _this.movedSet = new Set();\n      _this.droppedSet = new Set();\n      _this.movedMap = {};\n\n      _this.mutationCb(payload);\n    };\n\n    this.processMutation = function (m) {\n      var e_3, _a, e_4, _b;\n\n      if (isIgnored(m.target)) {\n        return;\n      }\n\n      if (_this.isContainIgnoreClass(m.target)) {\n        return;\n      }\n\n      switch (m.type) {\n        case 'characterData':\n          {\n            var value = m.target.textContent;\n\n            if (_this.disableRemoteControlFn && m.target) {\n              if (isDisableRemoteControl(m.target)) {\n                _this.disableRemoteControlFn(window.location.href, true);\n              } else {\n                _this.disableRemoteControlFn(window.location.href, false);\n              }\n            }\n\n            if (!isBlocked(m.target, _this.blockClass) && value !== m.oldValue) {\n              var classList = '';\n\n              if (m.target.nodeType === m.target.ELEMENT_NODE) {\n                classList = m.target.classList.value;\n              }\n\n              if (m.target.nodeType === m.target.TEXT_NODE) {\n                classList = m.target.parentNode.classList.value;\n              }\n\n              _this.texts.push({\n                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector) && value ? _this.maskTextFn ? _this.maskTextFn(value, classList) : value.replace(/[\\S]/g, '*') : value,\n                node: m.target\n              });\n            }\n\n            break;\n          }\n\n        case 'attributes':\n          {\n            var target = m.target;\n            var value = m.target.getAttribute(m.attributeName);\n\n            if (m.attributeName === 'value') {\n              var classList = '';\n\n              if (m.target.nodeType === m.target.ELEMENT_NODE) {\n                classList = m.target.classList.value;\n              }\n\n              if (m.target.nodeType === m.target.TEXT_NODE) {\n                classList = m.target.parentNode.classList.value;\n              }\n\n              value = maskInputValue({\n                maskInputOptions: _this.maskInputOptions,\n                tagName: m.target.tagName,\n                type: m.target.getAttribute('type'),\n                value: value,\n                maskInputFn: _this.maskInputFn,\n                classList: classList\n              });\n            }\n\n            if (isBlocked(m.target, _this.blockClass) || value === m.oldValue) {\n              return;\n            }\n\n            var item = _this.attributes.find(function (a) {\n              return a.node === m.target;\n            });\n\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {}\n              };\n\n              _this.attributes.push(item);\n            }\n\n            if (m.attributeName === 'style') {\n              var old = _this.doc.createElement('span');\n\n              if (m.oldValue) {\n                old.setAttribute('style', m.oldValue);\n              }\n\n              if (item.attributes.style === undefined || item.attributes.style === null) {\n                item.attributes.style = {};\n              }\n\n              var styleObj = item.attributes.style;\n\n              try {\n                for (var _c = __values(Array.from(target.style)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                  var pname = _d.value;\n                  var newValue = target.style.getPropertyValue(pname);\n                  var newPriority = target.style.getPropertyPriority(pname);\n\n                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                    if (newPriority === '') {\n                      styleObj[pname] = newValue;\n                    } else {\n                      styleObj[pname] = [newValue, newPriority];\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n\n              try {\n                for (var _e = __values(Array.from(old.style)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var pname = _f.value;\n\n                  if (target.style.getPropertyValue(pname) === '') {\n                    styleObj[pname] = false;\n                  }\n                }\n              } catch (e_4_1) {\n                e_4 = {\n                  error: e_4_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_4) throw e_4.error;\n                }\n              }\n            } else {\n              item.attributes[m.attributeName] = transformAttribute(_this.doc, m.target.tagName, m.attributeName, value);\n            }\n\n            break;\n          }\n\n        case 'childList':\n          {\n            var isNodeAdded_1 = false;\n            m.addedNodes.forEach(function (n) {\n              _this.genAdds(n, m.target);\n\n              isNodeAdded_1 = true;\n            });\n            m.removedNodes.forEach(function (n) {\n              if (isNodeAdded_1 && _this.addedSet.has(n)) {\n                return;\n              }\n\n              if (_this.isContainIgnoreClass(n)) {\n                return;\n              }\n\n              var nodeId = _this.mirror.getId(n);\n\n              var parentId = isShadowRoot(m.target) ? _this.mirror.getId(m.target.host) : _this.mirror.getId(m.target);\n\n              if (isBlocked(m.target, _this.blockClass) || isIgnored(n)) {\n                return;\n              }\n\n              if (_this.addedSet.has(n)) {\n                deepDelete(_this.addedSet, n);\n\n                _this.droppedSet.add(n);\n              } else if (_this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target, _this.mirror)) ;else if (_this.movedSet.has(n) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(_this.movedSet, n);\n              } else {\n                _this.removes.push({\n                  parentId: parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot(m.target) ? true : undefined\n                });\n              }\n\n              _this.mapRemoves.push(n);\n            });\n            break;\n          }\n      }\n    };\n\n    this.genAdds = function (n, target) {\n      if (_this.disableRemoteControlFn && target) {\n        if (isDisableRemoteControl(target)) {\n          _this.disableRemoteControlFn(window.location.href, true);\n        } else {\n          _this.disableRemoteControlFn(window.location.href, false);\n        }\n      }\n\n      if (target && isBlocked(target, _this.blockClass)) {\n        return;\n      }\n\n      if (target && isIgnored(target)) {\n        return;\n      }\n\n      if (_this.isContainIgnoreClass(target)) {\n        return;\n      }\n\n      if (_this.isContainIgnoreClass(n)) {\n        return;\n      }\n\n      if (isINode(n)) {\n        if (isIgnored(n)) {\n          return;\n        }\n\n        _this.movedSet.add(n);\n\n        var targetId = null;\n\n        if (target && isINode(target)) {\n          targetId = target.__sn.id;\n        }\n\n        if (targetId) {\n          _this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n        }\n      } else {\n        _this.addedSet.add(n);\n\n        _this.droppedSet.delete(n);\n      }\n\n      if (!isBlocked(n, _this.blockClass)) n.childNodes.forEach(function (childN) {\n        return _this.genAdds(childN);\n      });\n    };\n  }\n\n  MutationBuffer.prototype.init = function (options, takeFullSnapshot) {\n    var _this = this;\n\n    ['mutationCb', 'blockClass', 'blockSelector', 'maskTextClass', 'maskTextSelector', 'inlineStylesheet', 'maskInputOptions', 'maskTextFn', 'maskInputFn', 'recordCanvas', 'inlineImages', 'slimDOMOptions', 'doc', 'mirror', 'iframeManager', 'shadowDomManager', 'canvasManager', 'ignoreClass', 'disableRemoteControlFn'].forEach(function (key) {\n      _this[key] = options[key];\n    });\n    this.takeFullSnapshot = takeFullSnapshot;\n  };\n\n  MutationBuffer.prototype.freeze = function () {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  };\n\n  MutationBuffer.prototype.unfreeze = function () {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  };\n\n  MutationBuffer.prototype.isFrozen = function () {\n    return this.frozen;\n  };\n\n  MutationBuffer.prototype.lock = function () {\n    this.locked = true;\n    this.canvasManager.lock();\n  };\n\n  MutationBuffer.prototype.unlock = function () {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  };\n\n  MutationBuffer.prototype.reset = function () {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  };\n\n  MutationBuffer.prototype.isContainIgnoreClass = function (target) {\n    if (!this.ignoreClass || !target) {\n      return false;\n    }\n\n    if (target.classList && target.classList.contains(this.ignoreClass)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return MutationBuffer;\n}();\n\nfunction deepDelete(addsSet, n) {\n  addsSet.delete(n);\n  n.childNodes.forEach(function (childN) {\n    return deepDelete(addsSet, childN);\n  });\n}\n\nfunction isParentRemoved(removes, n, mirror) {\n  var parentNode = n.parentNode;\n\n  if (!parentNode) {\n    return false;\n  }\n\n  var parentId = mirror.getId(parentNode);\n\n  if (removes.some(function (r) {\n    return r.id === parentId;\n  })) {\n    return true;\n  }\n\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set, n) {\n  var parentNode = n.parentNode;\n\n  if (!parentNode) {\n    return false;\n  }\n\n  if (set.has(parentNode)) {\n    return true;\n  }\n\n  return isAncestorInSet(set, parentNode);\n}\n\nvar mutationBuffers = [];\nvar remoteControllParam = {\n  controlling: false,\n  scroll: false\n};\nvar isCSSGroupingRuleSupported = typeof CSSGroupingRule !== 'undefined';\nvar isCSSMediaRuleSupported = typeof CSSMediaRule !== 'undefined';\nvar isCSSSupportsRuleSupported = typeof CSSSupportsRule !== 'undefined';\nvar isCSSConditionRuleSupported = typeof CSSConditionRule !== 'undefined';\n\nfunction getEventTarget(event) {\n  try {\n    if ('composedPath' in event) {\n      var path = event.composedPath();\n\n      if (path.length) {\n        return path[0];\n      }\n    } else if ('path' in event && event.path.length) {\n      return event.path[0];\n    }\n\n    return event.target;\n  } catch (_a) {\n    return event.target;\n  }\n}\n\nfunction initMutationObserver(options, rootEl, takeFullSnapshot) {\n  var _a, _b;\n\n  var mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options, takeFullSnapshot);\n  var mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n  var angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, 'MutationObserver');\n\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n\n  var observer = new mutationObserverCtor(mutationBuffer.processMutations.bind(mutationBuffer));\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction initMoveObserver(_a) {\n  var mousemoveCb = _a.mousemoveCb,\n      sampling = _a.sampling,\n      doc = _a.doc,\n      mirror = _a.mirror;\n\n  if (sampling.mousemove === false) {\n    return function () {};\n  }\n\n  var threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  var callbackThreshold = typeof sampling.mousemoveCallback === 'number' ? sampling.mousemoveCallback : 500;\n  var positions = [];\n  var timeBaseline;\n  var wrappedCb = throttle(function (source) {\n    var totalOffset = Date.now() - timeBaseline;\n    mousemoveCb(positions.map(function (p) {\n      p.timeOffset -= totalOffset;\n      return p;\n    }), source);\n    positions = [];\n    timeBaseline = null;\n  }, callbackThreshold);\n  var updatePosition = throttle(function (evt) {\n    var target = getEventTarget(evt);\n\n    var _a = isTouchEvent(evt) ? evt.changedTouches[0] : evt,\n        clientX = _a.clientX,\n        clientY = _a.clientY;\n\n    if (!timeBaseline) {\n      timeBaseline = Date.now();\n    }\n\n    positions.push({\n      x: clientX,\n      y: clientY,\n      id: mirror.getId(target),\n      timeOffset: Date.now() - timeBaseline\n    });\n    wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent ? exports.yh.Drag : evt instanceof MouseEvent ? exports.yh.MouseMove : exports.yh.TouchMove);\n  }, threshold, {\n    trailing: false\n  });\n  var handlers = [on('mousemove', updatePosition, doc), on('touchmove', updatePosition, doc), on('drag', updatePosition, doc)];\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initMouseInteractionObserver(_a) {\n  var mouseInteractionCb = _a.mouseInteractionCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      sampling = _a.sampling;\n\n  if (sampling.mouseInteraction === false) {\n    return function () {};\n  }\n\n  var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;\n  var handlers = [];\n\n  var getHandler = function (eventKey) {\n    return function (event) {\n      if (remoteControllParam.controlling && !event.isTrusted) {\n        return;\n      }\n\n      var target = getEventTarget(event);\n\n      if (isBlocked(target, blockClass)) {\n        return;\n      }\n\n      var e = isTouchEvent(event) ? event.changedTouches[0] : event;\n\n      if (!e) {\n        return;\n      }\n\n      var id = mirror.getId(target);\n      var clientX = e.clientX,\n          clientY = e.clientY;\n      mouseInteractionCb({\n        type: exports.Y2[eventKey],\n        id: id,\n        x: clientX,\n        y: clientY\n      });\n    };\n  };\n\n  Object.keys(exports.Y2).filter(function (key) {\n    return Number.isNaN(Number(key)) && !key.endsWith('_Departed') && disableMap[key] !== false;\n  }).forEach(function (eventKey) {\n    var eventName = eventKey.toLowerCase();\n    var handler = getHandler(eventKey);\n    handlers.push(on(eventName, handler, doc));\n  });\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initScrollObserver(_a) {\n  var scrollCb = _a.scrollCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      sampling = _a.sampling;\n  var updatePosition = throttle(function (evt) {\n    var target = getEventTarget(evt);\n\n    if (!target || isBlocked(target, blockClass)) {\n      return;\n    }\n\n    var id = mirror.getId(target);\n\n    if (target === doc) {\n      var scrollEl = doc.scrollingElement || doc.documentElement;\n      scrollCb({\n        id: id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n        controlling: remoteControllParam.controlling\n      });\n    } else {\n      scrollCb({\n        id: id,\n        x: target.scrollLeft,\n        y: target.scrollTop,\n        controlling: remoteControllParam.controlling\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition, doc);\n}\n\nfunction initViewportResizeObserver(_a) {\n  var viewportResizeCb = _a.viewportResizeCb;\n  var lastH = -1;\n  var lastW = -1;\n  var updateDimension = throttle(function () {\n    var height = getWindowHeight();\n    var width = getWindowWidth();\n\n    if (lastH !== height || lastW !== width) {\n      viewportResizeCb({\n        width: Number(width),\n        height: Number(height)\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nfunction wrapEventWithUserTriggeredFlag(v, enable) {\n  var value = __assign({}, v);\n\n  if (!enable) delete value.userTriggered;\n  return value;\n}\n\nvar INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nvar lastInputValueMap = new WeakMap();\n\nfunction initInputObserver(_a) {\n  var inputCb = _a.inputCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      ignoreClass = _a.ignoreClass,\n      maskInputOptions = _a.maskInputOptions,\n      maskInputFn = _a.maskInputFn,\n      sampling = _a.sampling,\n      userTriggeredOnInput = _a.userTriggeredOnInput;\n\n  function eventHandler(event) {\n    var target = getEventTarget(event);\n    var userTriggered = event.isTrusted;\n    if (target && target.tagName === 'OPTION') target = target.parentElement;\n\n    if (!target || !target.tagName || INPUT_TAGS.indexOf(target.tagName) < 0 || isBlocked(target, blockClass)) {\n      return;\n    }\n\n    var type = target.type;\n\n    if (ignoreClass && target.classList.contains(ignoreClass)) {\n      return;\n    }\n\n    if (remoteControllParam.controlling && !event.isTrusted && type !== 'text') {\n      return;\n    }\n\n    var text = target.value;\n    var isChecked = false;\n\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = target.checked;\n    } else if (maskInputOptions[target.tagName.toLowerCase()] || maskInputOptions[type]) {\n      var classList = '';\n\n      if (target.nodeType === target.ELEMENT_NODE) {\n        classList = target.classList.value;\n      }\n\n      if (target.nodeType === target.TEXT_NODE) {\n        classList = target.parentNode.classList.value;\n      }\n\n      text = maskInputValue({\n        maskInputOptions: maskInputOptions,\n        tagName: target.tagName,\n        type: type,\n        value: text,\n        maskInputFn: maskInputFn,\n        classList: classList\n      });\n    }\n\n    cbWithDedup(target, wrapEventWithUserTriggeredFlag({\n      text: text,\n      isChecked: isChecked,\n      userTriggered: userTriggered\n    }, userTriggeredOnInput));\n    var name = target.name;\n\n    if (type === 'radio' && name && isChecked) {\n      doc.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\".concat(name, \"\\\"]\")).forEach(function (el) {\n        if (el !== target) {\n          cbWithDedup(el, wrapEventWithUserTriggeredFlag({\n            text: el.value,\n            isChecked: !isChecked,\n            userTriggered: false\n          }, userTriggeredOnInput));\n        }\n      });\n    }\n  }\n\n  function cbWithDedup(target, v) {\n    var lastInputValue = lastInputValueMap.get(target);\n\n    if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n      lastInputValueMap.set(target, v);\n      var id = mirror.getId(target);\n      inputCb(__assign(__assign({}, v), {\n        id: id\n      }));\n    }\n  }\n\n  var events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  var handlers = events.map(function (eventName) {\n    return on(eventName, eventHandler, doc);\n  });\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');\n  var hookProperties = [[HTMLInputElement.prototype, 'value'], [HTMLInputElement.prototype, 'checked'], [HTMLSelectElement.prototype, 'value'], [HTMLTextAreaElement.prototype, 'value'], [HTMLSelectElement.prototype, 'selectedIndex'], [HTMLOptionElement.prototype, 'selected']];\n\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push.apply(handlers, __spreadArray([], __read(hookProperties.map(function (p) {\n      return hookSetter(p[0], p[1], {\n        set: function () {\n          eventHandler({\n            target: this\n          });\n        }\n      });\n    })), false));\n  }\n\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction getNestedCSSRulePositions(rule) {\n  var positions = [];\n\n  function recurse(childRule, pos) {\n    if (isCSSGroupingRuleSupported && childRule.parentRule instanceof CSSGroupingRule || isCSSMediaRuleSupported && childRule.parentRule instanceof CSSMediaRule || isCSSSupportsRuleSupported && childRule.parentRule instanceof CSSSupportsRule || isCSSConditionRuleSupported && childRule.parentRule instanceof CSSConditionRule) {\n      var rules = Array.from(childRule.parentRule.cssRules);\n      var index = rules.indexOf(childRule);\n      pos.unshift(index);\n    } else {\n      var rules = Array.from(childRule.parentStyleSheet.cssRules);\n      var index = rules.indexOf(childRule);\n      pos.unshift(index);\n    }\n\n    return pos;\n  }\n\n  return recurse(rule, positions);\n}\n\nfunction initStyleSheetObserver(_a, _b) {\n  var styleSheetRuleCb = _a.styleSheetRuleCb,\n      mirror = _a.mirror;\n  var win = _b.win;\n  var insertRule = win.CSSStyleSheet.prototype.insertRule;\n\n  win.CSSStyleSheet.prototype.insertRule = function (rule, index) {\n    var id = mirror.getId(this.ownerNode);\n\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id: id,\n        adds: [{\n          rule: rule,\n          index: index\n        }]\n      });\n    }\n\n    return insertRule.apply(this, arguments);\n  };\n\n  var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n\n  win.CSSStyleSheet.prototype.deleteRule = function (index) {\n    var id = mirror.getId(this.ownerNode);\n\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id: id,\n        removes: [{\n          index: index\n        }]\n      });\n    }\n\n    return deleteRule.apply(this, arguments);\n  };\n\n  var supportedNestedCSSRuleTypes = {};\n\n  if (isCSSGroupingRuleSupported) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (isCSSMediaRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n\n    if (isCSSConditionRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n\n    if (isCSSSupportsRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n\n  var unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        typeKey = _b[0],\n        type = _b[1];\n\n    unmodifiedFunctions[typeKey] = {\n      insertRule: type.prototype.insertRule,\n      deleteRule: type.prototype.deleteRule\n    };\n\n    type.prototype.insertRule = function (rule, index) {\n      var id = mirror.getId(this.parentStyleSheet.ownerNode);\n\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id: id,\n          adds: [{\n            rule: rule,\n            index: __spreadArray(__spreadArray([], __read(getNestedCSSRulePositions(this)), false), [index || 0], false)\n          }]\n        });\n      }\n\n      return unmodifiedFunctions[typeKey].insertRule.apply(this, arguments);\n    };\n\n    type.prototype.deleteRule = function (index) {\n      var id = mirror.getId(this.parentStyleSheet.ownerNode);\n\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id: id,\n          removes: [{\n            index: __spreadArray(__spreadArray([], __read(getNestedCSSRulePositions(this)), false), [index], false)\n          }]\n        });\n      }\n\n      return unmodifiedFunctions[typeKey].deleteRule.apply(this, arguments);\n    };\n  });\n  return function () {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          typeKey = _b[0],\n          type = _b[1];\n\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  };\n}\n\nfunction initStyleDeclarationObserver(_a, _b) {\n  var styleDeclarationCb = _a.styleDeclarationCb,\n      mirror = _a.mirror;\n  var win = _b.win;\n  var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n\n  win.CSSStyleDeclaration.prototype.setProperty = function (property, value, priority) {\n    var _a, _b;\n\n    var id = mirror.getId((_b = (_a = this.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet) === null || _b === void 0 ? void 0 : _b.ownerNode);\n\n    if (id !== -1) {\n      styleDeclarationCb({\n        id: id,\n        set: {\n          property: property,\n          value: value,\n          priority: priority\n        },\n        index: getNestedCSSRulePositions(this.parentRule)\n      });\n    }\n\n    return setProperty.apply(this, arguments);\n  };\n\n  var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n\n  win.CSSStyleDeclaration.prototype.removeProperty = function (property) {\n    var _a, _b;\n\n    var id = mirror.getId((_b = (_a = this.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet) === null || _b === void 0 ? void 0 : _b.ownerNode);\n\n    if (id !== -1) {\n      styleDeclarationCb({\n        id: id,\n        remove: {\n          property: property\n        },\n        index: getNestedCSSRulePositions(this.parentRule)\n      });\n    }\n\n    return removeProperty.apply(this, arguments);\n  };\n\n  return function () {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  };\n}\n\nfunction initMediaInteractionObserver(_a) {\n  var mediaInteractionCb = _a.mediaInteractionCb,\n      blockClass = _a.blockClass,\n      mirror = _a.mirror,\n      sampling = _a.sampling;\n\n  var handler = function (type) {\n    return throttle(function (event) {\n      var target = getEventTarget(event);\n\n      if (!target || isBlocked(target, blockClass)) {\n        return;\n      }\n\n      var _a = target,\n          currentTime = _a.currentTime,\n          volume = _a.volume,\n          muted = _a.muted;\n      mediaInteractionCb({\n        type: type,\n        id: mirror.getId(target),\n        currentTime: currentTime,\n        volume: volume,\n        muted: muted\n      });\n    }, sampling.media || 500);\n  };\n\n  var handlers = [on('play', handler(0)), on('pause', handler(1)), on('seeked', handler(2)), on('volumechange', handler(3))];\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initFontObserver(_a) {\n  var fontCb = _a.fontCb,\n      doc = _a.doc;\n  var win = doc.defaultView;\n\n  if (!win) {\n    return function () {};\n  }\n\n  var handlers = [];\n  var fontMap = new WeakMap();\n  var originalFontFace = win.FontFace;\n\n  win.FontFace = function FontFace(family, source, descriptors) {\n    var fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family: family,\n      buffer: typeof source !== 'string',\n      descriptors: descriptors,\n      fontSource: typeof source === 'string' ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n\n  var restoreHandler = patch(doc.fonts, 'add', function (original) {\n    return function (fontFace) {\n      setTimeout(function () {\n        var p = fontMap.get(fontFace);\n\n        if (p) {\n          fontCb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n  handlers.push(function () {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction mergeHooks(o, hooks) {\n  var mutationCb = o.mutationCb,\n      mousemoveCb = o.mousemoveCb,\n      mouseInteractionCb = o.mouseInteractionCb,\n      scrollCb = o.scrollCb,\n      viewportResizeCb = o.viewportResizeCb,\n      inputCb = o.inputCb,\n      mediaInteractionCb = o.mediaInteractionCb,\n      styleSheetRuleCb = o.styleSheetRuleCb,\n      styleDeclarationCb = o.styleDeclarationCb,\n      canvasMutationCb = o.canvasMutationCb,\n      fontCb = o.fontCb;\n\n  o.mutationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mutation) {\n      hooks.mutation.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mutationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mousemoveCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mousemove) {\n      hooks.mousemove.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mousemoveCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mouseInteractionCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mouseInteractionCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.scrollCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.scroll) {\n      hooks.scroll.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    scrollCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.viewportResizeCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.viewportResize) {\n      hooks.viewportResize.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    viewportResizeCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.inputCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.input) {\n      hooks.input.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    inputCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mediaInteractionCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mediaInteractionCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.styleSheetRuleCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    styleSheetRuleCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.styleDeclarationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.styleDeclaration) {\n      hooks.styleDeclaration.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    styleDeclarationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.canvasMutationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    canvasMutationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.fontCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.font) {\n      hooks.font.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    fontCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n}\n\nfunction initObservers(o, hooks, takeFullSnapshot) {\n  var e_1, _a;\n\n  if (hooks === void 0) {\n    hooks = {};\n  }\n\n  var currentWindow = o.doc.defaultView;\n\n  if (!currentWindow) {\n    return function () {};\n  }\n\n  mergeHooks(o, hooks);\n  var mutationObserver = initMutationObserver(o, o.doc, takeFullSnapshot);\n  var mousemoveHandler = initMoveObserver(o);\n  var mouseInteractionHandler = initMouseInteractionObserver(o);\n  var scrollHandler = initScrollObserver(o);\n  var viewportResizeHandler = initViewportResizeObserver(o);\n  var inputHandler = initInputObserver(o);\n  var mediaInteractionHandler = initMediaInteractionObserver(o);\n  var styleSheetObserver = initStyleSheetObserver(o, {\n    win: currentWindow\n  });\n  var styleDeclarationObserver = initStyleDeclarationObserver(o, {\n    win: currentWindow\n  });\n  var fontObserver = o.collectFonts ? initFontObserver(o) : function () {};\n  var pluginHandlers = [];\n\n  try {\n    for (var _b = __values(o.plugins), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var plugin = _c.value;\n      pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return function () {\n    mutationBuffers.forEach(function (b) {\n      return b.reset();\n    });\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    pluginHandlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nvar IframeManager = function () {\n  function IframeManager(options) {\n    this.iframes = new WeakMap();\n    this.mutationCb = options.mutationCb;\n  }\n\n  IframeManager.prototype.addIframe = function (iframeEl) {\n    this.iframes.set(iframeEl, true);\n  };\n\n  IframeManager.prototype.addLoadListener = function (cb) {\n    this.loadListener = cb;\n  };\n\n  IframeManager.prototype.attachIframe = function (iframeEl, childSn) {\n    var _a;\n\n    this.mutationCb({\n      adds: [{\n        parentId: iframeEl.__sn.id,\n        nextId: null,\n        node: childSn\n      }],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\n  };\n\n  return IframeManager;\n}();\n\nvar ShadowDomManager = function () {\n  function ShadowDomManager(options) {\n    this.restorePatches = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.takeFullSnapshot = options.takeFullSnapshot;\n    var manager = this;\n    this.restorePatches.push(patch(HTMLElement.prototype, 'attachShadow', function (original) {\n      return function () {\n        var shadowRoot = original.apply(this, arguments);\n        if (this.shadowRoot) manager.addShadowRoot(this.shadowRoot, this.ownerDocument);\n        return shadowRoot;\n      };\n    }));\n  }\n\n  ShadowDomManager.prototype.addShadowRoot = function (shadowRoot, doc) {\n    initMutationObserver(__assign(__assign({}, this.bypassOptions), {\n      doc: doc,\n      mutationCb: this.mutationCb,\n      mirror: this.mirror,\n      shadowDomManager: this\n    }), shadowRoot, this.takeFullSnapshot);\n    initScrollObserver(__assign(__assign({}, this.bypassOptions), {\n      scrollCb: this.scrollCb,\n      doc: shadowRoot,\n      mirror: this.mirror\n    }));\n  };\n\n  ShadowDomManager.prototype.observeAttachShadow = function (iframeElement) {\n    if (iframeElement.contentWindow) {\n      var manager_1 = this;\n      this.restorePatches.push(patch(iframeElement.contentWindow.HTMLElement.prototype, 'attachShadow', function (original) {\n        return function () {\n          var shadowRoot = original.apply(this, arguments);\n          if (this.shadowRoot) manager_1.addShadowRoot(this.shadowRoot, iframeElement.contentDocument);\n          return shadowRoot;\n        };\n      }));\n    }\n  };\n\n  ShadowDomManager.prototype.reset = function () {\n    this.restorePatches.forEach(function (restorePatch) {\n      return restorePatch();\n    });\n  };\n\n  return ShadowDomManager;\n}();\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, mirror, ignoreClass) {\n  var e_1, _a;\n\n  var handlers = [];\n  var props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n\n  var _loop_1 = function (prop) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\n        return \"continue\";\n      }\n\n      var restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\n        return function () {\n          var _this = this;\n\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var isIgnored = this.canvas.classList.contains(ignoreClass);\n\n          if (!isBlocked(this.canvas, blockClass) && !isIgnored) {\n            setTimeout(function () {\n              if (prop === 'drawImage') {\n                cb(_this.canvas, {\n                  type: CanvasContext['2D'],\n                  property: 'aniDataURL',\n                  args: []\n                });\n              } else {\n                cb(_this.canvas, {\n                  type: CanvasContext['2D'],\n                  property: 'dataURL',\n                  args: []\n                });\n              }\n            }, 0);\n          }\n\n          return original.apply(this, args);\n        };\n      });\n      handlers.push(restoreHandler);\n    } catch (_b) {\n      var hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n        set: function (v) {\n          cb(this.canvas, {\n            type: CanvasContext['2D'],\n            property: 'dataURL',\n            args: []\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  };\n\n  try {\n    for (var props2D_1 = __values(props2D), props2D_1_1 = props2D_1.next(); !props2D_1_1.done; props2D_1_1 = props2D_1.next()) {\n      var prop = props2D_1_1.value;\n\n      _loop_1(prop);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (props2D_1_1 && !props2D_1_1.done && (_a = props2D_1.return)) _a.call(props2D_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initCanvasContextObserver(win, blockClass, ignoreClass) {\n  var handlers = [];\n\n  try {\n    var restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\n      return function (contextType) {\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments[_i];\n        }\n\n        var isIgnored = this.classList.contains(ignoreClass);\n\n        if (!isBlocked(this, blockClass) && !isIgnored) {\n          if (!('__context' in this)) this.__context = contextType;\n        }\n\n        return original.apply(this, __spreadArray([contextType], __read(args), false));\n      };\n    });\n    handlers.push(restoreHandler);\n  } catch (_a) {\n    console.error('failed to patch HTMLCanvasElement.prototype.getContext');\n  }\n\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\n\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.\n\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n\nfor (var i$2 = 0; i$2 < chars.length; i$2++) {\n  lookup[chars.charCodeAt(i$2)] = i$2;\n}\n\nvar decode = function (base64) {\n  var bufferLength = base64.length * 0.75,\n      len = base64.length,\n      i,\n      p = 0,\n      encoded1,\n      encoded2,\n      encoded3,\n      encoded4;\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n\n  var arraybuffer = new ArrayBuffer(bufferLength),\n      bytes = new Uint8Array(arraybuffer);\n\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n\n  return arraybuffer;\n};\n\nvar webGLVarMap$1 = new Map();\n\nfunction variableListFor$1(ctx, ctor) {\n  var contextMap = webGLVarMap$1.get(ctx);\n\n  if (!contextMap) {\n    contextMap = new Map();\n    webGLVarMap$1.set(ctx, contextMap);\n  }\n\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n\n  return contextMap.get(ctor);\n}\n\nvar saveWebGLVar = function (value, win, ctx) {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === 'object')) return;\n  var name = value.constructor.name;\n  var list = variableListFor$1(ctx, name);\n  var index = list.indexOf(value);\n\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n\n  return index;\n};\n\nvar isInstanceOfWebGLObject = function (value, win) {\n  var webGLConstructorNames = ['WebGLActiveInfo', 'WebGLBuffer', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLRenderbuffer', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLTexture', 'WebGLUniformLocation', 'WebGLVertexArrayObject', 'WebGLVertexArrayObjectOES'];\n  var supportedWebGLConstructorNames = webGLConstructorNames.filter(function (name) {\n    return typeof win[name] === 'function';\n  });\n  return Boolean(supportedWebGLConstructorNames.find(function (name) {\n    return value instanceof win[name];\n  }));\n};\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, mirror, win, ignoreClass) {\n  var e_1, _a;\n\n  var handlers = [];\n  var props = Object.getOwnPropertyNames(prototype);\n\n  try {\n    for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n      var prop = props_1_1.value;\n\n      try {\n        if (typeof prototype[prop] !== 'function') {\n          continue;\n        }\n\n        var restoreHandler = patch(prototype, prop, function (original) {\n          return function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            var result = original.apply(this, args);\n            saveWebGLVar(result, win, prototype);\n            var isIgnored = this.canvas.classList.contains(ignoreClass);\n\n            if (!isBlocked(this.canvas, blockClass) && !isIgnored) {\n              cb(this.canvas, {\n                type: type,\n                property: 'aniDataURL',\n                args: []\n              });\n            }\n\n            return result;\n          };\n        });\n        handlers.push(restoreHandler);\n      } catch (_b) {\n        var hookHandler = hookSetter(prototype, prop, {\n          set: function (v) {\n            cb(this.canvas, {\n              type: type,\n              property: 'aniDataURL',\n              args: []\n            });\n          }\n        });\n        handlers.push(hookHandler);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return handlers;\n}\n\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, mirror, ignoreClass) {\n  var handlers = [];\n  handlers.push.apply(handlers, __spreadArray([], __read(patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, mirror, win, ignoreClass)), false));\n\n  if (typeof win.WebGL2RenderingContext !== 'undefined') {\n    handlers.push.apply(handlers, __spreadArray([], __read(patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, mirror, win, ignoreClass)), false));\n  }\n\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nvar CanvasManager = function () {\n  function CanvasManager(options) {\n    this.pendingCanvasMutations = new Map();\n    this.rafStamps = {\n      latestId: 0,\n      invokeId: null\n    };\n    this.frozen = false;\n    this.locked = false;\n\n    this.processMutation = function (target, mutation) {\n      var newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    if (options.recordCanvas === true) this.initCanvasMutationObserver(options.win, options.blockClass, options.ignoreClass);\n  }\n\n  CanvasManager.prototype.reset = function () {\n    this.pendingCanvasMutations.clear();\n    this.resetObservers && this.resetObservers();\n  };\n\n  CanvasManager.prototype.freeze = function () {\n    this.frozen = true;\n  };\n\n  CanvasManager.prototype.unfreeze = function () {\n    this.frozen = false;\n  };\n\n  CanvasManager.prototype.lock = function () {\n    this.locked = true;\n  };\n\n  CanvasManager.prototype.unlock = function () {\n    this.locked = false;\n  };\n\n  CanvasManager.prototype.initCanvasMutationObserver = function (win, blockClass, ignoreClass) {\n    this.startRAFTimestamping();\n    this.startPendingCanvasMutationFlusher();\n    var canvasContextReset = initCanvasContextObserver(win, blockClass, ignoreClass);\n    var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, this.mirror, ignoreClass);\n    var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, this.mirror, ignoreClass);\n\n    this.resetObservers = function () {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    };\n  };\n\n  CanvasManager.prototype.startPendingCanvasMutationFlusher = function () {\n    var _this = this;\n\n    requestAnimationFrame(function () {\n      return _this.flushPendingCanvasMutations();\n    });\n  };\n\n  CanvasManager.prototype.startRAFTimestamping = function () {\n    var _this = this;\n\n    var setLatestRAFTimestamp = function (timestamp) {\n      _this.rafStamps.latestId = timestamp;\n      requestAnimationFrame(setLatestRAFTimestamp);\n    };\n\n    requestAnimationFrame(setLatestRAFTimestamp);\n  };\n\n  CanvasManager.prototype.flushPendingCanvasMutations = function () {\n    var _this = this;\n\n    this.pendingCanvasMutations.forEach(function (values, canvas) {\n      var id = _this.mirror.getId(canvas);\n\n      _this.flushPendingCanvasMutationFor(canvas, id);\n    });\n    requestAnimationFrame(function () {\n      return _this.flushPendingCanvasMutations();\n    });\n  };\n\n  CanvasManager.prototype.flushPendingCanvasMutationFor = function (canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    var valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    var values = valuesWithType.map(function (value) {\n      value.type;\n\n      var rest = __rest(value, [\"type\"]);\n\n      return rest;\n    });\n    var type = valuesWithType[0].type;\n    this.mutationCb({\n      id: id,\n      type: type,\n      commands: values\n    });\n    this.pendingCanvasMutations.delete(canvas);\n  };\n\n  return CanvasManager;\n}();\n\nfunction wrapEvent(e) {\n  return __assign(__assign({}, e), {\n    timestamp: Date.now()\n  });\n}\n\nvar wrappedEmit;\nvar takeFullSnapshot;\nvar isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\nvar isSafari = navigator.userAgent.indexOf('Safari') > -1 && navigator.userAgent.indexOf('Chrome') <= -1;\n\nfunction canvasHandle(param) {\n  var _a;\n\n  var canvas = param.target;\n  var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');\n\n  if (gl) {\n    var attribs = gl.getContextAttributes();\n\n    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {\n      console.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false');\n    }\n\n    var quality = isMobile ? 0.3 : 0.1;\n\n    if (canvas.width >= 1024 || canvas.height >= 1024) {\n      quality = 0.1;\n    }\n\n    var type = isSafari ? 'image/jpeg' : 'image/webp';\n    param.p.args = [canvas.toDataURL(type, quality)];\n  } else {\n    if (is2DCanvasBlank(canvas)) return;\n    param.p.args = [param.target.toDataURL('image/jpeg', 0.5)];\n  }\n\n  wrappedEmit(wrapEvent({\n    type: exports.tw.IncrementalSnapshot,\n    data: __assign({\n      source: exports.yh.CanvasMutation\n    }, param.p)\n  }));\n}\n\nvar webglTimeId = null;\nvar durationWebgl = isMobile ? 100 : 200;\n\nvar throttleCanvasFn = function (param) {\n  if (webglTimeId) return;\n  webglTimeId = setTimeout(function () {\n    canvasHandle(param);\n    webglTimeId = null;\n  }, durationWebgl);\n};\n\nvar debounceCanvasFn = debounce(canvasHandle, 100);\nvar mirror = createMirror();\n\nfunction record(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var emit = options.emit,\n      checkoutEveryNms = options.checkoutEveryNms,\n      checkoutEveryNth = options.checkoutEveryNth,\n      _a = options.blockClass,\n      blockClass = _a === void 0 ? 'rr-block' : _a,\n      _b = options.blockSelector,\n      blockSelector = _b === void 0 ? null : _b,\n      _c = options.ignoreClass,\n      ignoreClass = _c === void 0 ? 'rr-ignore' : _c,\n      _d = options.maskTextClass,\n      maskTextClass = _d === void 0 ? 'rr-mask' : _d,\n      _e = options.maskTextSelector,\n      maskTextSelector = _e === void 0 ? null : _e,\n      _f = options.inlineStylesheet,\n      inlineStylesheet = _f === void 0 ? true : _f,\n      maskAllInputs = options.maskAllInputs,\n      _maskInputOptions = options.maskInputOptions,\n      _slimDOMOptions = options.slimDOMOptions,\n      maskInputFn = options.maskInputFn,\n      maskTextFn = options.maskTextFn,\n      hooks = options.hooks,\n      packFn = options.packFn,\n      _g = options.sampling,\n      sampling = _g === void 0 ? {} : _g,\n      mousemoveWait = options.mousemoveWait,\n      _h = options.recordCanvas,\n      recordCanvas = _h === void 0 ? false : _h,\n      _j = options.userTriggeredOnInput,\n      userTriggeredOnInput = _j === void 0 ? false : _j,\n      _k = options.collectFonts,\n      collectFonts = _k === void 0 ? false : _k,\n      _l = options.inlineImages,\n      inlineImages = _l === void 0 ? false : _l,\n      plugins = options.plugins,\n      _m = options.keepIframeSrcFn,\n      keepIframeSrcFn = _m === void 0 ? function () {\n    return false;\n  } : _m,\n      disableRemoteControlFn = options.disableRemoteControlFn;\n\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  var maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    'datetime-local': true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    password: true\n  } : _maskInputOptions !== undefined ? _maskInputOptions : {\n    password: true\n  };\n  var slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all' ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    headMetaAuthorship: _slimDOMOptions === 'all',\n    headMetaDescKeywords: _slimDOMOptions === 'all'\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  var lastFullSnapshotEvent;\n  var incrementalSnapshotCount = 0;\n\n  var eventProcessor = function (e) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(plugins || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var plugin = _c.value;\n\n        if (plugin.eventProcessor) {\n          e = plugin.eventProcessor(e);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (packFn) {\n      e = packFn(e);\n    }\n\n    return e;\n  };\n\n  wrappedEmit = function (e, isCheckout) {\n    var _a;\n\n    if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) && e.type !== exports.tw.FullSnapshot && !(e.type === exports.tw.IncrementalSnapshot && e.data.source === exports.yh.Mutation)) {\n      mutationBuffers.forEach(function (buf) {\n        return buf.unfreeze();\n      });\n    }\n\n    emit(eventProcessor(e), isCheckout);\n\n    if (e.type === exports.tw.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === exports.tw.IncrementalSnapshot) {\n      if (e.data.source === exports.yh.Mutation && e.data.isAttachIframe) {\n        return;\n      }\n\n      incrementalSnapshotCount++;\n      var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      var exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  var wrappedMutationEmit = function (m) {\n    wrappedEmit(wrapEvent({\n      type: exports.tw.IncrementalSnapshot,\n      data: __assign({\n        source: exports.yh.Mutation\n      }, m)\n    }));\n  };\n\n  var wrappedScrollEmit = function (p) {\n    return wrappedEmit(wrapEvent({\n      type: exports.tw.IncrementalSnapshot,\n      data: __assign({\n        source: exports.yh.Scroll\n      }, p)\n    }));\n  };\n\n  var wrappedCanvasMutationEmit = function (p) {\n    var target = mirror.getNode(p.id);\n\n    if (target && !target.classList.contains(ignoreClass)) {\n      var property = 'commands' in p ? p.commands[0].property : p.property;\n\n      if (property === 'dataURL') {\n        var param = {\n          p: {\n            id: p.id,\n            property: 'dataURL',\n            args: [],\n            type: p.type\n          },\n          target: target\n        };\n        debounceCanvasFn(param);\n      } else if (property === 'aniDataURL') {\n        var param = {\n          p: {\n            id: p.id,\n            property: 'aniDataURL',\n            args: [],\n            type: p.type\n          },\n          target: target\n        };\n        throttleCanvasFn(param);\n      } else {\n        wrappedEmit(wrapEvent({\n          type: exports.tw.IncrementalSnapshot,\n          data: __assign({\n            source: exports.yh.CanvasMutation\n          }, p)\n        }));\n      }\n    }\n  };\n\n  var iframeManager = new IframeManager({\n    mutationCb: wrappedMutationEmit\n  });\n  var canvasManager = new CanvasManager({\n    recordCanvas: recordCanvas,\n    mutationCb: wrappedCanvasMutationEmit,\n    win: window,\n    blockClass: blockClass,\n    mirror: mirror,\n    ignoreClass: ignoreClass\n  });\n  var shadowDomManager = new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      blockClass: blockClass,\n      blockSelector: blockSelector,\n      maskTextClass: maskTextClass,\n      maskTextSelector: maskTextSelector,\n      inlineStylesheet: inlineStylesheet,\n      maskInputOptions: maskInputOptions,\n      maskTextFn: maskTextFn,\n      maskInputFn: maskInputFn,\n      recordCanvas: recordCanvas,\n      inlineImages: inlineImages,\n      sampling: sampling,\n      slimDOMOptions: slimDOMOptions,\n      iframeManager: iframeManager,\n      ignoreClass: ignoreClass,\n      takeFullSnapshot: takeFullSnapshot,\n      canvasManager: canvasManager,\n      disableRemoteControlFn: disableRemoteControlFn\n    },\n    mirror: mirror,\n    takeFullSnapshot: takeFullSnapshot\n  });\n\n  takeFullSnapshot = function (isCheckout) {\n    var _a, _b, _c, _d;\n\n    if (isCheckout === void 0) {\n      isCheckout = false;\n    }\n\n    wrappedEmit(wrapEvent({\n      type: exports.tw.Meta,\n      data: {\n        href: window.location.href,\n        width: getWindowWidth(),\n        height: getWindowHeight()\n      }\n    }), isCheckout);\n    mutationBuffers.forEach(function (buf) {\n      return buf.lock();\n    });\n\n    var _e = __read(snapshot(document, {\n      blockClass: blockClass,\n      blockSelector: blockSelector,\n      maskTextClass: maskTextClass,\n      maskTextSelector: maskTextSelector,\n      inlineStylesheet: inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskTextFn: maskTextFn,\n      slimDOM: slimDOMOptions,\n      recordCanvas: recordCanvas,\n      inlineImages: inlineImages,\n      onSerialize: function (n) {\n        if (isIframeINode(n)) {\n          iframeManager.addIframe(n);\n        }\n\n        if (hasShadowRoot(n)) {\n          shadowDomManager.addShadowRoot(n.shadowRoot, document);\n        }\n      },\n      onIframeLoad: function (iframe, childSn) {\n        iframeManager.attachIframe(iframe, childSn);\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      keepIframeSrcFn: keepIframeSrcFn,\n      disableRemoteControlFn: disableRemoteControlFn\n    }), 2),\n        node = _e[0],\n        idNodeMap = _e[1];\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(wrapEvent({\n      type: exports.tw.FullSnapshot,\n      data: {\n        node: node,\n        initialOffset: {\n          left: window.pageXOffset !== undefined ? window.pageXOffset : (document === null || document === void 0 ? void 0 : document.documentElement.scrollLeft) || ((_b = (_a = document === null || document === void 0 ? void 0 : document.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) || (document === null || document === void 0 ? void 0 : document.body.scrollLeft) || 0,\n          top: window.pageYOffset !== undefined ? window.pageYOffset : (document === null || document === void 0 ? void 0 : document.documentElement.scrollTop) || ((_d = (_c = document === null || document === void 0 ? void 0 : document.body) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.scrollTop) || (document === null || document === void 0 ? void 0 : document.body.scrollTop) || 0\n        }\n      }\n    }));\n    mutationBuffers.forEach(function (buf) {\n      return buf.unlock();\n    });\n  };\n\n  try {\n    var handlers_1 = [];\n    handlers_1.push(on('DOMContentLoaded', function () {\n      wrappedEmit(wrapEvent({\n        type: exports.tw.DomContentLoaded,\n        data: {}\n      }));\n    }));\n\n    var observe_1 = function (doc) {\n      var _a;\n\n      return initObservers({\n        mutationCb: wrappedMutationEmit,\n        mousemoveCb: function (positions, source) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: {\n              source: source,\n              positions: positions\n            }\n          }));\n        },\n        mouseInteractionCb: function (d) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.MouseInteraction\n            }, d)\n          }));\n        },\n        scrollCb: wrappedScrollEmit,\n        viewportResizeCb: function (d) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.ViewportResize\n            }, d)\n          }));\n        },\n        inputCb: function (v) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.Input\n            }, v)\n          }));\n        },\n        mediaInteractionCb: function (p) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.MediaInteraction\n            }, p)\n          }));\n        },\n        styleSheetRuleCb: function (r) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.StyleSheetRule\n            }, r)\n          }));\n        },\n        styleDeclarationCb: function (r) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.StyleDeclaration\n            }, r)\n          }));\n        },\n        canvasMutationCb: wrappedCanvasMutationEmit,\n        fontCb: function (p) {\n          return wrappedEmit(wrapEvent({\n            type: exports.tw.IncrementalSnapshot,\n            data: __assign({\n              source: exports.yh.Font\n            }, p)\n          }));\n        },\n        blockClass: blockClass,\n        ignoreClass: ignoreClass,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        maskInputOptions: maskInputOptions,\n        inlineStylesheet: inlineStylesheet,\n        sampling: sampling,\n        recordCanvas: recordCanvas,\n        inlineImages: inlineImages,\n        userTriggeredOnInput: userTriggeredOnInput,\n        collectFonts: collectFonts,\n        doc: doc,\n        maskInputFn: maskInputFn,\n        maskTextFn: maskTextFn,\n        blockSelector: blockSelector,\n        slimDOMOptions: slimDOMOptions,\n        mirror: mirror,\n        iframeManager: iframeManager,\n        shadowDomManager: shadowDomManager,\n        canvasManager: canvasManager,\n        plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter(function (p) {\n          return p.observer;\n        })) === null || _a === void 0 ? void 0 : _a.map(function (p) {\n          return {\n            observer: p.observer,\n            options: p.options,\n            callback: function (payload) {\n              return wrappedEmit(wrapEvent({\n                type: exports.tw.Plugin,\n                data: {\n                  plugin: p.name,\n                  payload: payload\n                }\n              }));\n            }\n          };\n        })) || [],\n        disableRemoteControlFn: disableRemoteControlFn\n      }, hooks, takeFullSnapshot);\n    };\n\n    iframeManager.addLoadListener(function (iframeEl) {\n      handlers_1.push(observe_1(iframeEl.contentDocument));\n    });\n\n    var init_1 = function () {\n      takeFullSnapshot();\n      handlers_1.push(observe_1(document));\n    };\n\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      init_1();\n    } else {\n      handlers_1.push(on('load', function () {\n        wrappedEmit(wrapEvent({\n          type: exports.tw.Load,\n          data: {}\n        }));\n        init_1();\n      }, window));\n    }\n\n    return function () {\n      handlers_1.forEach(function (h) {\n        return h();\n      });\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = function (tag, payload) {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n\n  wrappedEmit(wrapEvent({\n    type: exports.tw.Custom,\n    data: {\n      tag: tag,\n      payload: payload\n    }\n  }));\n};\n\nrecord.freezePage = function () {\n  mutationBuffers.forEach(function (buf) {\n    return buf.freeze();\n  });\n};\n\nrecord.takeFullSnapshot = function (isCheckout) {\n  if (!takeFullSnapshot) {\n    throw new Error('please take full snapshot after start recording');\n  }\n\n  takeFullSnapshot(isCheckout);\n};\n\nrecord.startRemoteControl = function () {\n  remoteControllParam.controlling = true;\n};\n\nrecord.stopRemoteControl = function () {\n  remoteControllParam.controlling = false;\n};\n\nrecord.startScroll = function () {\n  remoteControllParam.scroll = true;\n};\n\nrecord.stopScroll = function () {\n  remoteControllParam.scroll = false;\n};\n\nrecord.mirror = mirror; //      \n// An event handler can take an optional event argument\n// and should not return a value\n// An array of all currently registered event handlers for a type\n// A map of event types and their corresponding event handlers.\n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\n\nfunction mitt$1(all) {\n  all = all || Object.create(null);\n  return {\n    /**\n     * Register an event handler for the given type.\n     *\n     * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n     * @param  {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on: function on(type, handler) {\n      (all[type] || (all[type] = [])).push(handler);\n    },\n\n    /**\n     * Remove an event handler for the given type.\n     *\n     * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n     * @param  {Function} handler Handler function to remove\n     * @memberOf mitt\n     */\n    off: function off(type, handler) {\n      if (all[type]) {\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n      }\n    },\n\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `\"*\"` handlers are invoked after type-matched handlers.\n     *\n     * @param {String} type  The event type to invoke\n     * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit: function emit(type, evt) {\n      (all[type] || []).slice().map(function (handler) {\n        handler(evt);\n      });\n      (all['*'] || []).slice().map(function (handler) {\n        handler(type, evt);\n      });\n    }\n  };\n}\n\nvar mittProxy = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': mitt$1\n});\n\nfunction polyfill(w, d) {\n  if (w === void 0) {\n    w = window;\n  }\n\n  if (d === void 0) {\n    d = document;\n  }\n\n  if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n\n  var Element = w.HTMLElement || w.Element;\n  var SCROLL_TIME = 468;\n  var original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element.prototype.scroll || scrollElement,\n    scrollIntoView: Element.prototype.scrollIntoView\n  };\n  var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n\n  function isMicrosoftBrowser(userAgent) {\n    var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n    return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n  }\n\n  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  function shouldBailOut(firstArg) {\n    if (firstArg === null || typeof firstArg !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n      return true;\n    }\n\n    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n      return false;\n    }\n\n    throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n  }\n\n  function hasScrollableSpace(el, axis) {\n    if (axis === 'Y') {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n\n    if (axis === 'X') {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n\n  function canOverflow(el, axis) {\n    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n    return overflowValue === 'auto' || overflowValue === 'scroll';\n  }\n\n  function isScrollable(el) {\n    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n    return isScrollableY || isScrollableX;\n  }\n\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n\n    return el;\n  }\n\n  function step(context) {\n    var time = now();\n    var value;\n    var currentX;\n    var currentY;\n    var elapsed = (time - context.startTime) / SCROLL_TIME;\n    elapsed = elapsed > 1 ? 1 : elapsed;\n    value = ease(elapsed);\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n    context.method.call(context.scrollable, currentX, currentY);\n\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n\n  function smoothScroll(el, x, y) {\n    var scrollable;\n    var startX;\n    var startY;\n    var method;\n    var startTime = now();\n\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n\n    step({\n      scrollable: scrollable,\n      method: method,\n      startTime: startTime,\n      startX: startX,\n      startY: startY,\n      x: x,\n      y: y\n    });\n  }\n\n  w.scroll = w.scrollTo = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n      return;\n    }\n\n    smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n  };\n\n  w.scrollBy = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n      return;\n    }\n\n    smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n  };\n\n  Element.prototype.scroll = Element.prototype.scrollTo = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n        throw new SyntaxError('Value could not be converted');\n      }\n\n      original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n      return;\n    }\n\n    var left = arguments[0].left;\n    var top = arguments[0].top;\n    smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n  };\n\n  Element.prototype.scrollBy = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n      return;\n    }\n\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n\n  Element.prototype.scrollIntoView = function () {\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n      return;\n    }\n\n    var scrollableParent = findScrollableParent(this);\n    var parentRects = scrollableParent.getBoundingClientRect();\n    var clientRects = this.getBoundingClientRect();\n\n    if (scrollableParent !== d.body) {\n      smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);\n\n      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      }\n    } else {\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: 'smooth'\n      });\n    }\n  };\n}\n\nvar Timer = function () {\n  function Timer(actions, speed) {\n    if (actions === void 0) {\n      actions = [];\n    }\n\n    this.timeOffset = 0;\n    this.raf = null;\n    this.actions = actions;\n    this.speed = speed;\n  }\n\n  Timer.prototype.addAction = function (action) {\n    var index = this.findActionIndex(action);\n    this.actions.splice(index, 0, action);\n  };\n\n  Timer.prototype.addActions = function (actions) {\n    this.actions = this.actions.concat(actions);\n  };\n\n  Timer.prototype.start = function () {\n    this.timeOffset = 0;\n    var lastTimestamp = performance.now();\n    var actions = this.actions;\n    var self = this;\n\n    function check() {\n      var time = performance.now();\n      self.timeOffset += (time - lastTimestamp) * self.speed;\n      lastTimestamp = time;\n\n      while (actions.length) {\n        var action = actions[0];\n\n        if (self.timeOffset >= action.delay) {\n          actions.shift();\n          action.doAction();\n        } else {\n          break;\n        }\n      }\n\n      if (actions.length > 0 || self.liveMode) {\n        self.raf = requestAnimationFrame(check);\n      }\n    }\n\n    this.raf = requestAnimationFrame(check);\n  };\n\n  Timer.prototype.clear = function () {\n    if (this.raf) {\n      cancelAnimationFrame(this.raf);\n      this.raf = null;\n    }\n\n    this.actions.length = 0;\n  };\n\n  Timer.prototype.setSpeed = function (speed) {\n    this.speed = speed;\n  };\n\n  Timer.prototype.toggleLiveMode = function (mode) {\n    this.liveMode = mode;\n  };\n\n  Timer.prototype.isActive = function () {\n    return this.raf !== null;\n  };\n\n  Timer.prototype.findActionIndex = function (action) {\n    var start = 0;\n    var end = this.actions.length - 1;\n\n    while (start <= end) {\n      var mid = Math.floor((start + end) / 2);\n\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid + 1;\n      }\n    }\n\n    return start;\n  };\n\n  return Timer;\n}();\n\nfunction addDelay(event, baselineTime) {\n  if (event.type === exports.tw.IncrementalSnapshot && event.data.source === exports.yh.MouseMove) {\n    var firstOffset = event.data.positions[0].timeOffset;\n    var firstTimestamp = event.timestamp + firstOffset;\n    event.delay = firstTimestamp - baselineTime;\n    return firstTimestamp - baselineTime;\n  }\n\n  event.delay = event.timestamp - baselineTime;\n  return event.delay;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\n\nfunction t(t, n) {\n  var e = \"function\" == typeof Symbol && t[Symbol.iterator];\n  if (!e) return t;\n  var r,\n      o,\n      i = e.call(t),\n      a = [];\n\n  try {\n    for (; (void 0 === n || n-- > 0) && !(r = i.next()).done;) a.push(r.value);\n  } catch (t) {\n    o = {\n      error: t\n    };\n  } finally {\n    try {\n      r && !r.done && (e = i.return) && e.call(i);\n    } finally {\n      if (o) throw o.error;\n    }\n  }\n\n  return a;\n}\n\nvar n;\n!function (t) {\n  t[t.NotStarted = 0] = \"NotStarted\", t[t.Running = 1] = \"Running\", t[t.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nvar e = {\n  type: \"xstate.init\"\n};\n\nfunction r(t) {\n  return void 0 === t ? [] : [].concat(t);\n}\n\nfunction o(t) {\n  return {\n    type: \"xstate.assign\",\n    assignment: t\n  };\n}\n\nfunction i$1(t, n) {\n  return \"string\" == typeof (t = \"string\" == typeof t && n && n[t] ? n[t] : t) ? {\n    type: t\n  } : \"function\" == typeof t ? {\n    type: t.name,\n    exec: t\n  } : t;\n}\n\nfunction a(t) {\n  return function (n) {\n    return t === n;\n  };\n}\n\nfunction u(t) {\n  return \"string\" == typeof t ? {\n    type: t\n  } : t;\n}\n\nfunction c(t, n) {\n  return {\n    value: t,\n    context: n,\n    actions: [],\n    changed: !1,\n    matches: a(t)\n  };\n}\n\nfunction f(t, n, e) {\n  var r = n,\n      o = !1;\n  return [t.filter(function (t) {\n    if (\"xstate.assign\" === t.type) {\n      o = !0;\n      var n = Object.assign({}, r);\n      return \"function\" == typeof t.assignment ? n = t.assignment(r, e) : Object.keys(t.assignment).forEach(function (o) {\n        n[o] = \"function\" == typeof t.assignment[o] ? t.assignment[o](r, e) : t.assignment[o];\n      }), r = n, !1;\n    }\n\n    return !0;\n  }), r, o];\n}\n\nfunction s(n, o) {\n  void 0 === o && (o = {});\n  var s = t(f(r(n.states[n.initial].entry).map(function (t) {\n    return i$1(t, o.actions);\n  }), n.context, e), 2),\n      l = s[0],\n      v = s[1],\n      y = {\n    config: n,\n    _options: o,\n    initialState: {\n      value: n.initial,\n      actions: l,\n      context: v,\n      matches: a(n.initial)\n    },\n    transition: function (e, o) {\n      var s,\n          l,\n          v = \"string\" == typeof e ? {\n        value: e,\n        context: n.context\n      } : e,\n          p = v.value,\n          g = v.context,\n          d = u(o),\n          x = n.states[p];\n\n      if (x.on) {\n        var m = r(x.on[d.type]);\n\n        try {\n          for (var h = function (t) {\n            var n = \"function\" == typeof Symbol && Symbol.iterator,\n                e = n && t[n],\n                r = 0;\n            if (e) return e.call(t);\n            if (t && \"number\" == typeof t.length) return {\n              next: function () {\n                return t && r >= t.length && (t = void 0), {\n                  value: t && t[r++],\n                  done: !t\n                };\n              }\n            };\n            throw new TypeError(n ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n          }(m), b = h.next(); !b.done; b = h.next()) {\n            var S = b.value;\n            if (void 0 === S) return c(p, g);\n\n            var w = \"string\" == typeof S ? {\n              target: S\n            } : S,\n                j = w.target,\n                E = w.actions,\n                R = void 0 === E ? [] : E,\n                N = w.cond,\n                O = void 0 === N ? function () {\n              return !0;\n            } : N,\n                _ = void 0 === j,\n                k = null != j ? j : p,\n                T = n.states[k];\n\n            if (O(g, d)) {\n              var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function (t) {\n                return t;\n              })).map(function (t) {\n                return i$1(t, y._options.actions);\n              }), g, d), 3),\n                  z = q[0],\n                  A = q[1],\n                  B = q[2],\n                  C = null != j ? j : p;\n              return {\n                value: C,\n                context: A,\n                actions: z,\n                changed: j !== p || z.length > 0 || B,\n                matches: a(C)\n              };\n            }\n          }\n        } catch (t) {\n          s = {\n            error: t\n          };\n        } finally {\n          try {\n            b && !b.done && (l = h.return) && l.call(h);\n          } finally {\n            if (s) throw s.error;\n          }\n        }\n      }\n\n      return c(p, g);\n    }\n  };\n  return y;\n}\n\nvar l = function (t, n) {\n  return t.actions.forEach(function (e) {\n    var r = e.exec;\n    return r && r(t.context, n);\n  });\n};\n\nfunction v(t) {\n  var r = t.initialState,\n      o = n.NotStarted,\n      i = new Set(),\n      c = {\n    _machine: t,\n    send: function (e) {\n      o === n.Running && (r = t.transition(r, e), l(r, u(e)), i.forEach(function (t) {\n        return t(r);\n      }));\n    },\n    subscribe: function (t) {\n      return i.add(t), t(r), {\n        unsubscribe: function () {\n          return i.delete(t);\n        }\n      };\n    },\n    start: function (i) {\n      if (i) {\n        var u = \"object\" == typeof i ? i : {\n          context: t.config.context,\n          value: i\n        };\n        r = {\n          value: u.value,\n          actions: [],\n          context: u.context,\n          matches: a(u.value)\n        };\n      }\n\n      return o = n.Running, l(r, e), c;\n    },\n    stop: function () {\n      return o = n.Stopped, i.clear(), c;\n    },\n\n    get state() {\n      return r;\n    },\n\n    get status() {\n      return o;\n    }\n\n  };\n  return c;\n}\n\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (var idx = events.length - 1; idx >= 0; idx--) {\n    var event_1 = events[idx];\n\n    if (event_1.type === exports.tw.Meta) {\n      if (event_1.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n\n  return events;\n}\n\nfunction createPlayerService(context, _a) {\n  var getCastFn = _a.getCastFn,\n      applyEventsSynchronously = _a.applyEventsSynchronously,\n      emitter = _a.emitter;\n  var playerMachine = s({\n    id: 'player',\n    context: context,\n    initial: 'paused',\n    states: {\n      playing: {\n        on: {\n          PAUSE: {\n            target: 'paused',\n            actions: ['pause']\n          },\n          CAST_EVENT: {\n            target: 'playing',\n            actions: 'castEvent'\n          },\n          END: {\n            target: 'paused',\n            actions: ['resetLastPlayedEvent', 'pause']\n          },\n          ADD_EVENT: {\n            target: 'playing',\n            actions: ['addEvent']\n          }\n        }\n      },\n      paused: {\n        on: {\n          PLAY: {\n            target: 'playing',\n            actions: ['recordTimeOffset', 'play']\n          },\n          CAST_EVENT: {\n            target: 'paused',\n            actions: 'castEvent'\n          },\n          TO_LIVE: {\n            target: 'live',\n            actions: ['startLive']\n          },\n          ADD_EVENT: {\n            target: 'paused',\n            actions: ['addEvent']\n          }\n        }\n      },\n      live: {\n        on: {\n          ADD_EVENT: {\n            target: 'live',\n            actions: ['addEvent']\n          },\n          CAST_EVENT: {\n            target: 'live',\n            actions: ['castEvent']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      castEvent: o({\n        lastPlayedEvent: function (ctx, event) {\n          if (event.type === 'CAST_EVENT') {\n            return event.payload.event;\n          }\n\n          return ctx.lastPlayedEvent;\n        }\n      }),\n      recordTimeOffset: o(function (ctx, event) {\n        var timeOffset = ctx.timeOffset;\n\n        if ('payload' in event && 'timeOffset' in event.payload) {\n          timeOffset = event.payload.timeOffset;\n        }\n\n        return __assign(__assign({}, ctx), {\n          timeOffset: timeOffset,\n          baselineTime: ctx.events[0].timestamp + timeOffset\n        });\n      }),\n      play: function (ctx) {\n        var e_1, _a, e_2, _b;\n\n        var _c;\n\n        var timer = ctx.timer,\n            events = ctx.events,\n            baselineTime = ctx.baselineTime,\n            lastPlayedEvent = ctx.lastPlayedEvent;\n        timer.clear();\n\n        try {\n          for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {\n            var event_2 = events_1_1.value;\n            addDelay(event_2, baselineTime);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var neededEvents = discardPriorSnapshots(events, baselineTime);\n        var lastPlayedTimestamp = lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.timestamp;\n\n        if ((lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.type) === exports.tw.IncrementalSnapshot && lastPlayedEvent.data.source === exports.yh.MouseMove) {\n          lastPlayedTimestamp = lastPlayedEvent.timestamp + ((_c = lastPlayedEvent.data.positions[0]) === null || _c === void 0 ? void 0 : _c.timeOffset);\n        }\n\n        if (baselineTime < (lastPlayedTimestamp || 0)) {\n          emitter.emit(exports.SA.PlayBack);\n        }\n\n        var syncEvents = new Array();\n        var actions = new Array();\n\n        var _loop_1 = function (event_3) {\n          if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event_3.timestamp <= lastPlayedTimestamp || event_3 === lastPlayedEvent)) {\n            return \"continue\";\n          }\n\n          if (event_3.timestamp < baselineTime) {\n            syncEvents.push(event_3);\n          } else {\n            var castFn_1 = getCastFn(event_3, false);\n            actions.push({\n              doAction: function () {\n                castFn_1();\n              },\n              delay: event_3.delay\n            });\n          }\n        };\n\n        try {\n          for (var neededEvents_1 = __values(neededEvents), neededEvents_1_1 = neededEvents_1.next(); !neededEvents_1_1.done; neededEvents_1_1 = neededEvents_1.next()) {\n            var event_3 = neededEvents_1_1.value;\n\n            _loop_1(event_3);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (neededEvents_1_1 && !neededEvents_1_1.done && (_b = neededEvents_1.return)) _b.call(neededEvents_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        applyEventsSynchronously(syncEvents);\n        emitter.emit(exports.SA.Flush);\n        timer.addActions(actions);\n        timer.start();\n      },\n      pause: function (ctx) {\n        ctx.timer.clear();\n      },\n      resetLastPlayedEvent: o(function (ctx) {\n        return __assign(__assign({}, ctx), {\n          lastPlayedEvent: null\n        });\n      }),\n      startLive: o({\n        baselineTime: function (ctx, event) {\n          ctx.timer.toggleLiveMode(true);\n          ctx.timer.start();\n\n          if (event.type === 'TO_LIVE' && event.payload.baselineTime) {\n            return event.payload.baselineTime;\n          }\n\n          return Date.now();\n        }\n      }),\n      addEvent: o(function (ctx, machineEvent) {\n        var baselineTime = ctx.baselineTime,\n            timer = ctx.timer,\n            events = ctx.events;\n\n        if (machineEvent.type === 'ADD_EVENT') {\n          var event_4 = machineEvent.payload.event;\n          addDelay(event_4, baselineTime);\n          var end = events.length - 1;\n\n          if (!events[end] || events[end].timestamp <= event_4.timestamp) {\n            events.push(event_4);\n          } else {\n            var insertionIndex = -1;\n            var start = 0;\n\n            while (start <= end) {\n              var mid = Math.floor((start + end) / 2);\n\n              if (events[mid].timestamp <= event_4.timestamp) {\n                start = mid + 1;\n              } else {\n                end = mid - 1;\n              }\n            }\n\n            if (insertionIndex === -1) {\n              insertionIndex = start;\n            }\n\n            events.splice(insertionIndex, 0, event_4);\n          }\n\n          var isSync = event_4.timestamp < baselineTime;\n          var castFn_2 = getCastFn(event_4, isSync);\n\n          if (isSync) {\n            castFn_2();\n          } else if (timer.isActive()) {\n            timer.addAction({\n              doAction: function () {\n                castFn_2();\n              },\n              delay: event_4.delay\n            });\n          }\n        }\n\n        return __assign(__assign({}, ctx), {\n          events: events\n        });\n      })\n    }\n  });\n  return v(playerMachine);\n}\n\nfunction createSpeedService(context) {\n  var speedMachine = s({\n    id: 'speed',\n    context: context,\n    initial: 'normal',\n    states: {\n      normal: {\n        on: {\n          FAST_FORWARD: {\n            target: 'skipping',\n            actions: ['recordSpeed', 'setSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      },\n      skipping: {\n        on: {\n          BACK_TO_NORMAL: {\n            target: 'normal',\n            actions: ['restoreSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      setSpeed: function (ctx, event) {\n        if ('payload' in event) {\n          ctx.timer.setSpeed(event.payload.speed);\n        }\n      },\n      recordSpeed: o({\n        normalSpeed: function (ctx) {\n          return ctx.timer.speed;\n        }\n      }),\n      restoreSpeed: function (ctx) {\n        ctx.timer.setSpeed(ctx.normalSpeed);\n      }\n    }\n  });\n  return v(speedMachine);\n}\n\nvar rules = function (blockClass) {\n  return [\".\".concat(blockClass, \" { background: currentColor }\"), 'noscript { display: none !important; }'];\n};\n\nvar StyleRuleType;\n\n(function (StyleRuleType) {\n  StyleRuleType[StyleRuleType[\"Insert\"] = 0] = \"Insert\";\n  StyleRuleType[StyleRuleType[\"Remove\"] = 1] = \"Remove\";\n  StyleRuleType[StyleRuleType[\"Snapshot\"] = 2] = \"Snapshot\";\n  StyleRuleType[StyleRuleType[\"SetProperty\"] = 3] = \"SetProperty\";\n  StyleRuleType[StyleRuleType[\"RemoveProperty\"] = 4] = \"RemoveProperty\";\n})(StyleRuleType || (StyleRuleType = {}));\n\nfunction getNestedRule(rules, position) {\n  var rule = rules[position[0]];\n\n  if (position.length === 1) {\n    return rule;\n  } else {\n    return getNestedRule(rule.cssRules[position[1]].cssRules, position.slice(2));\n  }\n}\n\nfunction getPositionsAndIndex(nestedIndex) {\n  var positions = __spreadArray([], __read(nestedIndex), false);\n\n  var index = positions.pop();\n  return {\n    positions: positions,\n    index: index\n  };\n}\n\nfunction applyVirtualStyleRulesToNode(storedRules, styleNode) {\n  var sheet = styleNode.sheet;\n\n  if (!sheet) {\n    return;\n  }\n\n  storedRules.forEach(function (rule) {\n    if (rule.type === StyleRuleType.Insert) {\n      try {\n        if (Array.isArray(rule.index)) {\n          var _a = getPositionsAndIndex(rule.index),\n              positions = _a.positions,\n              index = _a.index;\n\n          var nestedRule = getNestedRule(sheet.cssRules, positions);\n          nestedRule.insertRule(rule.cssText, index);\n        } else {\n          sheet.insertRule(rule.cssText, rule.index);\n        }\n      } catch (e) {}\n    } else if (rule.type === StyleRuleType.Remove) {\n      try {\n        if (Array.isArray(rule.index)) {\n          var _b = getPositionsAndIndex(rule.index),\n              positions = _b.positions,\n              index = _b.index;\n\n          var nestedRule = getNestedRule(sheet.cssRules, positions);\n          nestedRule.deleteRule(index || 0);\n        } else {\n          sheet.deleteRule(rule.index);\n        }\n      } catch (e) {}\n    } else if (rule.type === StyleRuleType.Snapshot) {\n      restoreSnapshotOfStyleRulesToNode(rule.cssTexts, styleNode);\n    } else if (rule.type === StyleRuleType.SetProperty) {\n      var nativeRule = getNestedRule(sheet.cssRules, rule.index);\n      nativeRule.style.setProperty(rule.property, rule.value, rule.priority);\n    } else if (rule.type === StyleRuleType.RemoveProperty) {\n      var nativeRule = getNestedRule(sheet.cssRules, rule.index);\n      nativeRule.style.removeProperty(rule.property);\n    }\n  });\n}\n\nfunction restoreSnapshotOfStyleRulesToNode(cssTexts, styleNode) {\n  var _a;\n\n  try {\n    var existingRules = Array.from(((_a = styleNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) || []).map(function (rule) {\n      return rule.cssText;\n    });\n    var existingRulesReversed = Object.entries(existingRules).reverse();\n    var lastMatch_1 = existingRules.length;\n    existingRulesReversed.forEach(function (_a) {\n      var _b;\n\n      var _c = __read(_a, 2),\n          index = _c[0],\n          rule = _c[1];\n\n      var indexOf = cssTexts.indexOf(rule);\n\n      if (indexOf === -1 || indexOf > lastMatch_1) {\n        try {\n          (_b = styleNode.sheet) === null || _b === void 0 ? void 0 : _b.deleteRule(Number(index));\n        } catch (e) {}\n      }\n\n      lastMatch_1 = indexOf;\n    });\n    cssTexts.forEach(function (cssText, index) {\n      var _a, _b, _c;\n\n      try {\n        if (((_b = (_a = styleNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules[index]) === null || _b === void 0 ? void 0 : _b.cssText) !== cssText) {\n          (_c = styleNode.sheet) === null || _c === void 0 ? void 0 : _c.insertRule(cssText, index);\n        }\n      } catch (e) {}\n    });\n  } catch (e) {}\n}\n\nfunction storeCSSRules(parentElement, virtualStyleRulesMap) {\n  var _a;\n\n  try {\n    var cssTexts = Array.from(((_a = parentElement.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) || []).map(function (rule) {\n      return rule.cssText;\n    });\n    virtualStyleRulesMap.set(parentElement, [{\n      type: StyleRuleType.Snapshot,\n      cssTexts: cssTexts\n    }]);\n  } catch (e) {}\n}\n\nvar webGLVarMap = new Map();\n\nfunction variableListFor(ctx, ctor) {\n  var contextMap = webGLVarMap.get(ctx);\n\n  if (!contextMap) {\n    contextMap = new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n\n  return contextMap.get(ctor);\n}\n\nfunction getContext(target, type) {\n  try {\n    if (type === CanvasContext.WebGL) {\n      return target.getContext('webgl') || target.getContext('experimental-webgl');\n    }\n\n    return target.getContext('webgl2');\n  } catch (e) {\n    return null;\n  }\n}\n\nvar WebGLVariableConstructorsNames = ['WebGLActiveInfo', 'WebGLBuffer', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLRenderbuffer', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLTexture', 'WebGLUniformLocation', 'WebGLVertexArrayObject'];\n\nfunction saveToWebGLVarMap(ctx, result) {\n  if (!(result === null || result === void 0 ? void 0 : result.constructor)) return;\n  var name = result.constructor.name;\n  if (!WebGLVariableConstructorsNames.includes(name)) return;\n  var variables = variableListFor(ctx, name);\n  if (!variables.includes(result)) variables.push(result);\n}\n\nfunction deserializeArg(imageMap, ctx) {\n  return function (arg) {\n    if (arg && typeof arg === 'object' && 'rr_type' in arg) {\n      if ('index' in arg) {\n        var name_1 = arg.rr_type,\n            index = arg.index;\n        return variableListFor(ctx, name_1)[index];\n      } else if ('args' in arg) {\n        var name_2 = arg.rr_type,\n            args = arg.args;\n        var ctor = window[name_2];\n        return new (ctor.bind.apply(ctor, __spreadArray([void 0], __read(args.map(deserializeArg(imageMap, ctx))), false)))();\n      } else if ('base64' in arg) {\n        return decode(arg.base64);\n      } else if ('src' in arg) {\n        var image = imageMap.get(arg.src);\n\n        if (image) {\n          return image;\n        } else {\n          var image_1 = new Image();\n          image_1.src = arg.src;\n          imageMap.set(arg.src, image_1);\n          return image_1;\n        }\n      }\n    } else if (Array.isArray(arg)) {\n      return arg.map(deserializeArg(imageMap, ctx));\n    }\n\n    return arg;\n  };\n}\n\nfunction webglMutation(_a) {\n  var mutation = _a.mutation,\n      target = _a.target,\n      type = _a.type,\n      imageMap = _a.imageMap,\n      errorHandler = _a.errorHandler;\n\n  try {\n    if ((mutation.property === 'dataURL' || mutation.property === 'aniDataURL') && typeof mutation.args[0] === 'string') {\n      var image_2 = document.createElement('img');\n      image_2.src = mutation.args[0];\n\n      image_2.onload = function () {\n        var ctx2d = target.getContext('2d');\n\n        if (ctx2d) {\n          ctx2d.clearRect(0, 0, image_2.width, image_2.height);\n          ctx2d.drawImage(image_2, 0, 0, image_2.width, image_2.height);\n        }\n      };\n\n      return;\n    }\n\n    var ctx = getContext(target, type);\n    if (!ctx) return;\n\n    if (mutation.setter) {\n      ctx[mutation.property] = mutation.args[0];\n      return;\n    }\n\n    var original = ctx[mutation.property];\n    var args = mutation.args.map(deserializeArg(imageMap, ctx));\n    var result = original.apply(ctx, args);\n    saveToWebGLVarMap(ctx, result);\n    var debugMode = false;\n\n    if (debugMode) {\n      if (mutation.property === 'compileShader') {\n        if (!ctx.getShaderParameter(args[0], ctx.COMPILE_STATUS)) console.warn('something went wrong in replay', ctx.getShaderInfoLog(args[0]));\n      } else if (mutation.property === 'linkProgram') {\n        ctx.validateProgram(args[0]);\n        if (!ctx.getProgramParameter(args[0], ctx.LINK_STATUS)) console.warn('something went wrong in replay', ctx.getProgramInfoLog(args[0]));\n      }\n\n      var webglError = ctx.getError();\n\n      if (webglError !== ctx.NO_ERROR) {\n        console.warn.apply(console, __spreadArray(['WEBGL ERROR', webglError, 'on command:', mutation.property], __read(args), false));\n      }\n    }\n  } catch (error) {\n    errorHandler(mutation, error);\n  }\n}\n\nfunction canvasMutation$1(_a) {\n  var event = _a.event,\n      mutation = _a.mutation,\n      target = _a.target,\n      imageMap = _a.imageMap,\n      errorHandler = _a.errorHandler;\n\n  try {\n    var ctx_1 = target.getContext('2d');\n\n    if (mutation.setter) {\n      ctx_1[mutation.property] = mutation.args[0];\n      return;\n    }\n\n    var original = ctx_1[mutation.property];\n\n    if (mutation.property === 'drawImage' && typeof mutation.args[0] === 'string') {\n      var image = imageMap.get(event);\n\n      if (image) {\n        mutation.args[0] = image;\n        original.apply(ctx_1, mutation.args);\n      } else {\n        image = new Image();\n        image.src = mutation.args[0];\n        mutation.args[0] = image;\n        original.apply(ctx_1, mutation.args);\n      }\n    } else if ((mutation.property === 'dataURL' || mutation.property === 'aniDataURL') && typeof mutation.args[0] === 'string') {\n      var image_1 = document.createElement('img');\n      image_1.src = mutation.args[0];\n\n      image_1.onload = function () {\n        if (ctx_1) {\n          ctx_1.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n        }\n      };\n    } else if (original) {\n      original.apply(ctx_1, mutation.args);\n    }\n  } catch (error) {\n    errorHandler(mutation, error);\n  }\n}\n\nfunction canvasMutation(_a) {\n  var event = _a.event,\n      mutation = _a.mutation,\n      target = _a.target,\n      imageMap = _a.imageMap,\n      errorHandler = _a.errorHandler;\n\n  try {\n    var mutations = 'commands' in mutation ? mutation.commands : [mutation];\n\n    if ([CanvasContext.WebGL, CanvasContext.WebGL2].includes(mutation.type)) {\n      return mutations.forEach(function (command) {\n        if (command.property === 'dataURL' || command.property === 'aniDataURL') {\n          webglMutation({\n            mutation: {\n              property: command.property,\n              args: command['args']\n            },\n            type: mutation.type,\n            target: target,\n            imageMap: imageMap,\n            errorHandler: errorHandler\n          });\n        } else {\n          webglMutation({\n            mutation: command,\n            type: mutation.type,\n            target: target,\n            imageMap: imageMap,\n            errorHandler: errorHandler\n          });\n        }\n      });\n    }\n\n    return mutations.forEach(function (command) {\n      canvasMutation$1({\n        event: event,\n        mutation: command,\n        target: target,\n        imageMap: imageMap,\n        errorHandler: errorHandler\n      });\n    });\n  } catch (error) {\n    errorHandler(mutation, error);\n  }\n}\n\nvar SKIP_TIME_THRESHOLD = 10 * 1000;\nvar SKIP_TIME_INTERVAL = 5 * 1000;\nvar mitt = mitt$1 || mittProxy;\nvar REPLAY_CONSOLE_PREFIX = '[replayer]';\nvar defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: 'round',\n  lineWidth: 3,\n  strokeStyle: 'red'\n};\n\nfunction indicatesTouchDevice(e) {\n  return e.type == exports.tw.IncrementalSnapshot && (e.data.source == exports.yh.TouchMove || e.data.source == exports.yh.MouseInteraction && e.data.type == exports.Y2.TouchStart);\n}\n\nvar Replayer = function () {\n  function Replayer(events, config) {\n    var _this = this;\n\n    this.mouseTail = null;\n    this.tailPositions = [];\n    this.emitter = mitt();\n    this.legacy_missingNodeRetryMap = {};\n    this.cache = createCache();\n    this.imageMap = new Map();\n    this.mirror = createMirror();\n    this.firstFullSnapshot = null;\n    this.newDocumentQueue = [];\n    this.mousePos = null;\n    this.touchActive = null;\n    this.misssedQueueNodeTrees = [];\n\n    if (!(config === null || config === void 0 ? void 0 : config.liveMode) && events.length < 2) {\n      throw new Error('Replayer need at least 2 events.');\n    }\n\n    var defaultConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      showWarning: true,\n      showDebug: false,\n      blockClass: 'rr-block',\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.applyEventsSynchronously = this.applyEventsSynchronously.bind(this);\n    this.emitter.on(exports.SA.Resize, this.handleResize);\n    this.setupDom();\n    this.treeIndex = new TreeIndex();\n    this.fragmentParentMap = new Map();\n    this.elementStateMap = new Map();\n    this.virtualStyleRulesMap = new Map();\n    this.emitter.on(exports.SA.Flush, function () {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      var _d = _this.treeIndex.flush(),\n          scrollMap = _d.scrollMap,\n          inputMap = _d.inputMap;\n\n      _this.fragmentParentMap.forEach(function (parent, frag) {\n        return _this.restoreRealParent(frag, parent);\n      });\n\n      try {\n        for (var _e = __values(_this.virtualStyleRulesMap.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var node = _f.value;\n\n          _this.restoreNodeSheet(node);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      _this.fragmentParentMap.clear();\n\n      _this.elementStateMap.clear();\n\n      _this.virtualStyleRulesMap.clear();\n\n      try {\n        for (var _g = __values(scrollMap.values()), _h = _g.next(); !_h.done; _h = _g.next()) {\n          var d = _h.value;\n\n          _this.applyScroll(d, true);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        for (var _j = __values(inputMap.values()), _k = _j.next(); !_k.done; _k = _j.next()) {\n          var d = _k.value;\n\n          _this.applyInput(d);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    });\n    this.emitter.on(exports.SA.PlayBack, function () {\n      _this.firstFullSnapshot = null;\n\n      _this.mirror.reset();\n    });\n    var timer = new Timer([], (config === null || config === void 0 ? void 0 : config.speed) || defaultConfig.speed);\n    this.service = createPlayerService({\n      events: events.map(function (e) {\n        if (config && config.unpackFn) {\n          return config.unpackFn(e);\n        }\n\n        return e;\n      }).sort(function (a1, a2) {\n        return a1.timestamp - a2.timestamp;\n      }),\n      timer: timer,\n      timeOffset: 0,\n      baselineTime: 0,\n      lastPlayedEvent: null\n    }, {\n      getCastFn: this.getCastFn,\n      applyEventsSynchronously: this.applyEventsSynchronously,\n      emitter: this.emitter\n    });\n    this.service.start();\n    this.service.subscribe(function (state) {\n      _this.emitter.emit(exports.SA.StateChange, {\n        player: state\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer: timer\n    });\n    this.speedService.start();\n    this.speedService.subscribe(function (state) {\n      _this.emitter.emit(exports.SA.StateChange, {\n        speed: state\n      });\n    });\n    var firstMeta = this.service.state.context.events.find(function (e) {\n      return e.type === exports.tw.Meta;\n    });\n    var firstFullsnapshot = this.service.state.context.events.find(function (e) {\n      return e.type === exports.tw.FullSnapshot;\n    });\n\n    if (firstMeta) {\n      var _a = firstMeta.data,\n          width_1 = _a.width,\n          height_1 = _a.height;\n      setTimeout(function () {\n        _this.emitter.emit(exports.SA.Resize, {\n          width: width_1,\n          height: height_1\n        });\n      }, 0);\n    }\n\n    if (firstFullsnapshot) {\n      setTimeout(function () {\n        if (_this.firstFullSnapshot) {\n          return;\n        }\n\n        _this.firstFullSnapshot = firstFullsnapshot;\n\n        _this.rebuildFullSnapshot(firstFullsnapshot);\n\n        _this.iframe.contentWindow.scrollTo(firstFullsnapshot.data.initialOffset);\n      }, 1);\n    }\n\n    if (this.service.state.context.events.find(indicatesTouchDevice)) {\n      this.mouse.classList.add('touch-device');\n    }\n  }\n\n  Object.defineProperty(Replayer.prototype, \"timer\", {\n    get: function () {\n      return this.service.state.context.timer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Replayer.prototype.on = function (event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  };\n\n  Replayer.prototype.off = function (event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  };\n\n  Replayer.prototype.setConfig = function (config) {\n    var _this = this;\n\n    Object.keys(config).forEach(function (key) {\n      _this.config[key] = config[key];\n    });\n\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    }\n\n    if (typeof config.speed !== 'undefined') {\n      this.speedService.send({\n        type: 'SET_SPEED',\n        payload: {\n          speed: config.speed\n        }\n      });\n    }\n\n    if (typeof config.mouseTail !== 'undefined') {\n      if (config.mouseTail === false) {\n        if (this.mouseTail) {\n          this.mouseTail.style.display = 'none';\n        }\n      } else {\n        if (!this.mouseTail) {\n          this.mouseTail = document.createElement('canvas');\n          this.mouseTail.width = Number.parseFloat(this.iframe.width);\n          this.mouseTail.height = Number.parseFloat(this.iframe.height);\n          this.mouseTail.classList.add('replayer-mouse-tail');\n          this.wrapper.insertBefore(this.mouseTail, this.iframe);\n        }\n\n        this.mouseTail.style.display = 'inherit';\n      }\n    }\n  };\n\n  Replayer.prototype.getMetaData = function () {\n    var firstEvent = this.service.state.context.events[0];\n    var lastEvent = this.service.state.context.events[this.service.state.context.events.length - 1];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp\n    };\n  };\n\n  Replayer.prototype.getCurrentTime = function () {\n    return this.timer.timeOffset + this.getTimeOffset();\n  };\n\n  Replayer.prototype.getTimeOffset = function () {\n    var _a = this.service.state.context,\n        baselineTime = _a.baselineTime,\n        events = _a.events;\n    return baselineTime - events[0].timestamp;\n  };\n\n  Replayer.prototype.getMirror = function () {\n    return this.mirror;\n  };\n\n  Replayer.prototype.play = function (timeOffset) {\n    var _a;\n\n    if (timeOffset === void 0) {\n      timeOffset = 0;\n    }\n\n    if (this.service.state.matches('paused')) {\n      this.service.send({\n        type: 'PLAY',\n        payload: {\n          timeOffset: timeOffset\n        }\n      });\n    } else {\n      this.service.send({\n        type: 'PAUSE'\n      });\n      this.service.send({\n        type: 'PLAY',\n        payload: {\n          timeOffset: timeOffset\n        }\n      });\n    }\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('html')[0].classList.remove('rrweb-paused');\n    this.emitter.emit(exports.SA.Start);\n  };\n\n  Replayer.prototype.pause = function (timeOffset) {\n    var _a;\n\n    if (timeOffset === undefined && this.service.state.matches('playing')) {\n      this.service.send({\n        type: 'PAUSE'\n      });\n    }\n\n    if (typeof timeOffset === 'number') {\n      this.play(timeOffset);\n      this.service.send({\n        type: 'PAUSE'\n      });\n    }\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('html')[0].classList.add('rrweb-paused');\n    this.emitter.emit(exports.SA.Pause);\n  };\n\n  Replayer.prototype.resume = function (timeOffset) {\n    if (timeOffset === void 0) {\n      timeOffset = 0;\n    }\n\n    console.warn(\"The 'resume' will be departed in 1.0. Please use 'play' method which has the same interface.\");\n    this.play(timeOffset);\n    this.emitter.emit(exports.SA.Resume);\n  };\n\n  Replayer.prototype.startLive = function (baselineTime) {\n    this.service.send({\n      type: 'TO_LIVE',\n      payload: {\n        baselineTime: baselineTime\n      }\n    });\n  };\n\n  Replayer.prototype.addEvent = function (rawEvent) {\n    var _this = this;\n\n    var event = this.config.unpackFn ? this.config.unpackFn(rawEvent) : rawEvent;\n\n    if (indicatesTouchDevice(event)) {\n      this.mouse.classList.add('touch-device');\n    }\n\n    Promise.resolve().then(function () {\n      return _this.service.send({\n        type: 'ADD_EVENT',\n        payload: {\n          event: event\n        }\n      });\n    });\n  };\n\n  Replayer.prototype.enableInteract = function () {\n    this.iframe.setAttribute('scrolling', 'auto');\n    this.iframe.style.pointerEvents = 'auto';\n  };\n\n  Replayer.prototype.disableInteract = function () {\n    this.iframe.setAttribute('scrolling', 'no');\n    this.iframe.style.pointerEvents = 'none';\n  };\n\n  Replayer.prototype.resetCache = function () {\n    this.cache = createCache();\n  };\n\n  Replayer.prototype.setupDom = function () {\n    this.wrapper = document.createElement('div');\n    this.wrapper.classList.add('replayer-wrapper');\n    this.config.root.appendChild(this.wrapper);\n    this.mouse = document.createElement('div');\n    this.mouse.classList.add('replayer-mouse');\n    this.wrapper.appendChild(this.mouse);\n\n    if (this.config.mouseTail !== false) {\n      this.mouseTail = document.createElement('canvas');\n      this.mouseTail.classList.add('replayer-mouse-tail');\n      this.mouseTail.style.display = 'inherit';\n      this.wrapper.appendChild(this.mouseTail);\n    }\n\n    this.iframe = document.createElement('iframe');\n    var attributes = ['allow-same-origin'];\n\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes.push('allow-scripts');\n    }\n\n    this.iframe.style.display = 'none';\n    this.iframe.setAttribute('sandbox', attributes.join(' '));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n\n    if (this.iframe.contentWindow && this.iframe.contentDocument) {\n      polyfill(this.iframe.contentWindow, this.iframe.contentDocument);\n      polyfill$1(this.iframe.contentWindow);\n    }\n  };\n\n  Replayer.prototype.handleResize = function (dimension) {\n    var e_4, _a;\n\n    this.iframe.style.display = 'inherit';\n\n    try {\n      for (var _b = __values([this.mouseTail, this.iframe]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var el = _c.value;\n\n        if (!el) {\n          continue;\n        }\n\n        el.setAttribute('width', String(dimension.width));\n        el.setAttribute('height', String(dimension.height));\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n\n  Replayer.prototype.applyEventsSynchronously = function (events) {\n    var e_5, _a;\n\n    try {\n      for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {\n        var event_1 = events_1_1.value;\n\n        switch (event_1.type) {\n          case exports.tw.DomContentLoaded:\n          case exports.tw.Load:\n          case exports.tw.Custom:\n            continue;\n\n          case exports.tw.FullSnapshot:\n          case exports.tw.Meta:\n          case exports.tw.Plugin:\n            break;\n\n          case exports.tw.IncrementalSnapshot:\n            switch (event_1.data.source) {\n              case exports.yh.MediaInteraction:\n                continue;\n\n              default:\n                break;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        var castFn = this.getCastFn(event_1, true);\n        castFn();\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    if (this.mousePos) {\n      this.moveAndHover(this.mousePos.x, this.mousePos.y, this.mousePos.id, true, this.mousePos.debugData);\n    }\n\n    this.mousePos = null;\n\n    if (this.touchActive === true) {\n      this.mouse.classList.add('touch-active');\n    } else if (this.touchActive === false) {\n      this.mouse.classList.remove('touch-active');\n    }\n\n    this.touchActive = null;\n  };\n\n  Replayer.prototype.getCastFn = function (event, isSync) {\n    var _this = this;\n\n    if (isSync === void 0) {\n      isSync = false;\n    }\n\n    var castFn;\n\n    switch (event.type) {\n      case exports.tw.DomContentLoaded:\n      case exports.tw.Load:\n        break;\n\n      case exports.tw.Custom:\n        castFn = function () {\n          _this.emitter.emit(exports.SA.CustomEvent, event);\n        };\n\n        break;\n\n      case exports.tw.Meta:\n        castFn = function () {\n          return _this.emitter.emit(exports.SA.Resize, {\n            width: event.data.width,\n            height: event.data.height\n          });\n        };\n\n        break;\n\n      case exports.tw.FullSnapshot:\n        castFn = function () {\n          if (_this.firstFullSnapshot) {\n            if (_this.firstFullSnapshot === event) {\n              _this.firstFullSnapshot = true;\n              return;\n            }\n          } else {\n            _this.firstFullSnapshot = true;\n          }\n\n          _this.rebuildFullSnapshot(event, isSync);\n\n          _this.iframe.contentWindow.scrollTo(event.data.initialOffset);\n        };\n\n        break;\n\n      case exports.tw.IncrementalSnapshot:\n        castFn = function () {\n          var e_6, _a;\n\n          _this.applyIncremental(event, isSync);\n\n          if (isSync) {\n            return;\n          }\n\n          if (event === _this.nextUserInteractionEvent) {\n            _this.nextUserInteractionEvent = null;\n\n            _this.backToNormal();\n          }\n\n          if (_this.config.skipInactive && !_this.nextUserInteractionEvent) {\n            try {\n              for (var _b = __values(_this.service.state.context.events), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _event = _c.value;\n\n                if (_event.timestamp <= event.timestamp) {\n                  continue;\n                }\n\n                if (_this.isUserInteraction(_event)) {\n                  if (_event.delay - event.delay > SKIP_TIME_THRESHOLD * _this.speedService.state.context.timer.speed) {\n                    _this.nextUserInteractionEvent = _event;\n                  }\n\n                  break;\n                }\n              }\n            } catch (e_6_1) {\n              e_6 = {\n                error: e_6_1\n              };\n            } finally {\n              try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n              } finally {\n                if (e_6) throw e_6.error;\n              }\n            }\n\n            if (_this.nextUserInteractionEvent) {\n              var skipTime = _this.nextUserInteractionEvent.delay - event.delay;\n              var payload = {\n                speed: Math.min(Math.round(skipTime / SKIP_TIME_INTERVAL), _this.config.maxSpeed)\n              };\n\n              _this.speedService.send({\n                type: 'FAST_FORWARD',\n                payload: payload\n              });\n\n              _this.emitter.emit(exports.SA.SkipStart, payload);\n            }\n          }\n        };\n\n        break;\n    }\n\n    var wrappedCastFn = function () {\n      var e_7, _a;\n\n      if (castFn) {\n        castFn();\n      }\n\n      try {\n        for (var _b = __values(_this.config.plugins || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var plugin = _c.value;\n          plugin.handler(event, isSync, {\n            replayer: _this\n          });\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n\n      _this.service.send({\n        type: 'CAST_EVENT',\n        payload: {\n          event: event\n        }\n      });\n\n      var last_index = _this.service.state.context.events.length - 1;\n\n      if (event === _this.service.state.context.events[last_index]) {\n        var finish_1 = function () {\n          if (last_index < _this.service.state.context.events.length - 1) {\n            return;\n          }\n\n          _this.backToNormal();\n\n          _this.service.send('END');\n\n          _this.emitter.emit(exports.SA.Finish);\n        };\n\n        if (event.type === exports.tw.IncrementalSnapshot && event.data.source === exports.yh.MouseMove && event.data.positions.length) {\n          setTimeout(function () {\n            finish_1();\n          }, Math.max(0, -event.data.positions[0].timeOffset + 50));\n        } else {\n          finish_1();\n        }\n      }\n\n      _this.emitter.emit(exports.SA.EventCast, event);\n    };\n\n    return wrappedCastFn;\n  };\n\n  Replayer.prototype.rebuildFullSnapshot = function (event, isSync) {\n    var e_8, _a;\n\n    var _this = this;\n\n    if (isSync === void 0) {\n      isSync = false;\n    }\n\n    if (!this.iframe.contentDocument) {\n      return console.warn('Looks like your replayer has been destroyed.');\n    }\n\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      console.warn('Found unresolved missing node map', this.legacy_missingNodeRetryMap);\n    }\n\n    this.legacy_missingNodeRetryMap = {};\n    var collected = [];\n    this.mirror.map = rebuild(event.data.node, {\n      doc: this.iframe.contentDocument,\n      afterAppend: function (builtNode) {\n        _this.collectIframeAndAttachDocument(collected, builtNode);\n      },\n      cache: this.cache\n    })[1];\n\n    var _loop_1 = function (mutationInQueue, builtNode) {\n      this_1.attachDocumentToIframe(mutationInQueue, builtNode);\n      this_1.newDocumentQueue = this_1.newDocumentQueue.filter(function (m) {\n        return m !== mutationInQueue;\n      });\n\n      if (builtNode.contentDocument) {\n        var _d = builtNode.contentDocument,\n            documentElement_1 = _d.documentElement,\n            head_1 = _d.head;\n        this_1.insertStyleRules(documentElement_1, head_1);\n      }\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var collected_1 = __values(collected), collected_1_1 = collected_1.next(); !collected_1_1.done; collected_1_1 = collected_1.next()) {\n        var _b = collected_1_1.value,\n            mutationInQueue = _b.mutationInQueue,\n            builtNode = _b.builtNode;\n\n        _loop_1(mutationInQueue, builtNode);\n      }\n    } catch (e_8_1) {\n      e_8 = {\n        error: e_8_1\n      };\n    } finally {\n      try {\n        if (collected_1_1 && !collected_1_1.done && (_a = collected_1.return)) _a.call(collected_1);\n      } finally {\n        if (e_8) throw e_8.error;\n      }\n    }\n\n    var _c = this.iframe.contentDocument,\n        documentElement = _c.documentElement,\n        head = _c.head;\n    this.insertStyleRules(documentElement, head);\n\n    if (!this.service.state.matches('playing')) {\n      this.iframe.contentDocument.getElementsByTagName('html')[0].classList.add('rrweb-paused');\n    }\n\n    this.emitter.emit(exports.SA.FullsnapshotRebuilded, event);\n\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n\n    if (this.config.UNSAFE_replayCanvas) {\n      this.preloadAllImages();\n    }\n  };\n\n  Replayer.prototype.insertStyleRules = function (documentElement, head) {\n    var styleEl = document.createElement('style');\n    documentElement.insertBefore(styleEl, head);\n    var injectStylesRules = rules(this.config.blockClass).concat(this.config.insertStyleRules);\n\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push('html.rrweb-paused *, html.rrweb-paused *:before, html.rrweb-paused *:after { animation-play-state: paused !important; }');\n    }\n\n    for (var idx = 0; idx < injectStylesRules.length; idx++) {\n      styleEl.sheet.insertRule(injectStylesRules[idx], idx);\n    }\n  };\n\n  Replayer.prototype.attachDocumentToIframe = function (mutation, iframeEl) {\n    var e_9, _a;\n\n    var _this = this;\n\n    var collected = [];\n\n    if (!iframeEl.contentDocument) {\n      var parent_1 = iframeEl.parentNode;\n\n      while (parent_1) {\n        if (this.fragmentParentMap.has(parent_1)) {\n          var frag = parent_1;\n          var realParent = this.fragmentParentMap.get(frag);\n          this.restoreRealParent(frag, realParent);\n          break;\n        }\n\n        parent_1 = parent_1.parentNode;\n      }\n    }\n\n    buildNodeWithSN(mutation.node, {\n      doc: iframeEl.contentDocument,\n      map: this.mirror.map,\n      hackCss: true,\n      skipChild: false,\n      afterAppend: function (builtNode) {\n        _this.collectIframeAndAttachDocument(collected, builtNode);\n\n        if (builtNode.__sn.type === NodeType.Element && builtNode.__sn.tagName.toUpperCase() === 'HTML') {\n          var _a = iframeEl.contentDocument,\n              documentElement = _a.documentElement,\n              head = _a.head;\n\n          _this.insertStyleRules(documentElement, head);\n        }\n      },\n      cache: this.cache\n    });\n\n    var _loop_2 = function (mutationInQueue, builtNode) {\n      this_2.attachDocumentToIframe(mutationInQueue, builtNode);\n      this_2.newDocumentQueue = this_2.newDocumentQueue.filter(function (m) {\n        return m !== mutationInQueue;\n      });\n\n      if (builtNode.contentDocument) {\n        var _c = builtNode.contentDocument,\n            documentElement = _c.documentElement,\n            head = _c.head;\n        this_2.insertStyleRules(documentElement, head);\n      }\n    };\n\n    var this_2 = this;\n\n    try {\n      for (var collected_2 = __values(collected), collected_2_1 = collected_2.next(); !collected_2_1.done; collected_2_1 = collected_2.next()) {\n        var _b = collected_2_1.value,\n            mutationInQueue = _b.mutationInQueue,\n            builtNode = _b.builtNode;\n\n        _loop_2(mutationInQueue, builtNode);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (collected_2_1 && !collected_2_1.done && (_a = collected_2.return)) _a.call(collected_2);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n\n  Replayer.prototype.collectIframeAndAttachDocument = function (collected, builtNode) {\n    if (isIframeINode(builtNode)) {\n      var mutationInQueue = this.newDocumentQueue.find(function (m) {\n        return m.parentId === builtNode.__sn.id;\n      });\n\n      if (mutationInQueue) {\n        collected.push({\n          mutationInQueue: mutationInQueue,\n          builtNode: builtNode\n        });\n      }\n    }\n  };\n\n  Replayer.prototype.waitForStylesheetLoad = function () {\n    var _this = this;\n\n    var _a;\n\n    var head = (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.head;\n\n    if (head) {\n      var unloadSheets_1 = new Set();\n      var timer_1;\n      var beforeLoadState_1 = this.service.state;\n\n      var stateHandler_1 = function () {\n        beforeLoadState_1 = _this.service.state;\n      };\n\n      this.emitter.on(exports.SA.Start, stateHandler_1);\n      this.emitter.on(exports.SA.Pause, stateHandler_1);\n\n      var unsubscribe_1 = function () {\n        _this.emitter.off(exports.SA.Start, stateHandler_1);\n\n        _this.emitter.off(exports.SA.Pause, stateHandler_1);\n      };\n\n      head.querySelectorAll('link[rel=\"stylesheet\"]').forEach(function (css) {\n        if (!css.sheet) {\n          unloadSheets_1.add(css);\n          css.addEventListener('load', function () {\n            unloadSheets_1.delete(css);\n\n            if (unloadSheets_1.size === 0 && timer_1 !== -1) {\n              if (beforeLoadState_1.matches('playing')) {\n                _this.play(_this.getCurrentTime());\n              }\n\n              _this.emitter.emit(exports.SA.LoadStylesheetEnd);\n\n              if (timer_1) {\n                clearTimeout(timer_1);\n              }\n\n              unsubscribe_1();\n            }\n          });\n        }\n      });\n\n      if (unloadSheets_1.size > 0) {\n        this.service.send({\n          type: 'PAUSE'\n        });\n        this.emitter.emit(exports.SA.LoadStylesheetStart);\n        timer_1 = setTimeout(function () {\n          if (beforeLoadState_1.matches('playing')) {\n            _this.play(_this.getCurrentTime());\n          }\n\n          timer_1 = -1;\n          unsubscribe_1();\n        }, this.config.loadTimeout);\n      }\n    }\n  };\n\n  Replayer.prototype.hasImageArg = function (args) {\n    var e_10, _a;\n\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var arg = args_1_1.value;\n\n        if (!arg || typeof arg !== 'object') {} else if ('rr_type' in arg && 'args' in arg) {\n          if (this.hasImageArg(arg.args)) return true;\n        } else if ('rr_type' in arg && arg.rr_type === 'HTMLImageElement') {\n          return true;\n        } else if (arg instanceof Array) {\n          if (this.hasImageArg(arg)) return true;\n        }\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n\n    return false;\n  };\n\n  Replayer.prototype.getImageArgs = function (args) {\n    var e_11, _a;\n\n    var images = [];\n\n    try {\n      for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {\n        var arg = args_2_1.value;\n\n        if (!arg || typeof arg !== 'object') {} else if ('rr_type' in arg && 'args' in arg) {\n          images.push.apply(images, __spreadArray([], __read(this.getImageArgs(arg.args)), false));\n        } else if ('rr_type' in arg && arg.rr_type === 'HTMLImageElement') {\n          images.push(arg.src);\n        } else if (arg instanceof Array) {\n          images.push.apply(images, __spreadArray([], __read(this.getImageArgs(arg)), false));\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n\n    return images;\n  };\n\n  Replayer.prototype.preloadAllImages = function () {\n    var e_12, _a;\n\n    var _this = this;\n\n    this.service.state;\n\n    var stateHandler = function () {\n      _this.service.state;\n    };\n\n    this.emitter.on(exports.SA.Start, stateHandler);\n    this.emitter.on(exports.SA.Pause, stateHandler);\n\n    var _loop_3 = function (event_2) {\n      if (event_2.type === exports.tw.IncrementalSnapshot && event_2.data.source === exports.yh.CanvasMutation) if ('commands' in event_2.data) {\n        event_2.data.commands.forEach(function (c) {\n          return _this.preloadImages(c, event_2);\n        });\n      } else {\n        this_3.preloadImages(event_2.data, event_2);\n      }\n    };\n\n    var this_3 = this;\n\n    try {\n      for (var _b = __values(this.service.state.context.events), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var event_2 = _c.value;\n\n        _loop_3(event_2);\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n  };\n\n  Replayer.prototype.preloadImages = function (data, event) {\n    var _this = this;\n\n    if (data.property === 'drawImage' && typeof data.args[0] === 'string' && !this.imageMap.has(event)) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      var imgd = ctx === null || ctx === void 0 ? void 0 : ctx.createImageData(canvas.width, canvas.height);\n      imgd === null || imgd === void 0 ? void 0 : imgd.data;\n      JSON.parse(data.args[0]);\n      ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(imgd, 0, 0);\n    } else if (this.hasImageArg(data.args)) {\n      this.getImageArgs(data.args).forEach(function (url) {\n        var image = new Image();\n        image.src = url;\n\n        _this.imageMap.set(url, image);\n      });\n    }\n  };\n\n  Replayer.prototype.applyIncremental = function (e, isSync) {\n    var _this = this;\n\n    var _a, _b;\n\n    var d = e.data;\n\n    switch (d.source) {\n      case exports.yh.Mutation:\n        {\n          if (isSync) {\n            d.adds.forEach(function (m) {\n              return _this.treeIndex.add(m);\n            });\n            d.texts.forEach(function (m) {\n              return _this.treeIndex.text(m);\n            });\n            d.attributes.forEach(function (m) {\n              return _this.treeIndex.attribute(m);\n            });\n            d.removes.forEach(function (m) {\n              return _this.treeIndex.remove(m, _this.mirror);\n            });\n          }\n\n          try {\n            this.applyMutation(d, isSync);\n          } catch (error) {\n            this.warn(\"Exception in mutation \".concat(error.message || error), d);\n          }\n\n          break;\n        }\n\n      case exports.yh.Drag:\n      case exports.yh.TouchMove:\n      case exports.yh.MouseMove:\n        if (isSync) {\n          var lastPosition = d.positions[d.positions.length - 1];\n          this.mousePos = {\n            x: lastPosition.x,\n            y: lastPosition.y,\n            id: lastPosition.id,\n            debugData: d\n          };\n        } else {\n          d.positions.forEach(function (p) {\n            var action = {\n              doAction: function () {\n                _this.moveAndHover(p.x, p.y, p.id, isSync, d);\n              },\n              delay: p.timeOffset + e.timestamp - _this.service.state.context.baselineTime\n            };\n\n            _this.timer.addAction(action);\n          });\n          this.timer.addAction({\n            doAction: function () {},\n            delay: e.delay - ((_a = d.positions[0]) === null || _a === void 0 ? void 0 : _a.timeOffset)\n          });\n        }\n\n        break;\n\n      case exports.yh.MouseInteraction:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          var event_3 = new Event(exports.Y2[d.type].toLowerCase());\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          this.emitter.emit(exports.SA.MouseInteraction, {\n            type: d.type,\n            target: target\n          });\n          var triggerFocus = this.config.triggerFocus;\n\n          switch (d.type) {\n            case exports.Y2.Blur:\n              if ('blur' in target) {\n                target.blur();\n              }\n\n              break;\n\n            case exports.Y2.Focus:\n              if (triggerFocus && target.focus) {\n                target.focus({\n                  preventScroll: true\n                });\n              }\n\n              break;\n\n            case exports.Y2.Click:\n            case exports.Y2.TouchStart:\n            case exports.Y2.TouchEnd:\n              if (isSync) {\n                if (d.type === exports.Y2.TouchStart) {\n                  this.touchActive = true;\n                } else if (d.type === exports.Y2.TouchEnd) {\n                  this.touchActive = false;\n                }\n\n                this.mousePos = {\n                  x: d.x,\n                  y: d.y,\n                  id: d.id,\n                  debugData: d\n                };\n              } else {\n                if (d.type === exports.Y2.TouchStart) {\n                  this.tailPositions.length = 0;\n                }\n\n                this.moveAndHover(d.x, d.y, d.id, isSync, d);\n\n                if (d.type === exports.Y2.Click) {\n                  this.mouse.classList.remove('active');\n                  void this.mouse.offsetWidth;\n                  this.mouse.classList.add('active');\n                } else if (d.type === exports.Y2.TouchStart) {\n                  void this.mouse.offsetWidth;\n                  this.mouse.classList.add('touch-active');\n                } else if (d.type === exports.Y2.TouchEnd) {\n                  this.mouse.classList.remove('touch-active');\n                }\n              }\n\n              break;\n\n            case exports.Y2.TouchCancel:\n              if (isSync) {\n                this.touchActive = false;\n              } else {\n                this.mouse.classList.remove('touch-active');\n              }\n\n              break;\n\n            default:\n              target.dispatchEvent(event_3);\n          }\n\n          break;\n        }\n\n      case exports.yh.Scroll:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          if (isSync) {\n            this.treeIndex.scroll(d);\n            break;\n          }\n\n          this.applyScroll(d, false);\n          break;\n        }\n\n      case exports.yh.ViewportResize:\n        this.emitter.emit(exports.SA.Resize, {\n          width: d.width,\n          height: d.height\n        });\n        break;\n\n      case exports.yh.Input:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          if (isSync) {\n            this.treeIndex.input(d);\n            break;\n          }\n\n          this.applyInput(d);\n          break;\n        }\n\n      case exports.yh.MediaInteraction:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var mediaEl = target;\n\n          try {\n            if (d.currentTime) {\n              mediaEl.currentTime = d.currentTime;\n            }\n\n            if (d.volume) {\n              mediaEl.volume = d.volume;\n            }\n\n            if (d.muted) {\n              mediaEl.muted = d.muted;\n            }\n\n            if (d.type === 1) {\n              mediaEl.pause();\n            }\n\n            if (d.type === 0) {\n              mediaEl.play();\n            }\n          } catch (error) {\n            if (this.config.showWarning) {\n              console.warn(\"Failed to replay media interactions: \".concat(error.message || error));\n            }\n          }\n\n          break;\n        }\n\n      case exports.yh.StyleSheetRule:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var styleEl = target;\n          var parent_2 = target.parentNode;\n          var usingVirtualParent_1 = this.fragmentParentMap.has(parent_2);\n          var styleSheet_1 = usingVirtualParent_1 ? null : styleEl.sheet;\n          var rules_1;\n\n          if (!styleSheet_1) {\n            if (this.virtualStyleRulesMap.has(target)) {\n              rules_1 = this.virtualStyleRulesMap.get(target);\n            } else {\n              rules_1 = [];\n              this.virtualStyleRulesMap.set(target, rules_1);\n            }\n          }\n\n          if (d.adds) {\n            d.adds.forEach(function (_a) {\n              var rule = _a.rule,\n                  nestedIndex = _a.index;\n\n              if (styleSheet_1) {\n                try {\n                  if (Array.isArray(nestedIndex)) {\n                    var _b = getPositionsAndIndex(nestedIndex),\n                        positions = _b.positions,\n                        index = _b.index;\n\n                    var nestedRule = getNestedRule(styleSheet_1.cssRules, positions);\n                    nestedRule.insertRule(rule, index);\n                  } else {\n                    var index = nestedIndex === undefined ? undefined : Math.min(nestedIndex, styleSheet_1.cssRules.length);\n                    styleSheet_1.insertRule(rule, index);\n                  }\n                } catch (e) {}\n              } else {\n                rules_1 === null || rules_1 === void 0 ? void 0 : rules_1.push({\n                  cssText: rule,\n                  index: nestedIndex,\n                  type: StyleRuleType.Insert\n                });\n              }\n            });\n          }\n\n          if (d.removes) {\n            d.removes.forEach(function (_a) {\n              var nestedIndex = _a.index;\n\n              if (usingVirtualParent_1) {\n                rules_1 === null || rules_1 === void 0 ? void 0 : rules_1.push({\n                  index: nestedIndex,\n                  type: StyleRuleType.Remove\n                });\n              } else {\n                try {\n                  if (Array.isArray(nestedIndex)) {\n                    var _b = getPositionsAndIndex(nestedIndex),\n                        positions = _b.positions,\n                        index = _b.index;\n\n                    var nestedRule = getNestedRule(styleSheet_1.cssRules, positions);\n                    nestedRule.deleteRule(index || 0);\n                  } else {\n                    styleSheet_1 === null || styleSheet_1 === void 0 ? void 0 : styleSheet_1.deleteRule(nestedIndex);\n                  }\n                } catch (e) {}\n              }\n            });\n          }\n\n          break;\n        }\n\n      case exports.yh.StyleDeclaration:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var styleEl = target;\n          var parent_3 = target.parentNode;\n          var usingVirtualParent = this.fragmentParentMap.has(parent_3);\n          var styleSheet = usingVirtualParent ? null : styleEl.sheet;\n          var rules = [];\n\n          if (!styleSheet) {\n            if (this.virtualStyleRulesMap.has(target)) {\n              rules = this.virtualStyleRulesMap.get(target);\n            } else {\n              rules = [];\n              this.virtualStyleRulesMap.set(target, rules);\n            }\n          }\n\n          if (d.set) {\n            if (styleSheet) {\n              var rule = getNestedRule(styleSheet.rules, d.index);\n              rule.style.setProperty(d.set.property, d.set.value, d.set.priority);\n            } else {\n              rules.push(__assign({\n                type: StyleRuleType.SetProperty,\n                index: d.index\n              }, d.set));\n            }\n          }\n\n          if (d.remove) {\n            if (styleSheet) {\n              var rule = getNestedRule(styleSheet.rules, d.index);\n              rule.style.removeProperty(d.remove.property);\n            } else {\n              rules.push(__assign({\n                type: StyleRuleType.RemoveProperty,\n                index: d.index\n              }, d.remove));\n            }\n          }\n\n          break;\n        }\n\n      case exports.yh.CanvasMutation:\n        {\n          if (!this.config.UNSAFE_replayCanvas) {\n            return;\n          }\n\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          canvasMutation({\n            event: e,\n            mutation: d,\n            target: target,\n            imageMap: this.imageMap,\n            errorHandler: this.warnCanvasMutationFailed.bind(this)\n          });\n          break;\n        }\n\n      case exports.yh.Font:\n        {\n          try {\n            var fontFace = new FontFace(d.family, d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource, d.descriptors);\n            (_b = this.iframe.contentDocument) === null || _b === void 0 ? void 0 : _b.fonts.add(fontFace);\n          } catch (error) {\n            if (this.config.showWarning) {\n              console.warn(error);\n            }\n          }\n\n          break;\n        }\n    }\n  };\n\n  Replayer.prototype.applyMutation = function (d, useVirtualParent) {\n    var e_13, _a;\n\n    var _this = this;\n\n    d.removes.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.parentId;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.virtualStyleRulesMap.has(target)) {\n        _this.virtualStyleRulesMap.delete(target);\n      }\n\n      var parent = _this.mirror.getNode(mutation.parentId);\n\n      if (!parent) {\n        return _this.warnNodeNotFound(d, mutation.parentId);\n      }\n\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n\n      _this.mirror.removeNodeFromMap(target);\n\n      if (parent) {\n        var realTarget = null;\n        var realParent = '__sn' in parent ? _this.fragmentParentMap.get(parent) : undefined;\n\n        if (realParent && realParent.contains(target)) {\n          parent = realParent;\n        } else if (_this.fragmentParentMap.has(target)) {\n          realTarget = _this.fragmentParentMap.get(target);\n\n          _this.fragmentParentMap.delete(target);\n\n          target = realTarget;\n        }\n\n        try {\n          parent.removeChild(target);\n        } catch (error) {\n          if (error instanceof DOMException) {\n            _this.warn('parent could not remove child in mutation', parent, realParent, target, realTarget, d);\n          } else {\n            throw error;\n          }\n        }\n      }\n    });\n\n    var legacy_missingNodeMap = __assign({}, this.legacy_missingNodeRetryMap);\n\n    var queue = [];\n\n    var nextNotInDOM = function (mutation) {\n      var next = null;\n\n      if (mutation.nextId) {\n        next = _this.mirror.getNode(mutation.nextId);\n      }\n\n      if (mutation.nextId !== null && mutation.nextId !== undefined && mutation.nextId !== -1 && !next) {\n        return true;\n      }\n\n      return false;\n    };\n\n    var appendNode = function (mutation) {\n      var e_14, _a;\n\n      var _b, _c;\n\n      if (!_this.iframe.contentDocument) {\n        return console.warn('Looks like your replayer has been destroyed.');\n      }\n\n      var parent = _this.mirror.getNode(mutation.parentId);\n\n      if (!parent) {\n        if (mutation.node.type === NodeType.Document) {\n          return _this.newDocumentQueue.push(mutation);\n        }\n\n        return queue.push(mutation);\n      }\n\n      var parentInDocument = null;\n\n      if (_this.iframe.contentDocument.contains) {\n        parentInDocument = _this.iframe.contentDocument.contains(parent);\n      } else if (_this.iframe.contentDocument.body.contains) {\n        parentInDocument = _this.iframe.contentDocument.body.contains(parent);\n      }\n\n      var hasIframeChild = ((_c = (_b = parent).getElementsByTagName) === null || _c === void 0 ? void 0 : _c.call(_b, 'iframe').length) > 0;\n\n      if (useVirtualParent && parentInDocument && !isIframeINode(parent) && !hasIframeChild) {\n        var virtualParent = document.createDocumentFragment();\n        _this.mirror.map[mutation.parentId] = virtualParent;\n\n        _this.fragmentParentMap.set(virtualParent, parent);\n\n        _this.storeState(parent);\n\n        while (parent.firstChild) {\n          virtualParent.appendChild(parent.firstChild);\n        }\n\n        parent = virtualParent;\n      }\n\n      if (mutation.node.isShadow) {\n        if (!hasShadowRoot(parent)) {\n          parent.attachShadow({\n            mode: 'open'\n          });\n          parent = parent.shadowRoot;\n        } else parent = parent.shadowRoot;\n      }\n\n      var previous = null;\n      var next = null;\n\n      if (mutation.previousId) {\n        previous = _this.mirror.getNode(mutation.previousId);\n      }\n\n      if (mutation.nextId) {\n        next = _this.mirror.getNode(mutation.nextId);\n      }\n\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n\n      if (mutation.node.rootId && !_this.mirror.getNode(mutation.node.rootId)) {\n        return;\n      }\n\n      var targetDoc = mutation.node.rootId ? _this.mirror.getNode(mutation.node.rootId) : _this.iframe.contentDocument;\n\n      if (isIframeINode(parent)) {\n        _this.attachDocumentToIframe(mutation, parent);\n\n        return;\n      }\n\n      var target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc,\n        map: _this.mirror.map,\n        skipChild: true,\n        hackCss: true,\n        cache: _this.cache\n      });\n\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation: mutation\n        };\n        return;\n      }\n\n      if ('__sn' in parent && parent.__sn.type === NodeType.Element && parent.__sn.tagName === 'textarea' && mutation.node.type === NodeType.Text) {\n        try {\n          for (var _d = __values(Array.from(parent.childNodes)), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var c = _e.value;\n\n            if (c.nodeType === parent.TEXT_NODE) {\n              parent.removeChild(c);\n            }\n          }\n        } catch (e_14_1) {\n          e_14 = {\n            error: e_14_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n          } finally {\n            if (e_14) throw e_14.error;\n          }\n        }\n      }\n\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(target, previous.nextSibling);\n      } else if (next && next.parentNode) {\n        parent.contains(next) ? parent.insertBefore(target, next) : parent.insertBefore(target, null);\n      } else {\n        if (parent === targetDoc) {\n          while (targetDoc.firstChild) {\n            targetDoc.removeChild(targetDoc.firstChild);\n          }\n        }\n\n        parent.appendChild(target);\n      }\n\n      if (isIframeINode(target)) {\n        var mutationInQueue_1 = _this.newDocumentQueue.find(function (m) {\n          return m.parentId === target.__sn.id;\n        });\n\n        if (mutationInQueue_1) {\n          _this.attachDocumentToIframe(mutationInQueue_1, target);\n\n          _this.newDocumentQueue = _this.newDocumentQueue.filter(function (m) {\n            return m !== mutationInQueue_1;\n          });\n        }\n\n        if (target.contentDocument) {\n          var _f = target.contentDocument,\n              documentElement = _f.documentElement,\n              head = _f.head;\n\n          _this.insertStyleRules(documentElement, head);\n        }\n      }\n\n      if (mutation.previousId || mutation.nextId) {\n        _this.legacy_resolveMissingNode(legacy_missingNodeMap, parent, target, mutation);\n      }\n    };\n\n    d.adds.forEach(function (mutation) {\n      appendNode(mutation);\n    });\n    var passed = [];\n\n    for (var index = 0; index < this.misssedQueueNodeTrees.length; index++) {\n      var tree = this.misssedQueueNodeTrees[index];\n      var parent_4 = this.mirror.getNode(tree.value.parentId);\n\n      if (parent_4) {\n        iterateResolveTree(tree, function (mutation) {\n          appendNode(mutation);\n        });\n        passed.push(index);\n      } else {\n        console.warn('adds parent in missed queue: ', tree.value.parentId);\n      }\n    }\n\n    for (var index = 0; index < passed.length; index++) {\n      this.misssedQueueNodeTrees.splice(passed[index], 1);\n    }\n\n    var startTime = Date.now();\n\n    while (queue.length) {\n      var resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n\n      if (Date.now() - startTime > 500) {\n        this.warn('Timeout in the loop, please check the resolve tree data:', resolveTrees);\n        break;\n      }\n\n      try {\n        for (var resolveTrees_1 = (e_13 = void 0, __values(resolveTrees)), resolveTrees_1_1 = resolveTrees_1.next(); !resolveTrees_1_1.done; resolveTrees_1_1 = resolveTrees_1.next()) {\n          var tree = resolveTrees_1_1.value;\n          var parent_5 = this.mirror.getNode(tree.value.parentId);\n\n          if (!parent_5) {\n            this.misssedQueueNodeTrees.push(tree);\n            this.debug('Drop resolve tree since there is no parent for the root node.', tree);\n          } else {\n            iterateResolveTree(tree, function (mutation) {\n              appendNode(mutation);\n            });\n          }\n        }\n      } catch (e_13_1) {\n        e_13 = {\n          error: e_13_1\n        };\n      } finally {\n        try {\n          if (resolveTrees_1_1 && !resolveTrees_1_1.done && (_a = resolveTrees_1.return)) _a.call(resolveTrees_1);\n        } finally {\n          if (e_13) throw e_13.error;\n        }\n      }\n    }\n\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n\n    d.texts.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.id;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.fragmentParentMap.has(target)) {\n        target = _this.fragmentParentMap.get(target);\n      }\n\n      target.textContent = mutation.value;\n    });\n    d.attributes.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.id;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.fragmentParentMap.has(target)) {\n        target = _this.fragmentParentMap.get(target);\n      }\n\n      for (var attributeName in mutation.attributes) {\n        if (typeof attributeName === 'string') {\n          var value = mutation.attributes[attributeName];\n\n          if (value === null) {\n            target.removeAttribute(attributeName);\n          } else if (typeof value === 'string') {\n            try {\n              target.setAttribute(attributeName, value);\n            } catch (error) {\n              if (_this.config.showWarning) {\n                console.warn('An error occurred may due to the checkout feature.', error);\n              }\n            }\n          } else if (attributeName === 'style') {\n            var styleValues = value;\n            var targetEl = target;\n\n            for (var s in styleValues) {\n              if (styleValues[s] === false) {\n                targetEl.style.removeProperty(s);\n              } else if (styleValues[s] instanceof Array) {\n                var svp = styleValues[s];\n                targetEl.style.setProperty(s, svp[0], svp[1]);\n              } else {\n                var svs = styleValues[s];\n                targetEl.style.setProperty(s, svs);\n              }\n            }\n          }\n        }\n      }\n    });\n  };\n\n  Replayer.prototype.applyScroll = function (d, isSync) {\n    var target = this.mirror.getNode(d.id);\n\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n\n    if (target === this.iframe.contentDocument) {\n      this.iframe.contentWindow.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? 'auto' : 'smooth'\n      });\n    } else if (target.__sn.type === NodeType.Document) {\n      target.defaultView.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? 'auto' : 'smooth'\n      });\n    } else {\n      try {\n        target.scrollTop = d.y;\n        target.scrollLeft = d.x;\n      } catch (error) {}\n    }\n  };\n\n  Replayer.prototype.applyInput = function (d) {\n    var target = this.mirror.getNode(d.id);\n\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n\n    try {\n      target.checked = d.isChecked;\n      target.value = d.text;\n    } catch (error) {}\n  };\n\n  Replayer.prototype.legacy_resolveMissingNode = function (map, parent, target, targetMutation) {\n    var previousId = targetMutation.previousId,\n        nextId = targetMutation.nextId;\n    var previousInMap = previousId && map[previousId];\n    var nextInMap = nextId && map[nextId];\n\n    if (previousInMap) {\n      var _a = previousInMap,\n          node = _a.node,\n          mutation = _a.mutation;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n\n    if (nextInMap) {\n      var _b = nextInMap,\n          node = _b.node,\n          mutation = _b.mutation;\n      parent.insertBefore(node, target.nextSibling);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n  };\n\n  Replayer.prototype.moveAndHover = function (x, y, id, isSync, debugData) {\n    var target = this.mirror.getNode(id);\n\n    if (!target) {\n      return this.debugNodeNotFound(debugData, id);\n    }\n\n    var base = getBaseDimension(target, this.iframe);\n\n    var _x = x * base.absoluteScale + base.x;\n\n    var _y = y * base.absoluteScale + base.y;\n\n    this.mouse.style.left = \"\".concat(_x, \"px\");\n    this.mouse.style.top = \"\".concat(_y, \"px\");\n\n    if (!isSync) {\n      this.drawMouseTail({\n        x: _x,\n        y: _y\n      });\n    }\n\n    this.hoverElements(target);\n  };\n\n  Replayer.prototype.drawMouseTail = function (position) {\n    var _this = this;\n\n    if (!this.mouseTail) {\n      return;\n    }\n\n    var _a = this.config.mouseTail === true ? defaultMouseTailConfig : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail),\n        lineCap = _a.lineCap,\n        lineWidth = _a.lineWidth,\n        strokeStyle = _a.strokeStyle,\n        duration = _a.duration;\n\n    var draw = function () {\n      if (!_this.mouseTail) {\n        return;\n      }\n\n      var ctx = _this.mouseTail.getContext('2d');\n\n      if (!ctx || !_this.tailPositions.length) {\n        return;\n      }\n\n      ctx.clearRect(0, 0, _this.mouseTail.width, _this.mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(_this.tailPositions[0].x, _this.tailPositions[0].y);\n\n      _this.tailPositions.forEach(function (p) {\n        return ctx.lineTo(p.x, p.y);\n      });\n\n      ctx.stroke();\n    };\n\n    this.tailPositions.push(position);\n    draw();\n    setTimeout(function () {\n      _this.tailPositions = _this.tailPositions.filter(function (p) {\n        return p !== position;\n      });\n      draw();\n    }, duration / this.speedService.state.context.timer.speed);\n  };\n\n  Replayer.prototype.hoverElements = function (el) {\n    var _a;\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.\\\\:hover').forEach(function (hoveredEl) {\n      hoveredEl.classList.remove(':hover');\n    });\n    var currentEl = el;\n\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(':hover');\n      }\n\n      currentEl = currentEl.parentElement;\n    }\n  };\n\n  Replayer.prototype.isUserInteraction = function (event) {\n    if (event.type !== exports.tw.IncrementalSnapshot) {\n      return false;\n    }\n\n    return event.data.source > exports.yh.Mutation && event.data.source <= exports.yh.Input;\n  };\n\n  Replayer.prototype.backToNormal = function () {\n    this.nextUserInteractionEvent = null;\n\n    if (this.speedService.state.matches('normal')) {\n      return;\n    }\n\n    this.speedService.send({\n      type: 'BACK_TO_NORMAL'\n    });\n    this.emitter.emit(exports.SA.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed\n    });\n  };\n\n  Replayer.prototype.restoreRealParent = function (frag, parent) {\n    this.mirror.map[parent.__sn.id] = parent;\n\n    if (parent.__sn.type === NodeType.Element && parent.__sn.tagName === 'textarea' && frag.textContent) {\n      parent.value = frag.textContent;\n    }\n\n    parent.appendChild(frag);\n    this.restoreState(parent);\n  };\n\n  Replayer.prototype.storeState = function (parent) {\n    var e_15, _a;\n\n    if (parent) {\n      if (parent.nodeType === parent.ELEMENT_NODE) {\n        var parentElement = parent;\n\n        if (parentElement.scrollLeft || parentElement.scrollTop) {\n          this.elementStateMap.set(parent, {\n            scroll: [parentElement.scrollLeft, parentElement.scrollTop]\n          });\n        }\n\n        if (parentElement.tagName === 'STYLE') storeCSSRules(parentElement, this.virtualStyleRulesMap);\n        var children = parentElement.children;\n\n        try {\n          for (var _b = __values(Array.from(children)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var child = _c.value;\n            this.storeState(child);\n          }\n        } catch (e_15_1) {\n          e_15 = {\n            error: e_15_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_15) throw e_15.error;\n          }\n        }\n      }\n    }\n  };\n\n  Replayer.prototype.restoreState = function (parent) {\n    var e_16, _a;\n\n    if (parent.nodeType === parent.ELEMENT_NODE) {\n      var parentElement = parent;\n\n      if (this.elementStateMap.has(parent)) {\n        var storedState = this.elementStateMap.get(parent);\n\n        if (storedState.scroll) {\n          parentElement.scrollLeft = storedState.scroll[0];\n          parentElement.scrollTop = storedState.scroll[1];\n        }\n\n        this.elementStateMap.delete(parent);\n      }\n\n      var children = parentElement.children;\n\n      try {\n        for (var _b = __values(Array.from(children)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          this.restoreState(child);\n        }\n      } catch (e_16_1) {\n        e_16 = {\n          error: e_16_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_16) throw e_16.error;\n        }\n      }\n    }\n  };\n\n  Replayer.prototype.restoreNodeSheet = function (node) {\n    var storedRules = this.virtualStyleRulesMap.get(node);\n\n    if (node.nodeName !== 'STYLE') {\n      return;\n    }\n\n    if (!storedRules) {\n      return;\n    }\n\n    var styleNode = node;\n    applyVirtualStyleRulesToNode(storedRules, styleNode);\n  };\n\n  Replayer.prototype.warnNodeNotFound = function (d, id) {\n    if (this.treeIndex.idRemoved(id)) {\n      this.warn(\"Node with id '\".concat(id, \"' was previously removed. \"), d);\n    } else {\n      this.warn(\"Node with id '\".concat(id, \"' not found. \"), d);\n    }\n  };\n\n  Replayer.prototype.warnCanvasMutationFailed = function (d, error) {\n    this.warn(\"Has error on canvas update\", error, 'canvas mutation:', d);\n  };\n\n  Replayer.prototype.debugNodeNotFound = function (d, id) {\n    if (this.treeIndex.idRemoved(id)) {\n      this.debug(REPLAY_CONSOLE_PREFIX, \"Node with id '\".concat(id, \"' was previously removed. \"), d);\n    } else {\n      this.debug(REPLAY_CONSOLE_PREFIX, \"Node with id '\".concat(id, \"' not found. \"), d);\n    }\n  };\n\n  Replayer.prototype.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!this.config.showWarning) {\n      return;\n    }\n\n    console.warn.apply(console, __spreadArray([REPLAY_CONSOLE_PREFIX], __read(args), false));\n  };\n\n  Replayer.prototype.debug = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!this.config.showDebug) {\n      return;\n    }\n\n    console.log.apply(console, __spreadArray([REPLAY_CONSOLE_PREFIX], __read(args), false));\n  };\n\n  return Replayer;\n}();\n\nvar addCustomEvent = record.addCustomEvent;\nvar freezePage = record.freezePage; // DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// aliases for shorter compressed code (most minifers don't do this)\n\nvar u8 = Uint8Array,\n    u16 = Uint16Array,\n    u32 = Uint32Array; // fixed length extra bits\n\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n/* unused */\n0, 0,\n/* impossible */\n0]); // fixed distance extra bits\n// see fleb note\n\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,\n/* unused */\n0, 0]); // code length index map\n\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // get base, reverse index map from extra bits\n\nvar freb = function (eb, start) {\n  var b = new u16(31);\n\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  } // numbers here are at max 18 bits\n\n\n  var r = new u32(b[30]);\n\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n\n  return [b, r];\n};\n\nvar _a = freb(fleb, 2),\n    fl = _a[0],\n    revfl = _a[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway\n\n\nfl[28] = 258, revfl[258] = 28;\n\nvar _b = freb(fdeb, 0),\n    fd = _b[0],\n    revfd = _b[1]; // map of value to reverse (assuming 16 bits)\n\n\nvar rev = new u16(32768);\n\nfor (var i = 0; i < 32768; ++i) {\n  // reverse table algorithm from SO\n  var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n  x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n  x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n  rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n} // create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\n\n\nvar hMap = function (cd, mb, r) {\n  var s = cd.length; // index\n\n  var i = 0; // u16 \"map\": index -> # of codes with bit length = index\n\n  var l = new u16(mb); // length of cd must be 288 (total # of codes)\n\n  for (; i < s; ++i) ++l[cd[i] - 1]; // u16 \"map\": index -> minimum code for bit length = index\n\n\n  var le = new u16(mb);\n\n  for (i = 0; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n\n  var co;\n\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new u16(1 << mb); // bits to remove for reverser\n\n    var rvb = 15 - mb;\n\n    for (i = 0; i < s; ++i) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        var sv = i << 4 | cd[i]; // free bits\n\n        var r_1 = mb - cd[i]; // start value\n\n        var v = le[cd[i] - 1]++ << r_1; // m is end value\n\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[v] >>> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n\n    for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n  }\n\n  return co;\n}; // fixed length tree\n\n\nvar flt = new u8(288);\n\nfor (var i = 0; i < 144; ++i) flt[i] = 8;\n\nfor (var i = 144; i < 256; ++i) flt[i] = 9;\n\nfor (var i = 256; i < 280; ++i) flt[i] = 7;\n\nfor (var i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree\n\n\nvar fdt = new u8(32);\n\nfor (var i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map\n\n\nvar flm = /*#__PURE__*/hMap(flt, 9, 0),\n    flrm = /*#__PURE__*/hMap(flt, 9, 1); // fixed distance map\n\nvar fdm = /*#__PURE__*/hMap(fdt, 5, 0),\n    fdrm = /*#__PURE__*/hMap(fdt, 5, 1); // find max of array\n\nvar max = function (a) {\n  var m = a[0];\n\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m) m = a[i];\n  }\n\n  return m;\n}; // read d, starting at bit p and mask with m\n\n\nvar bits = function (d, p, m) {\n  var o = p / 8 >> 0;\n  return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;\n}; // read d, starting at bit p continuing for at least 16 bits\n\n\nvar bits16 = function (d, p) {\n  var o = p / 8 >> 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);\n}; // get end of byte\n\n\nvar shft = function (p) {\n  return (p / 8 >> 0) + (p & 7 && 1);\n}; // typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\n\n\nvar slc = function (v, s, e) {\n  if (s == null || s < 0) s = 0;\n  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied\n\n  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n}; // expands raw DEFLATE data\n\n\nvar inflt = function (dat, buf, st) {\n  // source length\n  var sl = dat.length; // have to estimate size\n\n  var noBuf = !buf || st; // no state\n\n  var noSt = !st || st.i;\n  if (!st) st = {}; // Assumes roughly 33% compression ratio average\n\n  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements\n\n  var cbuf = function (l) {\n    var bl = buf.length; // need to increase size to fit\n\n    if (l > bl) {\n      // Double or set to necessary, whichever is greater\n      var nbuf = new u8(Math.max(bl * 2, l));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  }; //  last chunk         bitpos           bytes\n\n\n  var final = st.f || 0,\n      pos = st.p || 0,\n      bt = st.b || 0,\n      lm = st.l,\n      dm = st.d,\n      lbt = st.m,\n      dbt = st.n; // total bits\n\n  var tbts = sl * 8;\n\n  do {\n    if (!lm) {\n      // BFINAL - this is only 1 when last chunk is next\n      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n\n      if (!type) {\n        // go to end of byte boundary\n        var s = shft(pos) + 4,\n            l = dat[s - 4] | dat[s - 3] << 8,\n            t = s + l;\n\n        if (t > sl) {\n          if (noSt) throw 'unexpected EOF';\n          break;\n        } // ensure size\n\n\n        if (noBuf) cbuf(bt + l); // Copy over uncompressed data\n\n        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count\n\n        st.b = bt += l, st.p = pos = t * 8;\n        continue;\n      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {\n        //  literal                            lengths\n        var hLit = bits(dat, pos, 31) + 257,\n            hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14; // length+distance tree\n\n        var ldt = new u8(tl); // code length tree\n\n        var clt = new u8(19);\n\n        for (var i = 0; i < hcLen; ++i) {\n          // use index map to get real code\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n\n        pos += hcLen * 3; // code lengths bits\n\n        var clb = max(clt),\n            clbmsk = (1 << clb) - 1;\n        if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map\n\n        var clm = hMap(clt, clb, 1);\n\n        for (var i = 0; i < tl;) {\n          var r = clm[bits(dat, pos, clbmsk)]; // bits read\n\n          pos += r & 15; // symbol\n\n          var s = r >>> 4; // code length to copy\n\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            //  copy   count\n            var c = 0,\n                n = 0;\n            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n\n            while (n--) ldt[i++] = c;\n          }\n        } //    length tree                 distance tree\n\n\n        var lt = ldt.subarray(0, hLit),\n            dt = ldt.subarray(hLit); // max length bits\n\n        lbt = max(lt); // max dist bits\n\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else throw 'invalid block type';\n\n      if (pos > tbts) throw 'unexpected EOF';\n    } // Make sure the buffer can hold this + the largest possible addition\n    // Maximum chunk size (practically, theoretically infinite) is 2^17;\n\n\n    if (noBuf) cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1,\n        dms = (1 << dbt) - 1;\n    var mxa = lbt + dbt + 18;\n\n    while (noSt || pos + mxa < tbts) {\n      // bits read, code\n      var c = lm[bits16(dat, pos) & lms],\n          sym = c >>> 4;\n      pos += c & 15;\n      if (pos > tbts) throw 'unexpected EOF';\n      if (!c) throw 'invalid length/literal';\n      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {\n        lm = null;\n        break;\n      } else {\n        var add = sym - 254; // no extra bits needed if less\n\n        if (sym > 264) {\n          // index\n          var i = sym - 257,\n              b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        } // dist\n\n\n        var d = dm[bits16(dat, pos) & dms],\n            dsym = d >>> 4;\n        if (!d) throw 'invalid distance';\n        pos += d & 15;\n        var dt = fd[dsym];\n\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n\n        if (pos > tbts) throw 'unexpected EOF';\n        if (noBuf) cbuf(bt + 131072);\n        var end = bt + add;\n\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n\n        bt = end;\n      }\n    }\n\n    st.l = lm, st.p = pos, st.b = bt;\n    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n}; // starting at p, write the minimum number of bits that can hold v to d\n\n\nvar wbits = function (d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 >> 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n}; // starting at p, write the minimum number of bits (>8) that can hold v to d\n\n\nvar wbits16 = function (d, p, v) {\n  v <<= p & 7;\n  var o = p / 8 >> 0;\n  d[o] |= v;\n  d[o + 1] |= v >>> 8;\n  d[o + 2] |= v >>> 16;\n}; // creates code lengths from a frequency table\n\n\nvar hTree = function (d, mb) {\n  // Need extra info to make a tree\n  var t = [];\n\n  for (var i = 0; i < d.length; ++i) {\n    if (d[i]) t.push({\n      s: i,\n      f: d[i]\n    });\n  }\n\n  var s = t.length;\n  var t2 = t.slice();\n  if (!s) return [new u8(0), 0];\n\n  if (s == 1) {\n    var v = new u8(t[0].s + 1);\n    v[t[0].s] = 1;\n    return [v, 1];\n  }\n\n  t.sort(function (a, b) {\n    return a.f - b.f;\n  }); // after i2 reaches last ind, will be stopped\n  // freq must be greater than largest possible number of symbols\n\n  t.push({\n    s: -1,\n    f: 25001\n  });\n  var l = t[0],\n      r = t[1],\n      i0 = 0,\n      i1 = 1,\n      i2 = 2;\n  t[0] = {\n    s: -1,\n    f: l.f + r.f,\n    l: l,\n    r: r\n  }; // efficient algorithm from UZIP.js\n  // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n  // symbols that combined have high freq, will start processing i2 (high-freq,\n  // non-composite) symbols instead\n  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n\n  while (i1 != s - 1) {\n    l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n    t[i1++] = {\n      s: -1,\n      f: l.f + r.f,\n      l: l,\n      r: r\n    };\n  }\n\n  var maxSym = t2[0].s;\n\n  for (var i = 1; i < s; ++i) {\n    if (t2[i].s > maxSym) maxSym = t2[i].s;\n  } // code lengths\n\n\n  var tr = new u16(maxSym + 1); // max bits in tree\n\n  var mbt = ln(t[i1 - 1], tr, 0);\n\n  if (mbt > mb) {\n    // more algorithms from UZIP.js\n    // TODO: find out how this code works (debt)\n    //  ind    debt\n    var i = 0,\n        dt = 0; //    left            cost\n\n    var lft = mbt - mb,\n        cst = 1 << lft;\n    t2.sort(function (a, b) {\n      return tr[b.s] - tr[a.s] || a.f - b.f;\n    });\n\n    for (; i < s; ++i) {\n      var i2_1 = t2[i].s;\n\n      if (tr[i2_1] > mb) {\n        dt += cst - (1 << mbt - tr[i2_1]);\n        tr[i2_1] = mb;\n      } else break;\n    }\n\n    dt >>>= lft;\n\n    while (dt > 0) {\n      var i2_2 = t2[i].s;\n      if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;\n    }\n\n    for (; i >= 0 && dt; --i) {\n      var i2_3 = t2[i].s;\n\n      if (tr[i2_3] == mb) {\n        --tr[i2_3];\n        ++dt;\n      }\n    }\n\n    mbt = mb;\n  }\n\n  return [new u8(tr), mbt];\n}; // get the max length and assign length codes\n\n\nvar ln = function (n, l, d) {\n  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n}; // length codes generation\n\n\nvar lc = function (c) {\n  var s = c.length; // Note that the semicolon was intentional\n\n  while (s && !c[--s]);\n\n  var cl = new u16(++s); //  ind      num         streak\n\n  var cli = 0,\n      cln = c[0],\n      cls = 1;\n\n  var w = function (v) {\n    cl[cli++] = v;\n  };\n\n  for (var i = 1; i <= s; ++i) {\n    if (c[i] == cln && i != s) ++cls;else {\n      if (!cln && cls > 2) {\n        for (; cls > 138; cls -= 138) w(32754);\n\n        if (cls > 2) {\n          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n          cls = 0;\n        }\n      } else if (cls > 3) {\n        w(cln), --cls;\n\n        for (; cls > 6; cls -= 6) w(8304);\n\n        if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n      }\n\n      while (cls--) w(cln);\n\n      cls = 1;\n      cln = c[i];\n    }\n  }\n\n  return [cl.subarray(0, cli), s];\n}; // calculate the length of output from tree, code lengths\n\n\nvar clen = function (cf, cl) {\n  var l = 0;\n\n  for (var i = 0; i < cl.length; ++i) l += cf[i] * cl[i];\n\n  return l;\n}; // writes a fixed block\n// returns the new bit pos\n\n\nvar wfblk = function (out, pos, dat) {\n  // no need to write 00 as type: TypedArray defaults to 0\n  var s = dat.length;\n  var o = shft(pos + 2);\n  out[o] = s & 255;\n  out[o + 1] = s >>> 8;\n  out[o + 2] = out[o] ^ 255;\n  out[o + 3] = out[o + 1] ^ 255;\n\n  for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];\n\n  return (o + 4 + s) * 8;\n}; // writes a block\n\n\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n  wbits(out, p++, final);\n  ++lf[256];\n\n  var _a = hTree(lf, 15),\n      dlt = _a[0],\n      mlb = _a[1];\n\n  var _b = hTree(df, 15),\n      ddt = _b[0],\n      mdb = _b[1];\n\n  var _c = lc(dlt),\n      lclt = _c[0],\n      nlc = _c[1];\n\n  var _d = lc(ddt),\n      lcdt = _d[0],\n      ndc = _d[1];\n\n  var lcfreq = new u16(19);\n\n  for (var i = 0; i < lclt.length; ++i) lcfreq[lclt[i] & 31]++;\n\n  for (var i = 0; i < lcdt.length; ++i) lcfreq[lcdt[i] & 31]++;\n\n  var _e = hTree(lcfreq, 7),\n      lct = _e[0],\n      mlcb = _e[1];\n\n  var nlcc = 19;\n\n  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n\n  var flen = bl + 5 << 3;\n  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n  var lm, ll, dm, dl;\n  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n\n  if (dtlen < ftlen) {\n    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n    var llm = hMap(lct, mlcb, 0);\n    wbits(out, p, nlc - 257);\n    wbits(out, p + 5, ndc - 1);\n    wbits(out, p + 10, nlcc - 4);\n    p += 14;\n\n    for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);\n\n    p += 3 * nlcc;\n    var lcts = [lclt, lcdt];\n\n    for (var it = 0; it < 2; ++it) {\n      var clct = lcts[it];\n\n      for (var i = 0; i < clct.length; ++i) {\n        var len = clct[i] & 31;\n        wbits(out, p, llm[len]), p += lct[len];\n        if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n      }\n    }\n  } else {\n    lm = flm, ll = flt, dm = fdm, dl = fdt;\n  }\n\n  for (var i = 0; i < li; ++i) {\n    if (syms[i] > 255) {\n      var len = syms[i] >>> 18 & 31;\n      wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n      if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n      var dst = syms[i] & 31;\n      wbits16(out, p, dm[dst]), p += dl[dst];\n      if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n    } else {\n      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n    }\n  }\n\n  wbits16(out, p, lm[256]);\n  return p + ll[256];\n}; // deflate options (nice << 13) | chain\n\n\nvar deo = /*#__PURE__*/new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]); // empty\n\nvar et = /*#__PURE__*/new u8(0); // compresses data into a raw DEFLATE buffer\n\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n  var s = dat.length;\n  var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post); // writing to this writes to the output buffer\n\n  var w = o.subarray(pre, o.length - post);\n  var pos = 0;\n\n  if (!lvl || s < 8) {\n    for (var i = 0; i <= s; i += 65535) {\n      // end\n      var e = i + 65535;\n\n      if (e < s) {\n        // write full block\n        pos = wfblk(w, pos, dat.subarray(i, e));\n      } else {\n        // write final block\n        w[i] = lst;\n        pos = wfblk(w, pos, dat.subarray(i, s));\n      }\n    }\n  } else {\n    var opt = deo[lvl - 1];\n    var n = opt >>> 13,\n        c = opt & 8191;\n    var msk_1 = (1 << plvl) - 1; //    prev 2-byte val map    curr 2-byte val map\n\n    var prev = new u16(32768),\n        head = new u16(msk_1 + 1);\n    var bs1_1 = Math.ceil(plvl / 3),\n        bs2_1 = 2 * bs1_1;\n\n    var hsh = function (i) {\n      return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n    }; // 24576 is an arbitrary number of maximum symbols per block\n    // 424 buffer for last block\n\n\n    var syms = new u32(25000); // length/literal freq   distance freq\n\n    var lf = new u16(288),\n        df = new u16(32); //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n\n    var lc_1 = 0,\n        eb = 0,\n        i = 0,\n        li = 0,\n        wi = 0,\n        bs = 0;\n\n    for (; i < s; ++i) {\n      // hash value\n      var hv = hsh(i); // index mod 32768\n\n      var imod = i & 32767; // previous index with this value\n\n      var pimod = head[hv];\n      prev[imod] = pimod;\n      head[hv] = imod; // We always should modify head and prev, but only add symbols if\n      // this data is not yet processed (\"wait\" for wait index)\n\n      if (wi <= i) {\n        // bytes remaining\n        var rem = s - i;\n\n        if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n          li = lc_1 = eb = 0, bs = i;\n\n          for (var j = 0; j < 286; ++j) lf[j] = 0;\n\n          for (var j = 0; j < 30; ++j) df[j] = 0;\n        } //  len    dist   chain\n\n\n        var l = 2,\n            d = 0,\n            ch_1 = c,\n            dif = imod - pimod & 32767;\n\n        if (rem > 2 && hv == hsh(i - dif)) {\n          var maxn = Math.min(n, rem) - 1;\n          var maxd = Math.min(32767, i); // max possible length\n          // not capped at dif because decompressors implement \"rolling\" index population\n\n          var ml = Math.min(258, rem);\n\n          while (dif <= maxd && --ch_1 && imod != pimod) {\n            if (dat[i + l] == dat[i + l - dif]) {\n              var nl = 0;\n\n              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n\n              if (nl > l) {\n                l = nl, d = dif; // break out early when we reach \"nice\" (we are satisfied enough)\n\n                if (nl > maxn) break; // now, find the rarest 2-byte sequence within this\n                // length of literals and search for that instead.\n                // Much faster than just using the start\n\n                var mmd = Math.min(dif, nl - 2);\n                var md = 0;\n\n                for (var j = 0; j < mmd; ++j) {\n                  var ti = i - dif + j + 32768 & 32767;\n                  var pti = prev[ti];\n                  var cd = ti - pti + 32768 & 32767;\n                  if (cd > md) md = cd, pimod = ti;\n                }\n              }\n            } // check the previous match\n\n\n            imod = pimod, pimod = prev[imod];\n            dif += imod - pimod + 32768 & 32767;\n          }\n        } // d will be nonzero only when a match was found\n\n\n        if (d) {\n          // store both dist and len data in one Uint32\n          // Make sure this is recognized as a len/dist with 28th bit (2^28)\n          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n          var lin = revfl[l] & 31,\n              din = revfd[d] & 31;\n          eb += fleb[lin] + fdeb[din];\n          ++lf[257 + lin];\n          ++df[din];\n          wi = i + l;\n          ++lc_1;\n        } else {\n          syms[li++] = dat[i];\n          ++lf[dat[i]];\n        }\n      }\n    }\n\n    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos); // this is the easiest way to avoid needing to maintain state\n\n    if (!lst) pos = wfblk(w, pos, et);\n  }\n\n  return slc(o, 0, pre + shft(pos) + post);\n}; // Alder32\n\n\nvar adler = function () {\n  var a = 1,\n      b = 0;\n  return {\n    p: function (d) {\n      // closures have awful performance\n      var n = a,\n          m = b;\n      var l = d.length;\n\n      for (var i = 0; i != l;) {\n        var e = Math.min(i + 5552, l);\n\n        for (; i < e; ++i) n += d[i], m += n;\n\n        n %= 65521, m %= 65521;\n      }\n\n      a = n, b = m;\n    },\n    d: function () {\n      return (a >>> 8 << 16 | (b & 255) << 8 | b >>> 8) + ((a & 255) << 23) * 2;\n    }\n  };\n}; // deflate with opts\n\n\nvar dopt = function (dat, opt, pre, post, st) {\n  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n}; // write bytes\n\n\nvar wbytes = function (d, b, v) {\n  for (; v; ++b) d[b] = v, v >>>= 8;\n}; // zlib header\n\n\nvar zlh = function (c, o) {\n  var lv = o.level,\n      fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n  c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n}; // zlib valid\n\n\nvar zlv = function (d) {\n  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';\n  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';\n};\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\n\n\nfunction zlibSync(data, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var a = adler();\n  a.p(data);\n  var d = dopt(data, opts, 2, 4);\n  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\n\n\nfunction unzlibSync(data, out) {\n  return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\n\n\nfunction strToU8(str, latin1) {\n  var l = str.length;\n  if (!latin1 && typeof TextEncoder != 'undefined') return new TextEncoder().encode(str);\n  var ar = new u8(str.length + (str.length >>> 1));\n  var ai = 0;\n\n  var w = function (v) {\n    ar[ai++] = v;\n  };\n\n  for (var i = 0; i < l; ++i) {\n    if (ai + 5 > ar.length) {\n      var n = new u8(ai + 8 + (l - i << 1));\n      n.set(ar);\n      ar = n;\n    }\n\n    var c = str.charCodeAt(i);\n    if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >>> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >>> 18), w(128 | c >>> 12 & 63), w(128 | c >>> 6 & 63), w(128 | c & 63);else w(224 | c >>> 12), w(128 | c >>> 6 & 63), w(128 | c & 63);\n  }\n\n  return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\n\n\nfunction strFromU8(dat, latin1) {\n  var r = '';\n  if (!latin1 && typeof TextDecoder != 'undefined') return new TextDecoder().decode(dat);\n\n  for (var i = 0; i < dat.length;) {\n    var c = dat[i++];\n    if (c < 128 || latin1) r += String.fromCharCode(c);else if (c < 224) r += String.fromCharCode((c & 31) << 6 | dat[i++] & 63);else if (c < 240) r += String.fromCharCode((c & 15) << 12 | (dat[i++] & 63) << 6 | dat[i++] & 63);else c = ((c & 15) << 18 | (dat[i++] & 63) << 12 | (dat[i++] & 63) << 6 | dat[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n  }\n\n  return r;\n}\n\nvar MARK = 'v1';\n\nvar pack = function (event) {\n  var _e = __assign(__assign({}, event), {\n    v: MARK\n  });\n\n  return strFromU8(zlibSync(strToU8(JSON.stringify(_e))), true);\n};\n\nvar unpack = function (raw) {\n  if (typeof raw !== 'string') {\n    return raw;\n  }\n\n  try {\n    var e = JSON.parse(raw);\n\n    if (e.timestamp) {\n      return e;\n    }\n  } catch (error) {}\n\n  try {\n    var e = JSON.parse(strFromU8(unzlibSync(strToU8(raw, true))));\n\n    if (e.v === MARK) {\n      return e;\n    }\n\n    throw new Error(\"These events were packed with packer \".concat(e.v, \" which is incompatible with current packer \").concat(MARK, \".\"));\n  } catch (error) {\n    console.error(error);\n    throw new Error('Unknown data format.');\n  }\n};\n\nvar StackFrame = function () {\n  function StackFrame(obj) {\n    this.fileName = obj.fileName || '';\n    this.functionName = obj.functionName || '';\n    this.lineNumber = obj.lineNumber;\n    this.columnNumber = obj.columnNumber;\n  }\n\n  StackFrame.prototype.toString = function () {\n    var lineNumber = this.lineNumber || '';\n    var columnNumber = this.columnNumber || '';\n\n    if (this.functionName) {\n      return this.functionName + ' (' + this.fileName + ':' + lineNumber + ':' + columnNumber + ')';\n    }\n\n    return this.fileName + ':' + lineNumber + ':' + columnNumber;\n  };\n\n  return StackFrame;\n}();\n\nvar FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\nvar CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nvar SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\nvar ErrorStackParser = {\n  parse: function (error) {\n    if (!error) {\n      return [];\n    }\n\n    if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n      return this.parseOpera(error);\n    } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n      return this.parseV8OrIE(error);\n    } else if (error.stack) {\n      return this.parseFFOrSafari(error);\n    } else {\n      throw new Error('Cannot parse given Error object');\n    }\n  },\n  extractLocation: function (urlLike) {\n    if (urlLike.indexOf(':') === -1) {\n      return [urlLike];\n    }\n\n    var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n    var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n    if (!parts) throw new Error(\"Cannot parse given url: \".concat(urlLike));\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n  },\n  parseV8OrIE: function (error) {\n    var filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n    return filtered.map(function (line) {\n      if (line.indexOf('(eval ') > -1) {\n        line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n      }\n\n      var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n      var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n      sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n      var tokens = sanitizedLine.split(/\\s+/).slice(1);\n      var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n      var functionName = tokens.join(' ') || undefined;\n      var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n      return new StackFrame({\n        functionName: functionName,\n        fileName: fileName,\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2]\n      });\n    }, this);\n  },\n  parseFFOrSafari: function (error) {\n    var filtered = error.stack.split('\\n').filter(function (line) {\n      return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n    }, this);\n    return filtered.map(function (line) {\n      if (line.indexOf(' > eval') > -1) {\n        line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n      }\n\n      if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n        return new StackFrame({\n          functionName: line\n        });\n      } else {\n        var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n        var matches = line.match(functionNameRegex);\n        var functionName = matches && matches[1] ? matches[1] : undefined;\n        var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n        return new StackFrame({\n          functionName: functionName,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2]\n        });\n      }\n    }, this);\n  },\n  parseOpera: function (e) {\n    if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n      return this.parseOpera9(e);\n    } else if (!e.stack) {\n      return this.parseOpera10(e);\n    } else {\n      return this.parseOpera11(e);\n    }\n  },\n  parseOpera9: function (e) {\n    var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n    var lines = e.message.split('\\n');\n    var result = [];\n\n    for (var i = 2, len = lines.length; i < len; i += 2) {\n      var match = lineRE.exec(lines[i]);\n\n      if (match) {\n        result.push(new StackFrame({\n          fileName: match[2],\n          lineNumber: parseFloat(match[1])\n        }));\n      }\n    }\n\n    return result;\n  },\n  parseOpera10: function (e) {\n    var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n    var lines = e.stacktrace.split('\\n');\n    var result = [];\n\n    for (var i = 0, len = lines.length; i < len; i += 2) {\n      var match = lineRE.exec(lines[i]);\n\n      if (match) {\n        result.push(new StackFrame({\n          functionName: match[3] || undefined,\n          fileName: match[2],\n          lineNumber: parseFloat(match[1])\n        }));\n      }\n    }\n\n    return result;\n  },\n  parseOpera11: function (error) {\n    var filtered = error.stack.split('\\n').filter(function (line) {\n      return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n    }, this);\n    return filtered.map(function (line) {\n      var tokens = line.split('@');\n      var locationParts = this.extractLocation(tokens.pop());\n      var functionCall = tokens.shift() || '';\n      var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n      return new StackFrame({\n        functionName: functionName,\n        fileName: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2]\n      });\n    }, this);\n  }\n};\n\nfunction pathToSelector(node) {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  var path = '';\n\n  while (node.parentElement) {\n    var name_1 = node.localName;\n\n    if (!name_1) {\n      break;\n    }\n\n    name_1 = name_1.toLowerCase();\n    var parent_1 = node.parentElement;\n    var domSiblings = [];\n\n    if (parent_1.children && parent_1.children.length > 0) {\n      for (var i = 0; i < parent_1.children.length; i++) {\n        var sibling = parent_1.children[i];\n\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name_1) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name_1 += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n\n    path = name_1 + (path ? '>' + path : '');\n    node = parent_1;\n  }\n\n  return path;\n}\n\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isObjTooDeep(obj, limit) {\n  var e_1, _a;\n\n  if (limit === 0) {\n    return true;\n  }\n\n  var keys = Object.keys(obj);\n\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n\n      if (isObject(obj[key]) && isObjTooDeep(obj[key], limit - 1)) {\n        return true;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return false;\n}\n\nfunction stringify(obj, stringifyOptions) {\n  var options = {\n    numOfKeysLimit: 50,\n    depthOfLimit: 4\n  };\n  Object.assign(options, stringifyOptions);\n  var stack = [];\n  var keys = [];\n  return JSON.stringify(obj, function (key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value = '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (shouldIgnore(value)) {\n      return toString(value);\n    }\n\n    if (value instanceof Event) {\n      var eventResult = {};\n\n      for (var eventKey in value) {\n        var eventValue = value[eventKey];\n\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(eventValue.length ? eventValue[0] : null);\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n\n      return value.nodeName;\n    } else if (value instanceof Error) {\n      return value.stack ? value.stack + '\\nEnd of stack for Error object' : value.name + ': ' + value.message;\n    }\n\n    return value;\n  });\n\n  function shouldIgnore(_obj) {\n    if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n      return true;\n    }\n\n    if (typeof _obj === 'function') {\n      return true;\n    }\n\n    if (isObject(_obj) && isObjTooDeep(_obj, options.depthOfLimit)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function toString(_obj) {\n    var str = _obj.toString();\n\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = \"\".concat(str.slice(0, options.stringLengthLimit), \"...\");\n    }\n\n    return str;\n  }\n}\n\nvar defaultLogOptions = {\n  level: ['assert', 'clear', 'count', 'countReset', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'table', 'time', 'timeEnd', 'timeLog', 'trace', 'warn'],\n  lengthThreshold: 1000,\n  logger: 'console'\n};\n\nfunction initLogObserver(cb, win, logOptions) {\n  var e_1, _a;\n\n  var loggerType = logOptions.logger;\n\n  if (!loggerType) {\n    return function () {};\n  }\n\n  var logger;\n\n  if (typeof loggerType === 'string') {\n    logger = win[loggerType];\n  } else {\n    logger = loggerType;\n  }\n\n  var logCount = 0;\n  var cancelHandlers = [];\n\n  if (logOptions.level.includes('error')) {\n    if (window) {\n      var errorHandler_1 = function (event) {\n        var message = event.message,\n            error = event.error;\n        var trace = ErrorStackParser.parse(error).map(function (stackFrame) {\n          return stackFrame.toString();\n        });\n        var payload = [stringify(message, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace: trace,\n          payload: payload\n        });\n      };\n\n      window.addEventListener('error', errorHandler_1);\n      cancelHandlers.push(function () {\n        if (window) window.removeEventListener('error', errorHandler_1);\n      });\n    }\n  }\n\n  try {\n    for (var _b = __values(logOptions.level), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var levelType = _c.value;\n      cancelHandlers.push(replace(logger, levelType));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return function () {\n    cancelHandlers.forEach(function (h) {\n      return h();\n    });\n  };\n\n  function replace(_logger, level) {\n    var _this = this;\n\n    if (!_logger[level]) {\n      return function () {};\n    }\n\n    return patch(_logger, level, function (original) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        original.apply(_this, args);\n\n        try {\n          var trace = ErrorStackParser.parse(new Error()).map(function (stackFrame) {\n            return stackFrame.toString();\n          }).splice(1);\n          var payload = args.map(function (s) {\n            return stringify(s, logOptions.stringifyOptions);\n          });\n          logCount++;\n\n          if (logCount < logOptions.lengthThreshold) {\n            cb({\n              level: level,\n              trace: trace,\n              payload: payload\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [stringify('The number of log records reached the threshold.')]\n            });\n          }\n        } catch (error) {\n          original.apply(void 0, __spreadArray(['rrweb logger error:', error], __read(args), false));\n        }\n      };\n    });\n  }\n}\n\nvar PLUGIN_NAME = 'rrweb/console@1';\n\nvar getRecordConsolePlugin = function (options) {\n  return {\n    name: PLUGIN_NAME,\n    observer: initLogObserver,\n    options: options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions\n  };\n};\n\nvar ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\nvar defaultLogConfig = {\n  level: ['assert', 'clear', 'count', 'countReset', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'table', 'time', 'timeEnd', 'timeLog', 'trace', 'warn'],\n  replayLogger: undefined\n};\n\nvar LogReplayPlugin = function () {\n  function LogReplayPlugin(config) {\n    this.config = Object.assign(defaultLogConfig, config);\n  }\n\n  LogReplayPlugin.prototype.getConsoleLogger = function () {\n    var e_1, _a;\n\n    var _this = this;\n\n    var replayLogger = {};\n\n    var _loop_1 = function (level) {\n      if (level === 'trace') {\n        replayLogger[level] = function (data) {\n          var logger = console.log[ORIGINAL_ATTRIBUTE_NAME] ? console.log[ORIGINAL_ATTRIBUTE_NAME] : console.log;\n          logger.apply(void 0, __spreadArray(__spreadArray([], __read(data.payload.map(function (s) {\n            return JSON.parse(s);\n          })), false), [_this.formatMessage(data)], false));\n        };\n      } else {\n        replayLogger[level] = function (data) {\n          var logger = console[level][ORIGINAL_ATTRIBUTE_NAME] ? console[level][ORIGINAL_ATTRIBUTE_NAME] : console[level];\n          logger.apply(void 0, __spreadArray(__spreadArray([], __read(data.payload.map(function (s) {\n            return JSON.parse(s);\n          })), false), [_this.formatMessage(data)], false));\n        };\n      }\n    };\n\n    try {\n      for (var _b = __values(this.config.level), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var level = _c.value;\n\n        _loop_1(level);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return replayLogger;\n  };\n\n  LogReplayPlugin.prototype.formatMessage = function (data) {\n    if (data.trace.length === 0) {\n      return '';\n    }\n\n    var stackPrefix = '\\n\\tat ';\n    var result = stackPrefix;\n    result += data.trace.join(stackPrefix);\n    return result;\n  };\n\n  return LogReplayPlugin;\n}();\n\nvar getReplayConsolePlugin = function (options) {\n  var replayLogger = (options === null || options === void 0 ? void 0 : options.replayLogger) || new LogReplayPlugin(options).getConsoleLogger();\n  return {\n    handler: function (event, _isSync, context) {\n      var logData = null;\n\n      if (event.type === exports.tw.IncrementalSnapshot && event.data.source === exports.yh.Log) {\n        logData = event.data;\n      } else if (event.type === exports.tw.Plugin && event.data.plugin === PLUGIN_NAME) {\n        logData = event.data.payload;\n      }\n\n      if (logData) {\n        try {\n          if (typeof replayLogger[logData.level] === 'function') {\n            replayLogger[logData.level](logData);\n          }\n        } catch (error) {\n          if (context.replayer.config.showWarning) {\n            console.warn(error);\n          }\n        }\n      }\n    }\n  };\n};\n\n__webpack_unused_export__ = PLUGIN_NAME;\nexports.xB = Replayer;\n__webpack_unused_export__ = addCustomEvent;\n__webpack_unused_export__ = freezePage;\n__webpack_unused_export__ = getRecordConsolePlugin;\n__webpack_unused_export__ = getReplayConsolePlugin;\n__webpack_unused_export__ = pack;\n__webpack_unused_export__ = record;\nexports.Vv = unpack;\n__webpack_unused_export__ = utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7O0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBR0E7O0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBcFVBO0FBc1VBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBU0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQVNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7QUFnQkE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUdBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTs7QUF1QkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFvQkE7QUFEQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBeUJBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFGQTtBQVFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBV0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7O0FBdUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQTVKQTtBQThKQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BOztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBOztBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQU5BO0FBUUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTs7QUEwQkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFDQTs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQTNCQTs7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBZEE7O0FBZ0JBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUtBO0FBTkE7QUFRQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNKQTtBQTZKQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBS0E7QUFDQTtBQURBO0FBR0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUlBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFIQTtBQVdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVBBO0FBU0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFPQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOztBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBYUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBYUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFvQkE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUF2QkE7O0FBeUJBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBQUE7QUFBQTs7QUEwQkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFQQTtBQUZBO0FBRkE7QUFvQkE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFYQTtBQVlBO0FBQ0E7QUF4RkE7QUEwRkE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUdBOztBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQXBDQTtBQXNDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVNBO0FBQ0E7O0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBU0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBU0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFiQTtBQURBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQWJBO0FBREE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQURBO0FBekNBO0FBSkE7QUEyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQTlJQTtBQURBO0FBa0pBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQURBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQURBO0FBYkE7QUFKQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBWEE7QUFEQTtBQWVBO0FBQ0E7O0FBRUE7QUFBQTtBQUdBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBR0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBWUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFNQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSkE7O0FBTUE7O0FBQ0E7QUFDQTtBQWxCQTs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFHQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQTdFQTs7QUErRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFlQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUExREE7O0FBNERBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQS9UQTtBQWlVQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFJQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7O0FBQ0E7QUFBQTtBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOzs7QUFFQTs7QUFDQTtBQUFBO0FBQUE7OztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBOzs7QUFFQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBQ0E7OztBQUdBO0FBQUE7O0FBRUE7QUFBQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUdBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFNQTtBQUVBO0FBQ0E7OztBQUVBO0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUVBOzs7QUFDQTtBQUVBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBOztBQUVBO0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFFQTs7O0FBQ0E7O0FBRUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFFQTs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFFQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFiQTtBQWVBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQVNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFwSkE7O0FBdUpBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFxQkE7QUFDQTtBQXZCQTs7QUF5QkE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFxQkE7QUF0QkE7O0FBd0JBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N5bmMtc2NyZWVuLy4vbm9kZV9tb2R1bGVzL0B6Y28vcnJ3ZWIvbGliL3Jyd2ViLWFsbC5qcz9jYjFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG52YXIgTm9kZVR5cGU7XHJcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRcIl0gPSAwXSA9IFwiRG9jdW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiRG9jdW1lbnRUeXBlXCJdID0gMV0gPSBcIkRvY3VtZW50VHlwZVwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJFbGVtZW50XCJdID0gMl0gPSBcIkVsZW1lbnRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiVGV4dFwiXSA9IDNdID0gXCJUZXh0XCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNEQVRBXCJdID0gNF0gPSBcIkNEQVRBXCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkNvbW1lbnRcIl0gPSA1XSA9IFwiQ29tbWVudFwiO1xyXG59KShOb2RlVHlwZSB8fCAoTm9kZVR5cGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobikge1xyXG4gICAgcmV0dXJuIG4ubm9kZVR5cGUgPT09IG4uRUxFTUVOVF9OT0RFO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChuKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgaG9zdCA9IChfYSA9IG4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0O1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oaG9zdCAmJiBob3N0LnNoYWRvd1Jvb3QgJiYgaG9zdC5zaGFkb3dSb290ID09PSBuKTtcclxufVxyXG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZShfYSkge1xyXG4gICAgdmFyIG1hc2tJbnB1dE9wdGlvbnMgPSBfYS5tYXNrSW5wdXRPcHRpb25zLCB0YWdOYW1lID0gX2EudGFnTmFtZSwgdHlwZSA9IF9hLnR5cGUsIHZhbHVlID0gX2EudmFsdWUsIG1hc2tJbnB1dEZuID0gX2EubWFza0lucHV0Rm4sIGNsYXNzTGlzdCA9IF9hLmNsYXNzTGlzdDtcclxuICAgIHZhciB0ZXh0ID0gdmFsdWUgfHwgJyc7XHJcbiAgICBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgbWFza0lucHV0T3B0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgIGlmIChtYXNrSW5wdXRGbikge1xyXG4gICAgICAgICAgICB0ZXh0ID0gbWFza0lucHV0Rm4odGV4dCwgY2xhc3NMaXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHQgPSAnKicucmVwZWF0KHRleHQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiBiYXNlNjRFbmNvZGUoYXJyYXlCdWZmZXIpIHtcclxuICAgIHZhciBiYXNlNjQgPSAnJztcclxuICAgIHZhciBlbmNvZGluZ3MgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XHJcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XHJcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XHJcbiAgICB2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzO1xyXG4gICAgdmFyIG1haW5MZW5ndGggPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlcjtcclxuICAgIHZhciBhLCBiLCBjLCBkO1xyXG4gICAgdmFyIGNodW5rO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcclxuICAgICAgICBjaHVuayA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xyXG4gICAgICAgIGEgPSAoY2h1bmsgJiAxNjUxNTA3MikgPj4gMTg7XHJcbiAgICAgICAgYiA9IChjaHVuayAmIDI1ODA0OCkgPj4gMTI7XHJcbiAgICAgICAgYyA9IChjaHVuayAmIDQwMzIpID4+IDY7XHJcbiAgICAgICAgZCA9IGNodW5rICYgNjM7XHJcbiAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXTtcclxuICAgIH1cclxuICAgIGlmIChieXRlUmVtYWluZGVyID09IDEpIHtcclxuICAgICAgICBjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdO1xyXG4gICAgICAgIGEgPSAoY2h1bmsgJiAyNTIpID4+IDI7XHJcbiAgICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7XHJcbiAgICAgICAgYmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArICc9PSc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcclxuICAgICAgICBjaHVuayA9IChieXRlc1ttYWluTGVuZ3RoXSA8PCA4KSB8IGJ5dGVzW21haW5MZW5ndGggKyAxXTtcclxuICAgICAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwO1xyXG4gICAgICAgIGIgPSAoY2h1bmsgJiAxMDA4KSA+PiA0O1xyXG4gICAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjtcclxuICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhc2U2NDtcclxufVxyXG5mdW5jdGlvbiBnZXRGb250RmFjZVByb3BlcnR5KHN0cikge1xyXG4gICAgdmFyIHJlZ2V4ID0gLyhbXFx3LV0qKVxccyo6XFxzKihbXjtdKikvZztcclxuICAgIHZhciBtYXRjaCwgcHJvcGVydGllcyA9IHt9O1xyXG4gICAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhzdHIpKSB7XHJcbiAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnc3JjJykge1xyXG4gICAgICAgICAgICB2YXIgaGFzV29mZiA9IG1hdGNoWzJdLmluY2x1ZGVzKFwiLndvZmZcXFwiXCIpO1xyXG4gICAgICAgICAgICB2YXIgdXJscyA9IG1hdGNoWzJdLnNwbGl0KCcsJykgfHwgW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB1cmxzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHVybHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1dvZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiLndvZmZcIikgJiYgIXVybC5pbmNsdWRlcyhcIi53b2ZmMlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd29mZnMgPSB1cmwubWF0Y2goL2h0dHBzOi4qPy53b2ZmL2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW21hdGNoWzFdXSA9IHdvZmZzICYmIHdvZmZzWzBdID8gd29mZnNbMF0gOiAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1snZm9ybWF0J10gPSAnd29mZic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwuaW5jbHVkZXMoXCIud29mZjJcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvZmZzID0gdXJsLm1hdGNoKC9odHRwczouKj8ud29mZjIvZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbbWF0Y2hbMV1dID0gd29mZnMgJiYgd29mZnNbMF0gPyB3b2Zmc1swXSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzWydmb3JtYXQnXSA9ICd3b2ZmMic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmwuaW5jbHVkZXMoXCIudHRmXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3b2ZmcyA9IHVybC5tYXRjaCgvaHR0cHM6Lio/LnR0Zi9nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1ttYXRjaFsxXV0gPSB3b2ZmcyAmJiB3b2Zmc1swXSA/IHdvZmZzWzBdIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbJ2Zvcm1hdCddID0gJ3RydWV0eXBlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW21hdGNoWzFdXSA9IG1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcGVydGllcztcclxufVxyXG5mdW5jdGlvbiBnZXRGb250RmFjZVN0cmluZyhzdHIpIHtcclxuICAgIGlmICghc3RyIHx8IHN0ci5sZW5ndGggPD0gMClcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB2YXIgcmVnZXggPSAvQGZvbnQtZmFjZS4qP30vZztcclxuICAgIHJldHVybiBzdHIubWF0Y2gocmVnZXgpO1xyXG59XHJcbnZhciBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSQyID0gJ19fcnJ3ZWJfb3JpZ2luYWxfXyc7XHJcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayQxKGNhbnZhcykge1xyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgY2h1bmtTaXplID0gNTA7XHJcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCArPSBjaHVua1NpemUpIHtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgIHZhciBnZXRJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxHZXRJbWFnZURhdGEgPSBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSQyIGluIGdldEltYWdlRGF0YVxyXG4gICAgICAgICAgICAgICAgPyBnZXRJbWFnZURhdGFbT1JJR0lOQUxfQVRUUklCVVRFX05BTUUkMl1cclxuICAgICAgICAgICAgICAgIDogZ2V0SW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWxCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkob3JpZ2luYWxHZXRJbWFnZURhdGEuY2FsbChjdHgsIHgsIHksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLndpZHRoIC0geCksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpKS5kYXRhLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbEJ1ZmZlci5zb21lKGZ1bmN0aW9uIChwaXhlbCkgeyByZXR1cm4gcGl4ZWwgIT09IDA7IH0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbnZhciBfaWQgPSAxO1xyXG52YXIgdGFnTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnW15hLXowLTktXzpdJyk7XHJcbnZhciBJR05PUkVEX05PREUgPSAtMjtcclxuZnVuY3Rpb24gZ2VuSWQoKSB7XHJcbiAgICByZXR1cm4gX2lkKys7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmFsaWRUYWdOYW1lKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdmb3JtJztcclxuICAgIH1cclxuICAgIHZhciBwcm9jZXNzZWRUYWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gICAgaWYgKHRhZ05hbWVSZWdleC50ZXN0KHByb2Nlc3NlZFRhZ05hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdkaXYnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhZ05hbWU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3NzUnVsZXNTdHJpbmcocykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgcnVsZXMgPSBzLnJ1bGVzIHx8IHMuY3NzUnVsZXM7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzID8gQXJyYXkuZnJvbShydWxlcykubWFwKGdldENzc1J1bGVTdHJpbmcpLmpvaW4oJycpIDogbnVsbDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldENzc1J1bGVTdHJpbmcocnVsZSkge1xyXG4gICAgdmFyIGNzc1N0cmluZ2lmaWVkID0gcnVsZS5jc3NUZXh0O1xyXG4gICAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNzc1N0cmluZ2lmaWVkID0gZ2V0Q3NzUnVsZXNTdHJpbmcocnVsZS5zdHlsZVNoZWV0KSB8fCBjc3NTdHJpbmdpZmllZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNzc1N0cmluZ2lmaWVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ1NTSW1wb3J0UnVsZShydWxlKSB7XHJcbiAgICByZXR1cm4gJ3N0eWxlU2hlZXQnIGluIHJ1bGU7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGVTaGVldChzaGVldCkge1xyXG4gICAgcmV0dXJuIHNoZWV0LmNzc1J1bGVzXHJcbiAgICAgICAgPyBBcnJheS5mcm9tKHNoZWV0LmNzc1J1bGVzKVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiBydWxlLmNzc1RleHQgfHwgJyc7IH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcnKVxyXG4gICAgICAgIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcclxuICAgIHZhciBvcmlnaW4gPSAnJztcclxuICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA+IC0xKSB7XHJcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KCcvJylbMF07XHJcbiAgICB9XHJcbiAgICBvcmlnaW4gPSBvcmlnaW4uc3BsaXQoJz8nKVswXTtcclxuICAgIHJldHVybiBvcmlnaW47XHJcbn1cclxudmFyIGNhbnZhc1NlcnZpY2U7XHJcbnZhciBjYW52YXNDdHg7XHJcbnZhciBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcclxudmFyIFJFTEFUSVZFX1BBVEggPSAvXig/IXd3d1xcLnwoPzpodHRwfGZ0cClzPzpcXC9cXC98W0EtWmEtel06XFxcXHxcXC9cXC98IykuKi87XHJcbnZhciBEQVRBX1VSSSA9IC9eKGRhdGE6KShbXixdKiksKC4qKS9pO1xyXG52YXIgREFUQV9VUkkyID0gL14oZGF0YVxcXFw6KShbXixdKiksKC4qKS9pO1xyXG5mdW5jdGlvbiBhYnNvbHV0ZVRvU3R5bGVzaGVldChjc3NUZXh0LCBocmVmKSB7XHJcbiAgICByZXR1cm4gKGNzc1RleHQgfHwgJycpLnJlcGxhY2UoVVJMX0lOX0NTU19SRUYsIGZ1bmN0aW9uIChvcmlnaW4sIHF1b3RlMSwgcGF0aDEsIHF1b3RlMiwgcGF0aDIsIHBhdGgzKSB7XHJcbiAgICAgICAgdmFyIGZpbGVQYXRoID0gcGF0aDEgfHwgcGF0aDIgfHwgcGF0aDM7XHJcbiAgICAgICAgdmFyIG1heWJlUXVvdGUgPSBxdW90ZTEgfHwgcXVvdGUyIHx8ICcnO1xyXG4gICAgICAgIGlmICghZmlsZVBhdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFSRUxBVElWRV9QQVRILnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBmaWxlUGF0aCArIG1heWJlUXVvdGUgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERBVEFfVVJJLnRlc3QoZmlsZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBmaWxlUGF0aCArIG1heWJlUXVvdGUgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKERBVEFfVVJJMi50ZXN0KGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoXCIgKyBtYXliZVF1b3RlICsgZmlsZVBhdGggKyBtYXliZVF1b3RlICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWxlUGF0aFswXSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyAoZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRoKSArIG1heWJlUXVvdGUgKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YWNrID0gaHJlZi5zcGxpdCgnLycpO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xW19pXTtcclxuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBzdGFjay5qb2luKCcvJykgKyBtYXliZVF1b3RlICsgXCIpXCI7XHJcbiAgICB9KTtcclxufVxyXG52YXIgU1JDU0VUX05PVF9TUEFDRVMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy87XHJcbnZhciBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcclxuZnVuY3Rpb24gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zID0gMDtcclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XHJcbiAgICAgICAgdmFyIGNoYXJzO1xyXG4gICAgICAgIHZhciBtYXRjaCA9IHJlZ0V4LmV4ZWMoYXR0cmlidXRlVmFsdWUuc3Vic3RyaW5nKHBvcykpO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBjaGFycyA9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgICBwb3MgKz0gY2hhcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMpO1xyXG4gICAgICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdXJsID0gY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX05PVF9TUEFDRVMpO1xyXG4gICAgICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSAnLCcpIHtcclxuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2godXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yc1N0ciA9ICcnO1xyXG4gICAgICAgICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsKTtcclxuICAgICAgICAgICAgdmFyIGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJBdChwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWluUGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKHVybCArIGRlc2NyaXB0b3JzU3RyKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYztcclxuICAgICAgICAgICAgICAgIHBvcyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcsICcpO1xyXG59XHJcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xyXG4gICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCBhdHRyaWJ1dGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGEgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgYS5ocmVmID0gYXR0cmlidXRlVmFsdWU7XHJcbiAgICByZXR1cm4gYS5ocmVmO1xyXG59XHJcbmZ1bmN0aW9uIGlzU1ZHRWxlbWVudChlbCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZWwudGFnTmFtZSA9PT0gJ3N2ZycgfHwgZWwub3duZXJTVkdFbGVtZW50KTtcclxufVxyXG5mdW5jdGlvbiBnZXRIcmVmKCkge1xyXG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBhLmhyZWYgPSAnJztcclxuICAgIHJldHVybiBhLmhyZWY7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgbmFtZSwgdmFsdWUpIHtcclxuICAgIGlmIChuYW1lID09PSAnc3JjJyB8fCAobmFtZSA9PT0gJ2hyZWYnICYmIHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3hsaW5rOmhyZWYnICYmIHZhbHVlICYmIHZhbHVlWzBdICE9PSAnIycpIHtcclxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdiYWNrZ3JvdW5kJyAmJlxyXG4gICAgICAgIHZhbHVlICYmXHJcbiAgICAgICAgKHRhZ05hbWUgPT09ICd0YWJsZScgfHwgdGFnTmFtZSA9PT0gJ3RkJyB8fCB0YWdOYW1lID09PSAndGgnKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3NyY3NldCcgJiYgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9TdHlsZXNoZWV0KHZhbHVlLCBnZXRIcmVmKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ29iamVjdCcgJiYgbmFtZSA9PT0gJ2RhdGEnICYmIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2lzQmxvY2tlZEVsZW1lbnQoZWxlbWVudCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICghYmxvY2tDbGFzcyB8fCBibG9ja0NsYXNzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGJsb2NrQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgZUluZGV4ID0gMDsgZUluZGV4IDwgZWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc0xpc3RbZUluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGJsb2NrQ2xhc3MudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0lnbm9yZWRFbGVtZW50KGVsZW1lbnQsIGlnbm9yZUNsYXNzKSB7XHJcbiAgICBpZiAodHlwZW9mIGlnbm9yZUNsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1hc2tUZXh0Q2xhc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhtYXNrVGV4dENsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGVJbmRleCA9IDA7IGVJbmRleCA8IG5vZGUuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBub2RlLmNsYXNzTGlzdC5pdGVtKGVJbmRleCkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFza1RleHRDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hc2tUZXh0U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubWF0Y2hlcyhtYXNrVGV4dFNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5lZWRNYXNraW5nVGV4dChub2RlLnBhcmVudE5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIG5lZWRNYXNraW5nVGV4dChub2RlLnBhcmVudE5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5lZWRNYXNraW5nVGV4dChub2RlLnBhcmVudE5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIF9uZWVkTWFza2luZ1RleHQobm9kZSwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3Rvcikge1xyXG4gICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXNrVGV4dENsYXNzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5jbGFzc0xpc3QuY29udGFpbnMobWFza1RleHRDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlZF8xID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tUZXh0Q2xhc3MudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZF8xID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkXzE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXNrVGV4dFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm1hdGNoZXMobWFza1RleHRTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBfbmVlZE1hc2tpbmdUZXh0KG5vZGUucGFyZW50Tm9kZSwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3Rvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX25lZWRNYXNraW5nVGV4dChub2RlLnBhcmVudE5vZGUsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xyXG4gICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XHJcbiAgICBpZiAoIXdpbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBmaXJlZCA9IGZhbHNlO1xyXG4gICAgdmFyIHJlYWR5U3RhdGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChyZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgdmFyIHRpbWVyXzEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGlmcmFtZUxvYWRUaW1lb3V0KTtcclxuICAgICAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJfMSk7XHJcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgYmxhbmtVcmwgPSAnYWJvdXQ6YmxhbmsnO1xyXG4gICAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fFxyXG4gICAgICAgIGlmcmFtZUVsLnNyYyA9PT0gYmxhbmtVcmwgfHxcclxuICAgICAgICBpZnJhbWVFbC5zcmMgPT09ICcnKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChsaXN0ZW5lciwgMCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxpc3RlbmVyKTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBkb2MgPSBvcHRpb25zLmRvYywgYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IG9wdGlvbnMuYmxvY2tTZWxlY3RvciwgbWFza1RleHRDbGFzcyA9IG9wdGlvbnMubWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciA9IG9wdGlvbnMubWFza1RleHRTZWxlY3RvciwgaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgX2IgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dE9wdGlvbnMgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYiwgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgbWFza0lucHV0Rm4gPSBvcHRpb25zLm1hc2tJbnB1dEZuLCBfYyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsIGlubGluZUltYWdlcyA9IG9wdGlvbnMuaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywga2VlcElmcmFtZVNyY0ZuID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIGRpc2FibGVSZW1vdGVDb250cm9sRm4gPSBvcHRpb25zLmRpc2FibGVSZW1vdGVDb250cm9sRm47XHJcbiAgICB2YXIgcm9vdElkO1xyXG4gICAgaWYgKGRvYy5fX3NuKSB7XHJcbiAgICAgICAgdmFyIGRvY0lkID0gZG9jLl9fc24uaWQ7XHJcbiAgICAgICAgcm9vdElkID0gZG9jSWQgPT09IDEgPyB1bmRlZmluZWQgOiBkb2NJZDtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobi5ub2RlVHlwZSkge1xyXG4gICAgICAgIGNhc2Ugbi5ET0NVTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICBpZiAobi5jb21wYXRNb2RlICE9PSAnQ1NTMUNvbXBhdCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuRG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGF0TW9kZTogbi5jb21wYXRNb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICByb290SWQ6IHJvb3RJZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2Ugbi5ET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogbi5wdWJsaWNJZCxcclxuICAgICAgICAgICAgICAgIHN5c3RlbUlkOiBuLnN5c3RlbUlkLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uRUxFTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZVJlbW90ZUNvbnRyb2xGbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9pc0Rpc2FibGVSZW1vdGVDb250cm9sRWxlbWVudChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZW1vdGVDb250cm9sRm4od2luZG93LmxvY2F0aW9uLmhyZWYsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlbW90ZUNvbnRyb2xGbih3aW5kb3cubG9jYXRpb24uaHJlZiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZWVkSWdub3JlID0gX2lzSWdub3JlZEVsZW1lbnQobiwgJ3JyLWlnbm9yZScpO1xyXG4gICAgICAgICAgICBpZiAobmVlZElnbm9yZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuZWVkQmxvY2sgPSBfaXNCbG9ja2VkRWxlbWVudChuLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcclxuICAgICAgICAgICAgdmFyIG5lZWRNYXNrID0gbmVlZE1hc2tpbmdUZXh0KG4sIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IGdldFZhbGlkVGFnTmFtZShuKTtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNfMSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9kID0gQXJyYXkuZnJvbShuLmF0dHJpYnV0ZXMpOyBfaSA8IF9kLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9lID0gX2RbX2ldLCBuYW1lXzEgPSBfZS5uYW1lLCB2YWx1ZSA9IF9lLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc18xW25hbWVfMV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCBuYW1lXzEsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2xpbmsnICYmIGlubGluZVN0eWxlc2hlZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gQXJyYXkuZnJvbShkb2Muc3R5bGVTaGVldHMpLmZpbmQoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5ocmVmID09PSBuLmhyZWY7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZXNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCA9IGdldENzc1J1bGVzU3RyaW5nKHN0eWxlc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNzc1RleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc18xLnJlbDtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc18xLmhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLl9jc3NUZXh0ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgc3R5bGVzaGVldC5ocmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3N0eWxlJyAmJlxyXG4gICAgICAgICAgICAgICAgbi5zaGVldCAmJlxyXG4gICAgICAgICAgICAgICAgIShuLmlubmVyVGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIG4udGV4dENvbnRlbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAnJykudHJpbSgpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNzc1RleHQgPSBnZXRDc3NSdWxlc1N0cmluZyhuLnNoZWV0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjc3NUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLl9jc3NUZXh0ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgZ2V0SHJlZigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0JyB8fFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyB8fFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG4udmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc18xLnR5cGUgIT09ICdyYWRpbycgJiZcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEudHlwZSAhPT0gJ2NoZWNrYm94JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMS50eXBlICE9PSAnc3VibWl0JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMS50eXBlICE9PSAnYnV0dG9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBuLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3QgPSBuLmNsYXNzTGlzdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IG4uVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IG4ucGFyZW50Tm9kZS5jbGFzc0xpc3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMS52YWx1ZSA9IG1hc2tJbnB1dFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYXR0cmlidXRlc18xLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobi5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLmNoZWNrZWQgPSBuLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobi5zZWxlY3RlZCAmJiAhbWFza0lucHV0T3B0aW9uc1snc2VsZWN0J10pIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNfMS5zZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2NhbnZhcycgJiYgcmVjb3JkQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobi5fX2NvbnRleHQgPT09ICcyZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzMkRDYW52YXNCbGFuayQxKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMS5ycl9kYXRhVVJMID0gbi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISgnX19jb250ZXh0JyBpbiBuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNEYXRhVVJMID0gbi50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsYW5rQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxhbmtDYW52YXMud2lkdGggPSBuLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJsYW5rQ2FudmFzLmhlaWdodCA9IG4uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibGFua0NhbnZhc0RhdGFVUkwgPSBibGFua0NhbnZhcy50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhc0RhdGFVUkwgIT09IGJsYW5rQ2FudmFzRGF0YVVSTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnaW1nJyAmJiBpbmxpbmVJbWFnZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FudmFzU2VydmljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQ3R4ID0gY2FudmFzU2VydmljZS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlXzEgPSBuO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlXzEgPSBpbWFnZV8xLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VfMS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZElubGluZUltYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2Uud2lkdGggPSBpbWFnZV8xLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZV8xLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0N0eC5kcmF3SW1hZ2UoaW1hZ2VfMSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMS5ycl9kYXRhVVJMID0gY2FudmFzU2VydmljZS50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IGlubGluZSBpbWcgc3JjPVwiICsgaW1hZ2VfMS5jdXJyZW50U3JjICsgXCIhIEVycm9yOiBcIiArIGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlXzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoYXR0cmlidXRlc18xLmNyb3NzT3JpZ2luID0gb2xkVmFsdWVfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWxldGUgYXR0cmlidXRlc18xLmNyb3NzT3JpZ2luO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZV8xLmNvbXBsZXRlICYmIGltYWdlXzEubmF0dXJhbFdpZHRoICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZElubGluZUltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VfMS5vbmxvYWQgPSByZWNvcmRJbmxpbmVJbWFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2F1ZGlvJyB8fCB0YWdOYW1lID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfbWVkaWFTdGF0ZSA9IG4ucGF1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgPyAncGF1c2VkJ1xyXG4gICAgICAgICAgICAgICAgICAgIDogJ3BsYXllZCc7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfbWVkaWFDdXJyZW50VGltZSA9IG4uY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG4uc2Nyb2xsTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLnJyX3Njcm9sbExlZnQgPSBuLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG4uc2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfc2Nyb2xsVG9wID0gbi5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5lZWRCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC53aWR0aCwgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGhlaWdodCA8PSAwIHx8IHdpZHRoIDw9IDApICYmIHRhZ05hbWUgPT09ICdpbWcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBuLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IG4ubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJpYWxpemVOb2RlIDogJywgdGFnTmFtZSwgd2lkdGgsIGhlaWdodCwgbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gYXR0cmlidXRlc18xW1wiY2xhc3NcIl07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmICFjbGFzc05hbWUuaW5jbHVkZXMoJ3JyLWJsb2NrJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gJyByci1ibG9jayc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3NwYW4nIHx8IHRhZ05hbWUgPT09ICdwJyB8fCB0YWdOYW1lID09PSAnaW5wdXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xW1wiY2xhc3NcIl0gPSBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLnJyX3dpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLnJyX2hlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfYmFja2dyb3VuZF9pbWFnZSA9IFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg0NWRlZywgI2ZmZiwgI2ZmZiAxMHB4LCAjY2NjIDEwcHgsICNjY2MgMjBweClcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJyX3dpZHRoOiB3aWR0aCArIFwicHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnJfaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJyX2JhY2tncm91bmRfaW1hZ2U6IFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg0NWRlZywgI2ZmZiwgI2ZmZiAxMHB4LCAjY2NjIDEwcHgsICNjY2MgMjBweClcIlxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5lZWRNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGF0dHJpYnV0ZXNfMVtcImNsYXNzXCJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiAhY2xhc3NOYW1lLmluY2x1ZGVzKCdyci1tYXNrJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gJyByci1tYXNrJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNfMVtcImNsYXNzXCJdID0gY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc18xLnJyX3dpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdpZnJhbWUnICYmICFrZWVwSWZyYW1lU3JjRm4oYXR0cmlidXRlc18xLnNyYykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbi5jb250ZW50RG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXzEucnJfc3JjID0gYXR0cmlidXRlc18xLnNyYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzXzEuc3JjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNfMSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuKSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBuZWVkQmxvY2s6IG5lZWRCbG9jayxcclxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBuLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgdmFyIHBhcmVudFRhZ05hbWUgPSBuLnBhcmVudE5vZGUgJiYgbi5wYXJlbnROb2RlLnRhZ05hbWU7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudF8xID0gbi50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgdmFyIGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSAnU1RZTEUnID8gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIGlzU2NyaXB0ID0gcGFyZW50VGFnTmFtZSA9PT0gJ1NDUklQVCcgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudF8xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBuLnBhcmVudE5vZGUuc2hlZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jc3NSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudF8xID0gc3RyaW5naWZ5U3R5bGVTaGVldChuLnBhcmVudE5vZGUuc2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3QgZ2V0IENTUyBzdHlsZXMgZnJvbSB0ZXh0J3MgcGFyZW50Tm9kZS4gRXJyb3I6IFwiICsgZXJyLCBuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgPSBhYnNvbHV0ZVRvU3R5bGVzaGVldCh0ZXh0Q29udGVudF8xLCBnZXRIcmVmKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1NjcmlwdCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnRfMSA9ICdTQ1JJUFRfUExBQ0VIT0xERVInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfbmVlZE1hc2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFpc1N0eWxlICYmXHJcbiAgICAgICAgICAgICAgICAhaXNTY3JpcHQgJiZcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEpIHtcclxuICAgICAgICAgICAgICAgIF9uZWVkTWFzayA9IF9uZWVkTWFza2luZ1RleHQobi5wYXJlbnROb2RlLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzU3R5bGUgJiZcclxuICAgICAgICAgICAgICAgICFpc1NjcmlwdCAmJlxyXG4gICAgICAgICAgICAgICAgX25lZWRNYXNrICYmXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29udGVudF8xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG4ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IHBhcmVudE5vZGUuY2xhc3NMaXN0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnRfMSA9IG1hc2tUZXh0Rm5cclxuICAgICAgICAgICAgICAgICAgICA/IG1hc2tUZXh0Rm4odGV4dENvbnRlbnRfMSwgY2xhc3NMaXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIDogdGV4dENvbnRlbnRfMS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodGV4dENvbnRlbnRfMSA9PT0gbnVsbCB8fCB0ZXh0Q29udGVudF8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0Q29udGVudF8xLmluY2x1ZGVzKCdAZm9udC1mYWNlJykpICYmICh0ZXh0Q29udGVudF8xID09PSBudWxsIHx8IHRleHRDb250ZW50XzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRDb250ZW50XzEuaW5jbHVkZXMobG9jYXRpb24ub3JpZ2luKSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb250RmFjZVN0cmluZ3MgPSBnZXRGb250RmFjZVN0cmluZyh0ZXh0Q29udGVudF8xKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGZvbnRGYWNlU3RyaW5ncy5tYXAoZnVuY3Rpb24gKGZvbnRGYWNlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gZ2V0Rm9udEZhY2VQcm9wZXJ0eShmb250RmFjZVN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb250RmFtaWx5XzEgPSBwcm9wZXJ0eSA/IHByb3BlcnR5Wydmb250LWZhbWlseSddIDogJ3Vua25vdyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb250RmFjZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGZvbnRGYW1pbHlfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250RmFjZSAmJiBmb250RmFjZS5sZW5ndGggPiAwICYmIHRleHRDb250ZW50XzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgPSB0ZXh0Q29udGVudF8xLnJlcGxhY2UoZm9udEZhY2VTdHJpbmcsIGZvbnRGYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmMgPSBwcm9wZXJ0eVsnc3JjJ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0XzEgPSBwcm9wZXJ0eVsnZm9ybWF0J107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9udFN0eWxlXzEgPSBwcm9wZXJ0eVsnZm9udC1zdHlsZSddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRXZWlnaHRfMSA9IHByb3BlcnR5W1wiZm9udC13ZWlnaHRcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHNyYywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gNCB8fCB4aHIuc3RhdHVzICE9IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZTY0RW5jb2RlZEZvbnQgPSBiYXNlNjRFbmNvZGUoeGhyLnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlNjRFbmNvZGVkRm9udCAmJiBiYXNlNjRFbmNvZGVkRm9udC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRDb2RlID0gXCJAZm9udC1mYWNlIHsgZm9udC1mYW1pbHk6IFwiICsgZm9udEZhbWlseV8xICsgXCI7IHNyYzogdXJsKFxcXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsXCIgKyBiYXNlNjRFbmNvZGVkRm9udCArIFwiXFxcIikgZm9ybWF0KFxcXCJcIiArIGZvcm1hdF8xICsgXCJcXFwiKTsgZm9udC1zdHlsZTogXCIgKyBmb250U3R5bGVfMSArIFwiOyBmb250LXdlaWdodDogXCIgKyBmb250V2VpZ2h0XzEgKyBcIiB9XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZm9udEZhbWlseV8xLCBmb250Q29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gZm9udENvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih4aHIuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoeGhyLnN0YXR1c1RleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuVGV4dCxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudF8xIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgaXNTdHlsZTogaXNTdHlsZSxcclxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBuLkNEQVRBX1NFQ1RJT05fTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkNEQVRBLFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIG4uQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUuQ29tbWVudCxcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50OiBuLnRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbG93ZXJJZkV4aXN0cyhtYXliZUF0dHIpIHtcclxuICAgIGlmIChtYXliZUF0dHIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XHJcbiAgICBpZiAoc2xpbURPTU9wdGlvbnMuY29tbWVudCAmJiBzbi50eXBlID09PSBOb2RlVHlwZS5Db21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbi50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLnNjcmlwdCAmJlxyXG4gICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ3NjcmlwdCcgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICBzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3ByZWxvYWQnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc24uYXR0cmlidXRlcy5hcyA9PT0gJ3NjcmlwdCcpIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc24uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVmZXRjaCcgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMuaHJlZi5lbmRzV2l0aCgnLmpzJykpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZEZhdmljb24gJiZcclxuICAgICAgICAgICAgKChzbi50YWdOYW1lID09PSAnbGluaycgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09ICdzaG9ydGN1dCBpY29uJykgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbWV0YScgJiZcclxuICAgICAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9ebXNhcHBsaWNhdGlvbi10aWxlKGltYWdlfGNvbG9yKSQvKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdhcHBsaWNhdGlvbi1uYW1lJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ2ljb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnYXBwbGUtdG91Y2gtaWNvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdzaG9ydGN1dCBpY29uJykpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc24udGFnTmFtZSA9PT0gJ21ldGEnKSB7XHJcbiAgICAgICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YURlc2NLZXl3b3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eZGVzY3JpcHRpb258a2V5d29yZHMkLykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXihvZ3x0d2l0dGVyfGZiKTovKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3BpbnRlcmVzdCcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVJvYm90cyAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3JvYm90cycgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdnb29nbGVib3QnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYmluZ2JvdCcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUh0dHBFcXVpdiAmJlxyXG4gICAgICAgICAgICAgICAgc24uYXR0cmlidXRlc1snaHR0cC1lcXVpdiddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhQXV0aG9yc2hpcCAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2F1dGhvcicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdnZW5lcmF0b3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZnJhbWV3b3JrJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3B1Ymxpc2hlcicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwcm9naWQnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXmFydGljbGU6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9ecHJvZHVjdDovKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhVmVyaWZpY2F0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3lhbmRleC12ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnY3NyZi10b2tlbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwOmRvbWFpbl92ZXJpZnknIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAndmVyaWZ5LXYxJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3ZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdzaG9waWZ5LWNoZWNrb3V0LWFwaS10b2tlbicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBkb2MgPSBvcHRpb25zLmRvYywgbWFwID0gb3B0aW9ucy5tYXAsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIG1hc2tUZXh0Q2xhc3MgPSBvcHRpb25zLm1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIF9hID0gb3B0aW9ucy5za2lwQ2hpbGQsIHNraXBDaGlsZCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRPcHRpb25zID0gX2MgPT09IHZvaWQgMCA/IHt9IDogX2MsIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgc2xpbURPTU9wdGlvbnMgPSBvcHRpb25zLnNsaW1ET01PcHRpb25zLCBfZCA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2QsIF9lID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCByZWNvcmRDYW52YXMgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZiwgb25TZXJpYWxpemUgPSBvcHRpb25zLm9uU2VyaWFsaXplLCBvbklmcmFtZUxvYWQgPSBvcHRpb25zLm9uSWZyYW1lTG9hZCwgX2cgPSBvcHRpb25zLmlmcmFtZUxvYWRUaW1lb3V0LCBpZnJhbWVMb2FkVGltZW91dCA9IF9nID09PSB2b2lkIDAgPyA1MDAwIDogX2csIF9oID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIGtlZXBJZnJhbWVTcmNGbiA9IF9oID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSA6IF9oLCBkaXNhYmxlUmVtb3RlQ29udHJvbEZuID0gb3B0aW9ucy5kaXNhYmxlUmVtb3RlQ29udHJvbEZuO1xyXG4gICAgdmFyIF9qID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlU3BhY2UsIHByZXNlcnZlV2hpdGVTcGFjZSA9IF9qID09PSB2b2lkIDAgPyB0cnVlIDogX2o7XHJcbiAgICB2YXIgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuLCB7XHJcbiAgICAgICAgZG9jOiBkb2MsXHJcbiAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcclxuICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcclxuICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXHJcbiAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIGRpc2FibGVSZW1vdGVDb250cm9sRm46IGRpc2FibGVSZW1vdGVDb250cm9sRm5cclxuICAgIH0pO1xyXG4gICAgaWYgKCFfc2VyaWFsaXplZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBpZDtcclxuICAgIGlmICgnX19zbicgaW4gbikge1xyXG4gICAgICAgIGlkID0gbi5fX3NuLmlkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2xpbURPTUV4Y2x1ZGVkKF9zZXJpYWxpemVkTm9kZSwgc2xpbURPTU9wdGlvbnMpIHx8XHJcbiAgICAgICAgKCFwcmVzZXJ2ZVdoaXRlU3BhY2UgJiZcclxuICAgICAgICAgICAgX3NlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLlRleHQgJiZcclxuICAgICAgICAgICAgIV9zZXJpYWxpemVkTm9kZS5pc1N0eWxlICYmXHJcbiAgICAgICAgICAgICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sICcnKS5sZW5ndGgpKSB7XHJcbiAgICAgICAgaWQgPSBJR05PUkVEX05PREU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZCA9IGdlbklkKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2VyaWFsaXplZE5vZGUgPSBPYmplY3QuYXNzaWduKF9zZXJpYWxpemVkTm9kZSwgeyBpZDogaWQgfSk7XHJcbiAgICBuLl9fc24gPSBzZXJpYWxpemVkTm9kZTtcclxuICAgIGlmIChpZCA9PT0gSUdOT1JFRF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXBbaWRdID0gbjtcclxuICAgIGlmIChvblNlcmlhbGl6ZSkge1xyXG4gICAgICAgIG9uU2VyaWFsaXplKG4pO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlY29yZENoaWxkID0gIXNraXBDaGlsZDtcclxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgcmVjb3JkQ2hpbGQgPSByZWNvcmRDaGlsZCAmJiAhc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xyXG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XHJcbiAgICAgICAgaWYgKG4uc2hhZG93Um9vdClcclxuICAgICAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3dIb3N0ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICgoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRG9jdW1lbnQgfHxcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSAmJlxyXG4gICAgICAgIHJlY29yZENoaWxkKSB7XHJcbiAgICAgICAgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRXaGl0ZXNwYWNlICYmXHJcbiAgICAgICAgICAgIF9zZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgICAgIF9zZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAnaGVhZCcpIHtcclxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBieXBhc3NPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkb2M6IGRvYyxcclxuICAgICAgICAgICAgbWFwOiBtYXAsXHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIHNraXBDaGlsZDogc2tpcENoaWxkLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxyXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICBkaXNhYmxlUmVtb3RlQ29udHJvbEZuOiBkaXNhYmxlUmVtb3RlQ29udHJvbEZuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9rID0gQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpOyBfaSA8IF9rLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGROID0gX2tbX2ldO1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNFbGVtZW50KG4pICYmIG4uc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfbCA9IDAsIF9tID0gQXJyYXkuZnJvbShuLnNoYWRvd1Jvb3QuY2hpbGROb2Rlcyk7IF9sIDwgX20ubGVuZ3RoOyBfbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROID0gX21bX2xdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRDaGlsZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuLnBhcmVudE5vZGUgJiYgaXNTaGFkb3dSb290KG4ucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvdyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09ICdpZnJhbWUnKSB7XHJcbiAgICAgICAgb25jZUlmcmFtZUxvYWRlZChuLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpZnJhbWVEb2MgPSBuLmNvbnRlbnREb2N1bWVudDtcclxuICAgICAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkSWZyYW1lTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoaWZyYW1lRG9jLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBpZnJhbWVEb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBtYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVJlbW90ZUNvbnRyb2xGbjogZGlzYWJsZVJlbW90ZUNvbnRyb2xGblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQobiwgc2VyaWFsaXplZElmcmFtZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNuYXBzaG90KG4sIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYSA9IG9wdGlvbnMgfHwge30sIF9iID0gX2EuYmxvY2tDbGFzcywgYmxvY2tDbGFzcyA9IF9iID09PSB2b2lkIDAgPyAncnItYmxvY2snIDogX2IsIF9jID0gX2EuYmxvY2tTZWxlY3RvciwgYmxvY2tTZWxlY3RvciA9IF9jID09PSB2b2lkIDAgPyBudWxsIDogX2MsIF9kID0gX2EubWFza1RleHRDbGFzcywgbWFza1RleHRDbGFzcyA9IF9kID09PSB2b2lkIDAgPyAncnItbWFzaycgOiBfZCwgX2UgPSBfYS5tYXNrVGV4dFNlbGVjdG9yLCBtYXNrVGV4dFNlbGVjdG9yID0gX2UgPT09IHZvaWQgMCA/IG51bGwgOiBfZSwgX2YgPSBfYS5pbmxpbmVTdHlsZXNoZWV0LCBpbmxpbmVTdHlsZXNoZWV0ID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZiwgX2cgPSBfYS5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nLCBfaCA9IF9hLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2gsIF9qID0gX2EubWFza0FsbElucHV0cywgbWFza0FsbElucHV0cyA9IF9qID09PSB2b2lkIDAgPyBmYWxzZSA6IF9qLCBtYXNrVGV4dEZuID0gX2EubWFza1RleHRGbiwgbWFza0lucHV0Rm4gPSBfYS5tYXNrSW5wdXRGbiwgX2sgPSBfYS5zbGltRE9NLCBzbGltRE9NID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2ssIGRhdGFVUkxPcHRpb25zID0gX2EuZGF0YVVSTE9wdGlvbnMsIHByZXNlcnZlV2hpdGVTcGFjZSA9IF9hLnByZXNlcnZlV2hpdGVTcGFjZSwgb25TZXJpYWxpemUgPSBfYS5vblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkID0gX2Eub25JZnJhbWVMb2FkLCBpZnJhbWVMb2FkVGltZW91dCA9IF9hLmlmcmFtZUxvYWRUaW1lb3V0LCBfbCA9IF9hLmtlZXBJZnJhbWVTcmNGbiwga2VlcElmcmFtZVNyY0ZuID0gX2wgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9IDogX2wsIGRpc2FibGVSZW1vdGVDb250cm9sRm4gPSBfYS5kaXNhYmxlUmVtb3RlQ29udHJvbEZuO1xyXG4gICAgdmFyIGlkTm9kZU1hcCA9IHt9O1xyXG4gICAgdmFyIG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxyXG4gICAgICAgICAgICBlbWFpbDogdHJ1ZSxcclxuICAgICAgICAgICAgbW9udGg6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWJlcjogdHJ1ZSxcclxuICAgICAgICAgICAgcmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIHNlYXJjaDogdHJ1ZSxcclxuICAgICAgICAgICAgdGVsOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICB0aW1lOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmw6IHRydWUsXHJcbiAgICAgICAgICAgIHdlZWs6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHRhcmVhOiB0cnVlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogbWFza0FsbElucHV0cyA9PT0gZmFsc2VcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogbWFza0FsbElucHV0cztcclxuICAgIHZhciBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gJ2FsbCdcclxuICAgICAgICA/XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNjcmlwdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHNsaW1ET00gPT09ICdhbGwnLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIDogc2xpbURPTSA9PT0gZmFsc2VcclxuICAgICAgICAgICAgPyB7fVxyXG4gICAgICAgICAgICA6IHNsaW1ET007XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgICAgICBkb2M6IG4sXHJcbiAgICAgICAgICAgIG1hcDogaWROb2RlTWFwLFxyXG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZTogcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxyXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dDogaWZyYW1lTG9hZFRpbWVvdXQsXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICBkaXNhYmxlUmVtb3RlQ29udHJvbEZuOiBkaXNhYmxlUmVtb3RlQ29udHJvbEZuXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaWROb2RlTWFwLFxyXG4gICAgXTtcclxufVxyXG5mdW5jdGlvbiBfaXNEaXNhYmxlUmVtb3RlQ29udHJvbEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgdmFyIGRpc2FibGVDbGFzcyA9ICdjb3NlZS1kaXNhYmxlLXJlbW90ZS1jb250cm9sJztcclxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhkaXNhYmxlQ2xhc3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxudmFyIGNvbW1lbnRyZSA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9nO1xyXG5mdW5jdGlvbiBwYXJzZShjc3MsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgbGluZW5vID0gMTtcclxuICAgIHZhciBjb2x1bW4gPSAxO1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oc3RyKSB7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gc3RyLm1hdGNoKC9cXG4vZyk7XHJcbiAgICAgICAgaWYgKGxpbmVzKSB7XHJcbiAgICAgICAgICAgIGxpbmVubyArPSBsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gc3RyLmxhc3RJbmRleE9mKCdcXG4nKTtcclxuICAgICAgICBjb2x1bW4gPSBpID09PSAtMSA/IGNvbHVtbiArIHN0ci5sZW5ndGggOiBzdHIubGVuZ3RoIC0gaTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHsgbGluZTogbGluZW5vLCBjb2x1bW46IGNvbHVtbiB9O1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHN0YXJ0KTtcclxuICAgICAgICAgICAgd2hpdGVzcGFjZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIFBvc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBQb3NpdGlvbihzdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0geyBsaW5lOiBsaW5lbm8sIGNvbHVtbjogY29sdW1uIH07XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQb3NpdGlvbjtcclxuICAgIH0oKSk7XHJcbiAgICBQb3NpdGlvbi5wcm90b3R5cGUuY29udGVudCA9IGNzcztcclxuICAgIHZhciBlcnJvcnNMaXN0ID0gW107XHJcbiAgICBmdW5jdGlvbiBlcnJvcihtc2cpIHtcclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKG9wdGlvbnMuc291cmNlICsgJzonICsgbGluZW5vICsgJzonICsgY29sdW1uICsgJzogJyArIG1zZyk7XHJcbiAgICAgICAgZXJyLnJlYXNvbiA9IG1zZztcclxuICAgICAgICBlcnIuZmlsZW5hbWUgPSBvcHRpb25zLnNvdXJjZTtcclxuICAgICAgICBlcnIubGluZSA9IGxpbmVubztcclxuICAgICAgICBlcnIuY29sdW1uID0gY29sdW1uO1xyXG4gICAgICAgIGVyci5zb3VyY2UgPSBjc3M7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lsZW50KSB7XHJcbiAgICAgICAgICAgIGVycm9yc0xpc3QucHVzaChlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN0eWxlc2hlZXQoKSB7XHJcbiAgICAgICAgdmFyIHJ1bGVzTGlzdCA9IHJ1bGVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ3N0eWxlc2hlZXQnLFxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0OiB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzTGlzdCxcclxuICAgICAgICAgICAgICAgIHBhcnNpbmdFcnJvcnM6IGVycm9yc0xpc3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvcGVuKCkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaCgvXntcXHMqLyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2goL159Lyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBydWxlcygpIHtcclxuICAgICAgICB2YXIgbm9kZTtcclxuICAgICAgICB2YXIgcnVsZXMgPSBbXTtcclxuICAgICAgICB3aGl0ZXNwYWNlKCk7XHJcbiAgICAgICAgY29tbWVudHMocnVsZXMpO1xyXG4gICAgICAgIHdoaWxlIChjc3MubGVuZ3RoICYmIGNzcy5jaGFyQXQoMCkgIT09ICd9JyAmJiAobm9kZSA9IGF0cnVsZSgpIHx8IHJ1bGUoKSkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY29tbWVudHMocnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBydWxlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hdGNoKHJlKSB7XHJcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKGNzcyk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0ciA9IG1bMF07XHJcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oc3RyKTtcclxuICAgICAgICBjc3MgPSBjc3Muc2xpY2Uoc3RyLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3aGl0ZXNwYWNlKCkge1xyXG4gICAgICAgIG1hdGNoKC9eXFxzKi8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tbWVudHMocnVsZXMpIHtcclxuICAgICAgICBpZiAocnVsZXMgPT09IHZvaWQgMCkgeyBydWxlcyA9IFtdOyB9XHJcbiAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgd2hpbGUgKChjID0gY29tbWVudCgpKSkge1xyXG4gICAgICAgICAgICBpZiAoYyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2goYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYyA9IGNvbW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tbWVudCgpIHtcclxuICAgICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcclxuICAgICAgICBpZiAoJy8nICE9PSBjc3MuY2hhckF0KDApIHx8ICcqJyAhPT0gY3NzLmNoYXJBdCgxKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gMjtcclxuICAgICAgICB3aGlsZSAoJycgIT09IGNzcy5jaGFyQXQoaSkgJiZcclxuICAgICAgICAgICAgKCcqJyAhPT0gY3NzLmNoYXJBdChpKSB8fCAnLycgIT09IGNzcy5jaGFyQXQoaSArIDEpKSkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMjtcclxuICAgICAgICBpZiAoJycgPT09IGNzcy5jaGFyQXQoaSAtIDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcignRW5kIG9mIGNvbW1lbnQgbWlzc2luZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RyID0gY3NzLnNsaWNlKDIsIGkgLSAyKTtcclxuICAgICAgICBjb2x1bW4gKz0gMjtcclxuICAgICAgICB1cGRhdGVQb3NpdGlvbihzdHIpO1xyXG4gICAgICAgIGNzcyA9IGNzcy5zbGljZShpKTtcclxuICAgICAgICBjb2x1bW4gKz0gMjtcclxuICAgICAgICByZXR1cm4gcG9zKHtcclxuICAgICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxyXG4gICAgICAgICAgICBjb21tZW50OiBzdHJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yKCkge1xyXG4gICAgICAgIHZhciBtID0gbWF0Y2goL14oW157XSspLyk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyaW0obVswXSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKi9dfFtcXHJcXG5dKSkpKlxcKlxcLysvZywgJycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIig/OlxcXFxcInxbXlwiXSkqXCJ8Jyg/OlxcXFwnfFteJ10pKicvZywgZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucmVwbGFjZSgvLC9nLCAnXFx1MjAwQycpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zcGxpdCgvXFxzKig/IVteKF0qXFwpKSxcXHMqLylcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXHUyMDBDL2csICcsJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWNsYXJhdGlvbigpIHtcclxuICAgICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcclxuICAgICAgICB2YXIgcHJvcE1hdGNoID0gbWF0Y2goL14oXFwqP1stI1xcL1xcKlxcXFxcXHddKyhcXFtbMC05YS16Xy1dK1xcXSk/KVxccyovKTtcclxuICAgICAgICBpZiAoIXByb3BNYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wID0gdHJpbShwcm9wTWF0Y2hbMF0pO1xyXG4gICAgICAgIGlmICghbWF0Y2goL146XFxzKi8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihcInByb3BlcnR5IG1pc3NpbmcgJzonXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsID0gbWF0Y2goL14oKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXlxcKV0qP1xcKXxbXn07XSkrKS8pO1xyXG4gICAgICAgIHZhciByZXQgPSBwb3Moe1xyXG4gICAgICAgICAgICB0eXBlOiAnZGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eTogcHJvcC5yZXBsYWNlKGNvbW1lbnRyZSwgJycpLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsID8gdHJpbSh2YWxbMF0pLnJlcGxhY2UoY29tbWVudHJlLCAnJykgOiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1hdGNoKC9eWztcXHNdKi8pO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZWNsYXJhdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIGRlY2xzID0gW107XHJcbiAgICAgICAgaWYgKCFvcGVuKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKFwibWlzc2luZyAneydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbW1lbnRzKGRlY2xzKTtcclxuICAgICAgICB2YXIgZGVjbDtcclxuICAgICAgICB3aGlsZSAoKGRlY2wgPSBkZWNsYXJhdGlvbigpKSkge1xyXG4gICAgICAgICAgICBpZiAoZGVjbCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGRlY2xzLnB1c2goZGVjbCk7XHJcbiAgICAgICAgICAgICAgICBjb21tZW50cyhkZWNscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVjbCA9IGRlY2xhcmF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJtaXNzaW5nICd9J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlY2xzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24ga2V5ZnJhbWUoKSB7XHJcbiAgICAgICAgdmFyIG07XHJcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcclxuICAgICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcclxuICAgICAgICB3aGlsZSAoKG0gPSBtYXRjaCgvXigoXFxkK1xcLlxcZCt8XFwuXFxkK3xcXGQrKSU/fFthLXpdKylcXHMqLykpKSB7XHJcbiAgICAgICAgICAgIHZhbHMucHVzaChtWzFdKTtcclxuICAgICAgICAgICAgbWF0Y2goL14sXFxzKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcyh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdrZXlmcmFtZScsXHJcbiAgICAgICAgICAgIHZhbHVlczogdmFscyxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXRrZXlmcmFtZXMoKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XHJcbiAgICAgICAgdmFyIG0gPSBtYXRjaCgvXkAoWy1cXHddKyk/a2V5ZnJhbWVzXFxzKi8pO1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZW5kb3IgPSBtWzFdO1xyXG4gICAgICAgIG0gPSBtYXRjaCgvXihbLVxcd10rKVxccyovKTtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdAa2V5ZnJhbWVzIG1pc3NpbmcgbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmFtZSA9IG1bMV07XHJcbiAgICAgICAgaWYgKCFvcGVuKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKFwiQGtleWZyYW1lcyBtaXNzaW5nICd7J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZyYW1lO1xyXG4gICAgICAgIHZhciBmcmFtZXMgPSBjb21tZW50cygpO1xyXG4gICAgICAgIHdoaWxlICgoZnJhbWUgPSBrZXlmcmFtZSgpKSkge1xyXG4gICAgICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XHJcbiAgICAgICAgICAgIGZyYW1lcyA9IGZyYW1lcy5jb25jYXQoY29tbWVudHMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAa2V5ZnJhbWVzIG1pc3NpbmcgJ30nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zKHtcclxuICAgICAgICAgICAgdHlwZTogJ2tleWZyYW1lcycsXHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIHZlbmRvcjogdmVuZG9yLFxyXG4gICAgICAgICAgICBrZXlmcmFtZXM6IGZyYW1lc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXRzdXBwb3J0cygpIHtcclxuICAgICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcclxuICAgICAgICB2YXIgbSA9IG1hdGNoKC9eQHN1cHBvcnRzICooW157XSspLyk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzID0gdHJpbShtWzFdKTtcclxuICAgICAgICBpZiAoIW9wZW4oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAc3VwcG9ydHMgbWlzc2luZyAneydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IGNvbW1lbnRzKCkuY29uY2F0KHJ1bGVzKCkpO1xyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAc3VwcG9ydHMgbWlzc2luZyAnfSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3Moe1xyXG4gICAgICAgICAgICB0eXBlOiAnc3VwcG9ydHMnLFxyXG4gICAgICAgICAgICBzdXBwb3J0czogc3VwcG9ydHMsXHJcbiAgICAgICAgICAgIHJ1bGVzOiBzdHlsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXRob3N0KCkge1xyXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBtID0gbWF0Y2goL15AaG9zdFxccyovKTtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9wZW4oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAaG9zdCBtaXNzaW5nICd7J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0eWxlID0gY29tbWVudHMoKS5jb25jYXQocnVsZXMoKSk7XHJcbiAgICAgICAgaWYgKCFjbG9zZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihcIkBob3N0IG1pc3NpbmcgJ30nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zKHtcclxuICAgICAgICAgICAgdHlwZTogJ2hvc3QnLFxyXG4gICAgICAgICAgICBydWxlczogc3R5bGVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0bWVkaWEoKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XHJcbiAgICAgICAgdmFyIG0gPSBtYXRjaCgvXkBtZWRpYSAqKFtee10rKS8pO1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtZWRpYSA9IHRyaW0obVsxXSk7XHJcbiAgICAgICAgaWYgKCFvcGVuKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKFwiQG1lZGlhIG1pc3NpbmcgJ3snXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3R5bGUgPSBjb21tZW50cygpLmNvbmNhdChydWxlcygpKTtcclxuICAgICAgICBpZiAoIWNsb3NlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKFwiQG1lZGlhIG1pc3NpbmcgJ30nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zKHtcclxuICAgICAgICAgICAgdHlwZTogJ21lZGlhJyxcclxuICAgICAgICAgICAgbWVkaWE6IG1lZGlhLFxyXG4gICAgICAgICAgICBydWxlczogc3R5bGVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0Y3VzdG9tbWVkaWEoKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XHJcbiAgICAgICAgdmFyIG0gPSBtYXRjaCgvXkBjdXN0b20tbWVkaWFcXHMrKC0tW15cXHNdKylcXHMqKFteeztdKyk7Lyk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcyh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdjdXN0b20tbWVkaWEnLFxyXG4gICAgICAgICAgICBuYW1lOiB0cmltKG1bMV0pLFxyXG4gICAgICAgICAgICBtZWRpYTogdHJpbShtWzJdKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXRwYWdlKCkge1xyXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBtID0gbWF0Y2goL15AcGFnZSAqLyk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbCA9IHNlbGVjdG9yKCkgfHwgW107XHJcbiAgICAgICAgaWYgKCFvcGVuKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKFwiQHBhZ2UgbWlzc2luZyAneydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWNscyA9IGNvbW1lbnRzKCk7XHJcbiAgICAgICAgdmFyIGRlY2w7XHJcbiAgICAgICAgd2hpbGUgKChkZWNsID0gZGVjbGFyYXRpb24oKSkpIHtcclxuICAgICAgICAgICAgZGVjbHMucHVzaChkZWNsKTtcclxuICAgICAgICAgICAgZGVjbHMgPSBkZWNscy5jb25jYXQoY29tbWVudHMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAcGFnZSBtaXNzaW5nICd9J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcyh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdwYWdlJyxcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWwsXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbHNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGF0ZG9jdW1lbnQoKSB7XHJcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uKCk7XHJcbiAgICAgICAgdmFyIG0gPSBtYXRjaCgvXkAoWy1cXHddKyk/ZG9jdW1lbnQgKihbXntdKykvKTtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVuZG9yID0gdHJpbShtWzFdKTtcclxuICAgICAgICB2YXIgZG9jID0gdHJpbShtWzJdKTtcclxuICAgICAgICBpZiAoIW9wZW4oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAZG9jdW1lbnQgbWlzc2luZyAneydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IGNvbW1lbnRzKCkuY29uY2F0KHJ1bGVzKCkpO1xyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAZG9jdW1lbnQgbWlzc2luZyAnfSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3Moe1xyXG4gICAgICAgICAgICB0eXBlOiAnZG9jdW1lbnQnLFxyXG4gICAgICAgICAgICBkb2N1bWVudDogZG9jLFxyXG4gICAgICAgICAgICB2ZW5kb3I6IHZlbmRvcixcclxuICAgICAgICAgICAgcnVsZXM6IHN0eWxlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhdGZvbnRmYWNlKCkge1xyXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBtID0gbWF0Y2goL15AZm9udC1mYWNlXFxzKi8pO1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb3BlbigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihcIkBmb250LWZhY2UgbWlzc2luZyAneydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWNscyA9IGNvbW1lbnRzKCk7XHJcbiAgICAgICAgdmFyIGRlY2w7XHJcbiAgICAgICAgd2hpbGUgKChkZWNsID0gZGVjbGFyYXRpb24oKSkpIHtcclxuICAgICAgICAgICAgZGVjbHMucHVzaChkZWNsKTtcclxuICAgICAgICAgICAgZGVjbHMgPSBkZWNscy5jb25jYXQoY29tbWVudHMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2xvc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IoXCJAZm9udC1mYWNlIG1pc3NpbmcgJ30nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zKHtcclxuICAgICAgICAgICAgdHlwZTogJ2ZvbnQtZmFjZScsXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbHNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBhdGltcG9ydCA9IF9jb21waWxlQXRydWxlKCdpbXBvcnQnKTtcclxuICAgIHZhciBhdGNoYXJzZXQgPSBfY29tcGlsZUF0cnVsZSgnY2hhcnNldCcpO1xyXG4gICAgdmFyIGF0bmFtZXNwYWNlID0gX2NvbXBpbGVBdHJ1bGUoJ25hbWVzcGFjZScpO1xyXG4gICAgZnVuY3Rpb24gX2NvbXBpbGVBdHJ1bGUobmFtZSkge1xyXG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ15AJyArIG5hbWUgKyAnXFxcXHMqKFteO10rKTsnKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gcG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIG0gPSBtYXRjaChyZSk7XHJcbiAgICAgICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXQgPSB7IHR5cGU6IG5hbWUgfTtcclxuICAgICAgICAgICAgcmV0W25hbWVdID0gbVsxXS50cmltKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3MocmV0KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXRydWxlKCkge1xyXG4gICAgICAgIGlmIChjc3NbMF0gIT09ICdAJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoYXRrZXlmcmFtZXMoKSB8fFxyXG4gICAgICAgICAgICBhdG1lZGlhKCkgfHxcclxuICAgICAgICAgICAgYXRjdXN0b21tZWRpYSgpIHx8XHJcbiAgICAgICAgICAgIGF0c3VwcG9ydHMoKSB8fFxyXG4gICAgICAgICAgICBhdGltcG9ydCgpIHx8XHJcbiAgICAgICAgICAgIGF0Y2hhcnNldCgpIHx8XHJcbiAgICAgICAgICAgIGF0bmFtZXNwYWNlKCkgfHxcclxuICAgICAgICAgICAgYXRkb2N1bWVudCgpIHx8XHJcbiAgICAgICAgICAgIGF0cGFnZSgpIHx8XHJcbiAgICAgICAgICAgIGF0aG9zdCgpIHx8XHJcbiAgICAgICAgICAgIGF0Zm9udGZhY2UoKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBydWxlKCkge1xyXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBzZWwgPSBzZWxlY3RvcigpO1xyXG4gICAgICAgIGlmICghc2VsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcignc2VsZWN0b3IgbWlzc2luZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21tZW50cygpO1xyXG4gICAgICAgIHJldHVybiBwb3Moe1xyXG4gICAgICAgICAgICB0eXBlOiAncnVsZScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczogc2VsLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGRlY2xhcmF0aW9ucygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRkUGFyZW50KHN0eWxlc2hlZXQoKSk7XHJcbn1cclxuZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuICAgIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gYWRkUGFyZW50KG9iaiwgcGFyZW50KSB7XHJcbiAgICB2YXIgaXNOb2RlID0gb2JqICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZyc7XHJcbiAgICB2YXIgY2hpbGRQYXJlbnQgPSBpc05vZGUgPyBvYmogOiBwYXJlbnQ7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMob2JqKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgayA9IF9hW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba107XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGFkZFBhcmVudCh2LCBjaGlsZFBhcmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGFkZFBhcmVudCh2YWx1ZSwgY2hpbGRQYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc05vZGUpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAncGFyZW50Jywge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgdmFsdWU6IHBhcmVudCB8fCBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XG5cbnZhciB0YWdNYXAgPSB7XHJcbiAgICBzY3JpcHQ6ICdub3NjcmlwdCcsXHJcbiAgICBhbHRnbHlwaDogJ2FsdEdseXBoJyxcclxuICAgIGFsdGdseXBoZGVmOiAnYWx0R2x5cGhEZWYnLFxyXG4gICAgYWx0Z2x5cGhpdGVtOiAnYWx0R2x5cGhJdGVtJyxcclxuICAgIGFuaW1hdGVjb2xvcjogJ2FuaW1hdGVDb2xvcicsXHJcbiAgICBhbmltYXRlbW90aW9uOiAnYW5pbWF0ZU1vdGlvbicsXHJcbiAgICBhbmltYXRldHJhbnNmb3JtOiAnYW5pbWF0ZVRyYW5zZm9ybScsXHJcbiAgICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcclxuICAgIGZlYmxlbmQ6ICdmZUJsZW5kJyxcclxuICAgIGZlY29sb3JtYXRyaXg6ICdmZUNvbG9yTWF0cml4JyxcclxuICAgIGZlY29tcG9uZW50dHJhbnNmZXI6ICdmZUNvbXBvbmVudFRyYW5zZmVyJyxcclxuICAgIGZlY29tcG9zaXRlOiAnZmVDb21wb3NpdGUnLFxyXG4gICAgZmVjb252b2x2ZW1hdHJpeDogJ2ZlQ29udm9sdmVNYXRyaXgnLFxyXG4gICAgZmVkaWZmdXNlbGlnaHRpbmc6ICdmZURpZmZ1c2VMaWdodGluZycsXHJcbiAgICBmZWRpc3BsYWNlbWVudG1hcDogJ2ZlRGlzcGxhY2VtZW50TWFwJyxcclxuICAgIGZlZGlzdGFudGxpZ2h0OiAnZmVEaXN0YW50TGlnaHQnLFxyXG4gICAgZmVkcm9wc2hhZG93OiAnZmVEcm9wU2hhZG93JyxcclxuICAgIGZlZmxvb2Q6ICdmZUZsb29kJyxcclxuICAgIGZlZnVuY2E6ICdmZUZ1bmNBJyxcclxuICAgIGZlZnVuY2I6ICdmZUZ1bmNCJyxcclxuICAgIGZlZnVuY2c6ICdmZUZ1bmNHJyxcclxuICAgIGZlZnVuY3I6ICdmZUZ1bmNSJyxcclxuICAgIGZlZ2F1c3NpYW5ibHVyOiAnZmVHYXVzc2lhbkJsdXInLFxyXG4gICAgZmVpbWFnZTogJ2ZlSW1hZ2UnLFxyXG4gICAgZmVtZXJnZTogJ2ZlTWVyZ2UnLFxyXG4gICAgZmVtZXJnZW5vZGU6ICdmZU1lcmdlTm9kZScsXHJcbiAgICBmZW1vcnBob2xvZ3k6ICdmZU1vcnBob2xvZ3knLFxyXG4gICAgZmVvZmZzZXQ6ICdmZU9mZnNldCcsXHJcbiAgICBmZXBvaW50bGlnaHQ6ICdmZVBvaW50TGlnaHQnLFxyXG4gICAgZmVzcGVjdWxhcmxpZ2h0aW5nOiAnZmVTcGVjdWxhckxpZ2h0aW5nJyxcclxuICAgIGZlc3BvdGxpZ2h0OiAnZmVTcG90TGlnaHQnLFxyXG4gICAgZmV0aWxlOiAnZmVUaWxlJyxcclxuICAgIGZldHVyYnVsZW5jZTogJ2ZlVHVyYnVsZW5jZScsXHJcbiAgICBmb3JlaWdub2JqZWN0OiAnZm9yZWlnbk9iamVjdCcsXHJcbiAgICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcclxuICAgIGxpbmVhcmdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxyXG4gICAgcmFkaWFsZ3JhZGllbnQ6ICdyYWRpYWxHcmFkaWVudCdcclxufTtcclxuZnVuY3Rpb24gZ2V0VGFnTmFtZShuKSB7XHJcbiAgICB2YXIgdGFnTmFtZSA9IHRhZ01hcFtuLnRhZ05hbWVdID8gdGFnTWFwW24udGFnTmFtZV0gOiBuLnRhZ05hbWU7XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2xpbmsnICYmIG4uYXR0cmlidXRlcy5fY3NzVGV4dCkge1xyXG4gICAgICAgIHRhZ05hbWUgPSAnc3R5bGUnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhZ05hbWU7XHJcbn1cclxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xyXG59XHJcbnZhciBIT1ZFUl9TRUxFQ1RPUiA9IC8oW15cXFxcXSk6aG92ZXIvO1xyXG52YXIgSE9WRVJfU0VMRUNUT1JfR0xPQkFMID0gbmV3IFJlZ0V4cChIT1ZFUl9TRUxFQ1RPUi5zb3VyY2UsICdnJyk7XHJcbmZ1bmN0aW9uIGFkZEhvdmVyQ2xhc3MoY3NzVGV4dCwgY2FjaGUpIHtcclxuICAgIHZhciBjYWNoZWRTdHlsZSA9IGNhY2hlID09PSBudWxsIHx8IGNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZS5zdHlsZXNXaXRoSG92ZXJDbGFzcy5nZXQoY3NzVGV4dCk7XHJcbiAgICBpZiAoY2FjaGVkU3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFN0eWxlO1xyXG4gICAgdmFyIGFzdCA9IHBhcnNlKGNzc1RleHQsIHtcclxuICAgICAgICBzaWxlbnQ6IHRydWVcclxuICAgIH0pO1xyXG4gICAgaWYgKCFhc3Quc3R5bGVzaGVldCkge1xyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGVjdG9ycyA9IFtdO1xyXG4gICAgYXN0LnN0eWxlc2hlZXQucnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgIGlmICgnc2VsZWN0b3JzJyBpbiBydWxlKSB7XHJcbiAgICAgICAgICAgIChydWxlLnNlbGVjdG9ycyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChIT1ZFUl9TRUxFQ1RPUi50ZXN0KHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xyXG4gICAgfVxyXG4gICAgdmFyIHNlbGVjdG9yTWF0Y2hlciA9IG5ldyBSZWdFeHAoc2VsZWN0b3JzXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2VsZWN0b3IsIGluZGV4KSB7IHJldHVybiBzZWxlY3RvcnMuaW5kZXhPZihzZWxlY3RvcikgPT09IGluZGV4OyB9KVxyXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoOyB9KVxyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGVzY2FwZVJlZ0V4cChzZWxlY3Rvcik7XHJcbiAgICB9KVxyXG4gICAgICAgIC5qb2luKCd8JyksICdnJyk7XHJcbiAgICB2YXIgcmVzdWx0ID0gY3NzVGV4dC5yZXBsYWNlKHNlbGVjdG9yTWF0Y2hlciwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIG5ld1NlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShIT1ZFUl9TRUxFQ1RPUl9HTE9CQUwsICckMS5cXFxcOmhvdmVyJyk7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yICsgXCIsIFwiICsgbmV3U2VsZWN0b3I7XHJcbiAgICB9KTtcclxuICAgIGNhY2hlID09PSBudWxsIHx8IGNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZS5zdHlsZXNXaXRoSG92ZXJDbGFzcy5zZXQoY3NzVGV4dCwgcmVzdWx0KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XHJcbiAgICB2YXIgc3R5bGVzV2l0aEhvdmVyQ2xhc3MgPSBuZXcgTWFwKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0eWxlc1dpdGhIb3ZlckNsYXNzOiBzdHlsZXNXaXRoSG92ZXJDbGFzc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBidWlsZE5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgdmFyIGRvYyA9IG9wdGlvbnMuZG9jLCBoYWNrQ3NzID0gb3B0aW9ucy5oYWNrQ3NzLCBjYWNoZSA9IG9wdGlvbnMuY2FjaGU7XHJcbiAgICBzd2l0Y2ggKG4udHlwZSkge1xyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRG9jdW1lbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiBkb2MuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQobnVsbCwgJycsIG51bGwpO1xyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRG9jdW1lbnRUeXBlOlxyXG4gICAgICAgICAgICByZXR1cm4gZG9jLmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZShuLm5hbWUgfHwgJ2h0bWwnLCBuLnB1YmxpY0lkLCBuLnN5c3RlbUlkKTtcclxuICAgICAgICBjYXNlIE5vZGVUeXBlLkVsZW1lbnQ6XHJcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gZ2V0VGFnTmFtZShuKTtcclxuICAgICAgICAgICAgdmFyIG5vZGVfMTtcclxuICAgICAgICAgICAgaWYgKG4uaXNTVkcpIHtcclxuICAgICAgICAgICAgICAgIG5vZGVfMSA9IGRvYy5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlXzEgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChuYW1lXzEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbi5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbi5hdHRyaWJ1dGVzW25hbWVfMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicgJiYgbmFtZV8xID09PSAnc2VsZWN0ZWQnICYmIHZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVfMS5zdGFydHNXaXRoKCdycl8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1RleHRhcmVhID0gdGFnTmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBuYW1lXzEgPT09ICd2YWx1ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVtb3RlT3JEeW5hbWljQ3NzID0gdGFnTmFtZSA9PT0gJ3N0eWxlJyAmJiBuYW1lXzEgPT09ICdfY3NzVGV4dCc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVtb3RlT3JEeW5hbWljQ3NzICYmIGhhY2tDc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhZGRIb3ZlckNsYXNzKHZhbHVlLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHRhcmVhIHx8IGlzUmVtb3RlT3JEeW5hbWljQ3NzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKG5vZGVfMS5jaGlsZE5vZGVzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMubm9kZVR5cGUgPT09IG5vZGVfMS5URVhUX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEucmVtb3ZlQ2hpbGQoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uaXNTVkcgJiYgbmFtZV8xID09PSAneGxpbms6aHJlZicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWVfMSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ29ubG9hZCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfMSA9PT0gJ29uY2xpY2snIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lXzEuc3Vic3RyaW5nKDAsIDcpID09PSAnb25tb3VzZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5zZXRBdHRyaWJ1dGUoJ18nICsgbmFtZV8xLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ21ldGEnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXSA9PT0gJ0NvbnRlbnQtU2VjdXJpdHktUG9saWN5JyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZV8xID09PSAnY29udGVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5zZXRBdHRyaWJ1dGUoJ2NzcC1jb250ZW50JywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWdOYW1lID09PSAnbGluaycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVsb2FkJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLmFzID09PSAnc2NyaXB0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3ByZWZldGNoJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG4uYXR0cmlidXRlcy5ocmVmID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5hdHRyaWJ1dGVzLmhyZWYuZW5kc1dpdGgoJy5qcycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ2ltZycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy5zcmNzZXQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4uYXR0cmlidXRlcy5ycl9kYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEuc2V0QXR0cmlidXRlKCdycndlYi1vcmlnaW5hbC1zcmNzZXQnLCBuLmF0dHJpYnV0ZXMuc3Jjc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5zZXRBdHRyaWJ1dGUobmFtZV8xLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdjYW52YXMnICYmIG5hbWVfMSA9PT0gJ3JyX2RhdGFVUkwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZV8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXzEuc3JjID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXzEub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IG5vZGVfMS5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2VfMSwgMCwgMCwgaW1hZ2VfMS53aWR0aCwgaW1hZ2VfMS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWdOYW1lID09PSAnaW1nJyAmJiBuYW1lXzEgPT09ICdycl9kYXRhVVJMJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBub2RlXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UuY3VycmVudFNyYy5zdGFydHNXaXRoKCdkYXRhOicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3Jyd2ViLW9yaWdpbmFsLXNyYycsIG4uYXR0cmlidXRlcy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVfMSA9PT0gJ3JyX3dpZHRoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEuc3R5bGUud2lkdGggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZV8xID09PSAncnJfaGVpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEuc3R5bGUuaGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ3JyX21lZGlhQ3VycmVudFRpbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5jdXJyZW50VGltZSA9IG4uYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJyX21lZGlhQ3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ3JyX21lZGlhU3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BsYXllZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wbGF5KClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkgeyByZXR1cm4gY29uc29sZS53YXJuKCdtZWRpYSBwbGF5YmFjayBlcnJvcicsIGUpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhdXNlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZV8xID09PSAncnJfZGlzcGxheScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZV8xID09PSAncnJfYmFja2dyb3VuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLnN0eWxlLmJhY2tncm91bmQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZV8xID09PSAncnJfYmFja2dyb3VuZF9pbWFnZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlXzEuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9ICduby1yZXBlYXQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIG4uYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShuYW1lXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuLmlzU2hhZG93SG9zdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlXzEuc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVfMS5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhdHRhY2hTaGFkb3cgZXJyb3IgOiAnLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGVfMS5zaGFkb3dSb290LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xLnNoYWRvd1Jvb3QucmVtb3ZlQ2hpbGQobm9kZV8xLnNoYWRvd1Jvb3QuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlXzE7XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5UZXh0OlxyXG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKG4uaXNTdHlsZSAmJiBoYWNrQ3NzXHJcbiAgICAgICAgICAgICAgICA/IGFkZEhvdmVyQ2xhc3Mobi50ZXh0Q29udGVudCwgY2FjaGUpXHJcbiAgICAgICAgICAgICAgICA6IG4udGV4dENvbnRlbnQpO1xyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuQ0RBVEE6XHJcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlQ0RBVEFTZWN0aW9uKG4udGV4dENvbnRlbnQpO1xyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuQ29tbWVudDpcclxuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVDb21tZW50KG4udGV4dENvbnRlbnQpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkTm9kZVdpdGhTTihuLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIG1hcCA9IG9wdGlvbnMubWFwLCBfYSA9IG9wdGlvbnMuc2tpcENoaWxkLCBza2lwQ2hpbGQgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLmhhY2tDc3MsIGhhY2tDc3MgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBhZnRlckFwcGVuZCA9IG9wdGlvbnMuYWZ0ZXJBcHBlbmQsIGNhY2hlID0gb3B0aW9ucy5jYWNoZTtcclxuICAgIHZhciBub2RlID0gYnVpbGROb2RlKG4sIHsgZG9jOiBkb2MsIGhhY2tDc3M6IGhhY2tDc3MsIGNhY2hlOiBjYWNoZSB9KTtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKG4ucm9vdElkKSB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQobWFwW24ucm9vdElkXSA9PT0gZG9jLCAnVGFyZ2V0IGRvY3VtZW50IHNob3VsZCBoYXMgdGhlIHNhbWUgcm9vdCBpZC4nKTtcclxuICAgIH1cclxuICAgIGlmIChuLnR5cGUgPT09IE5vZGVUeXBlLkRvY3VtZW50KSB7XHJcbiAgICAgICAgZG9jLmNsb3NlKCk7XHJcbiAgICAgICAgZG9jLm9wZW4oKTtcclxuICAgICAgICBpZiAobi5jb21wYXRNb2RlID09PSAnQmFja0NvbXBhdCcgJiZcclxuICAgICAgICAgICAgbi5jaGlsZE5vZGVzICYmXHJcbiAgICAgICAgICAgIG4uY2hpbGROb2Rlc1swXS50eXBlICE9PSBOb2RlVHlwZS5Eb2N1bWVudFR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKG4uY2hpbGROb2Rlc1swXS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAneG1sbnMnIGluIG4uY2hpbGROb2Rlc1swXS5hdHRyaWJ1dGVzICYmXHJcbiAgICAgICAgICAgICAgICBuLmNoaWxkTm9kZXNbMF0uYXR0cmlidXRlcy54bWxucyA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnKSB7XHJcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoJzwhRE9DVFlQRSBodG1sIFBVQkxJQyBcIi0vL1czQy8vRFREIFhIVE1MIDEuMCBUcmFuc2l0aW9uYWwvL0VOXCIgXCJcIj4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvYy53cml0ZSgnPCFET0NUWVBFIGh0bWwgUFVCTElDIFwiLS8vVzNDLy9EVEQgSFRNTCA0LjAgVHJhbnNpdGlvbmFsLy9FTlwiIFwiXCI+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IGRvYztcclxuICAgIH1cclxuICAgIG5vZGUuX19zbiA9IG47XHJcbiAgICBtYXBbbi5pZF0gPSBub2RlO1xyXG4gICAgaWYgKChuLnR5cGUgPT09IE5vZGVUeXBlLkRvY3VtZW50IHx8IG4udHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkgJiZcclxuICAgICAgICAhc2tpcENoaWxkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IG4uY2hpbGROb2RlczsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTiA9IF9jW19pXTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGJ1aWxkTm9kZVdpdGhTTihjaGlsZE4sIHtcclxuICAgICAgICAgICAgICAgIGRvYzogZG9jLFxyXG4gICAgICAgICAgICAgICAgbWFwOiBtYXAsXHJcbiAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaGFja0NzczogaGFja0NzcyxcclxuICAgICAgICAgICAgICAgIGFmdGVyQXBwZW5kOiBhZnRlckFwcGVuZCxcclxuICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlYnVpbGQnLCBjaGlsZE4pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoaWxkTi5pc1NoYWRvdyAmJiBpc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWZ0ZXJBcHBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGFmdGVyQXBwZW5kKGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiB2aXNpdChpZE5vZGVNYXAsIG9uVmlzaXQpIHtcclxuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xyXG4gICAgICAgIG9uVmlzaXQobm9kZSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gaWROb2RlTWFwKSB7XHJcbiAgICAgICAgaWYgKGlkTm9kZU1hcFtrZXldKSB7XHJcbiAgICAgICAgICAgIHdhbGsoaWROb2RlTWFwW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwobm9kZSkge1xyXG4gICAgdmFyIG4gPSBub2RlLl9fc247XHJcbiAgICBpZiAobi50eXBlICE9PSBOb2RlVHlwZS5FbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGVsID0gbm9kZTtcclxuICAgIGZvciAodmFyIG5hbWVfMiBpbiBuLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBpZiAoIShuLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZV8yKSAmJiBuYW1lXzIuc3RhcnRzV2l0aCgncnJfJykpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBuLmF0dHJpYnV0ZXNbbmFtZV8yXTtcclxuICAgICAgICBpZiAobmFtZV8yID09PSAncnJfc2Nyb2xsTGVmdCcpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFtZV8yID09PSAncnJfc2Nyb2xsVG9wJykge1xyXG4gICAgICAgICAgICBlbC5zY3JvbGxUb3AgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVidWlsZChuLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZG9jID0gb3B0aW9ucy5kb2MsIG9uVmlzaXQgPSBvcHRpb25zLm9uVmlzaXQsIF9hID0gb3B0aW9ucy5oYWNrQ3NzLCBoYWNrQ3NzID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYSwgYWZ0ZXJBcHBlbmQgPSBvcHRpb25zLmFmdGVyQXBwZW5kLCBjYWNoZSA9IG9wdGlvbnMuY2FjaGU7XHJcbiAgICB2YXIgaWROb2RlTWFwID0ge307XHJcbiAgICB2YXIgbm9kZSA9IGJ1aWxkTm9kZVdpdGhTTihuLCB7XHJcbiAgICAgICAgZG9jOiBkb2MsXHJcbiAgICAgICAgbWFwOiBpZE5vZGVNYXAsXHJcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcclxuICAgICAgICBoYWNrQ3NzOiBoYWNrQ3NzLFxyXG4gICAgICAgIGFmdGVyQXBwZW5kOiBhZnRlckFwcGVuZCxcclxuICAgICAgICBjYWNoZTogY2FjaGVcclxuICAgIH0pO1xyXG4gICAgdmlzaXQoaWROb2RlTWFwLCBmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcclxuICAgICAgICBpZiAob25WaXNpdCkge1xyXG4gICAgICAgICAgICBvblZpc2l0KHZpc2l0ZWROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlU2Nyb2xsKHZpc2l0ZWROb2RlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFtub2RlLCBpZE5vZGVNYXBdO1xyXG59XG5cbmV4cG9ydHMuRXZlbnRUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkRvbUNvbnRlbnRMb2FkZWRcIl0gPSAwXSA9IFwiRG9tQ29udGVudExvYWRlZFwiO1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkxvYWRcIl0gPSAxXSA9IFwiTG9hZFwiO1xyXG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIkZ1bGxTbmFwc2hvdFwiXSA9IDJdID0gXCJGdWxsU25hcHNob3RcIjtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJJbmNyZW1lbnRhbFNuYXBzaG90XCJdID0gM10gPSBcIkluY3JlbWVudGFsU25hcHNob3RcIjtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJNZXRhXCJdID0gNF0gPSBcIk1ldGFcIjtcclxuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJDdXN0b21cIl0gPSA1XSA9IFwiQ3VzdG9tXCI7XHJcbiAgICBFdmVudFR5cGVbRXZlbnRUeXBlW1wiUGx1Z2luXCJdID0gNl0gPSBcIlBsdWdpblwiO1xyXG59KShleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xyXG5leHBvcnRzLkluY3JlbWVudGFsU291cmNlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEluY3JlbWVudGFsU291cmNlKSB7XHJcbiAgICBJbmNyZW1lbnRhbFNvdXJjZVtJbmNyZW1lbnRhbFNvdXJjZVtcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XHJcbiAgICBJbmNyZW1lbnRhbFNvdXJjZVtJbmNyZW1lbnRhbFNvdXJjZVtcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IDJdID0gXCJNb3VzZUludGVyYWN0aW9uXCI7XHJcbiAgICBJbmNyZW1lbnRhbFNvdXJjZVtJbmNyZW1lbnRhbFNvdXJjZVtcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiSW5wdXRcIl0gPSA1XSA9IFwiSW5wdXRcIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xyXG4gICAgSW5jcmVtZW50YWxTb3VyY2VbSW5jcmVtZW50YWxTb3VyY2VbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiU3R5bGVTaGVldFJ1bGVcIl0gPSA4XSA9IFwiU3R5bGVTaGVldFJ1bGVcIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcclxuICAgIEluY3JlbWVudGFsU291cmNlW0luY3JlbWVudGFsU291cmNlW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xyXG4gICAgSW5jcmVtZW50YWxTb3VyY2VbSW5jcmVtZW50YWxTb3VyY2VbXCJMb2dcIl0gPSAxMV0gPSBcIkxvZ1wiO1xyXG4gICAgSW5jcmVtZW50YWxTb3VyY2VbSW5jcmVtZW50YWxTb3VyY2VbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XHJcbiAgICBJbmNyZW1lbnRhbFNvdXJjZVtJbmNyZW1lbnRhbFNvdXJjZVtcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcclxufSkoZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZSB8fCAoZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZSA9IHt9KSk7XHJcbmV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTW91c2VJbnRlcmFjdGlvbnMpIHtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiTW91c2VVcFwiXSA9IDBdID0gXCJNb3VzZVVwXCI7XHJcbiAgICBNb3VzZUludGVyYWN0aW9uc1tNb3VzZUludGVyYWN0aW9uc1tcIk1vdXNlRG93blwiXSA9IDFdID0gXCJNb3VzZURvd25cIjtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiQ29udGV4dE1lbnVcIl0gPSAzXSA9IFwiQ29udGV4dE1lbnVcIjtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiRGJsQ2xpY2tcIl0gPSA0XSA9IFwiRGJsQ2xpY2tcIjtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiRm9jdXNcIl0gPSA1XSA9IFwiRm9jdXNcIjtcclxuICAgIE1vdXNlSW50ZXJhY3Rpb25zW01vdXNlSW50ZXJhY3Rpb25zW1wiQmx1clwiXSA9IDZdID0gXCJCbHVyXCI7XHJcbiAgICBNb3VzZUludGVyYWN0aW9uc1tNb3VzZUludGVyYWN0aW9uc1tcIlRvdWNoU3RhcnRcIl0gPSA3XSA9IFwiVG91Y2hTdGFydFwiO1xyXG4gICAgTW91c2VJbnRlcmFjdGlvbnNbTW91c2VJbnRlcmFjdGlvbnNbXCJUb3VjaE1vdmVfRGVwYXJ0ZWRcIl0gPSA4XSA9IFwiVG91Y2hNb3ZlX0RlcGFydGVkXCI7XHJcbiAgICBNb3VzZUludGVyYWN0aW9uc1tNb3VzZUludGVyYWN0aW9uc1tcIlRvdWNoRW5kXCJdID0gOV0gPSBcIlRvdWNoRW5kXCI7XHJcbiAgICBNb3VzZUludGVyYWN0aW9uc1tNb3VzZUludGVyYWN0aW9uc1tcIlRvdWNoQ2FuY2VsXCJdID0gMTBdID0gXCJUb3VjaENhbmNlbFwiO1xyXG59KShleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zIHx8IChleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zID0ge30pKTtcclxudmFyIENhbnZhc0NvbnRleHQ7XHJcbihmdW5jdGlvbiAoQ2FudmFzQ29udGV4dCkge1xyXG4gICAgQ2FudmFzQ29udGV4dFtDYW52YXNDb250ZXh0W1wiMkRcIl0gPSAwXSA9IFwiMkRcIjtcclxuICAgIENhbnZhc0NvbnRleHRbQ2FudmFzQ29udGV4dFtcIldlYkdMXCJdID0gMV0gPSBcIldlYkdMXCI7XHJcbiAgICBDYW52YXNDb250ZXh0W0NhbnZhc0NvbnRleHRbXCJXZWJHTDJcIl0gPSAyXSA9IFwiV2ViR0wyXCI7XHJcbn0pKENhbnZhc0NvbnRleHQgfHwgKENhbnZhc0NvbnRleHQgPSB7fSkpO1xyXG52YXIgTWVkaWFJbnRlcmFjdGlvbnM7XHJcbihmdW5jdGlvbiAoTWVkaWFJbnRlcmFjdGlvbnMpIHtcclxuICAgIE1lZGlhSW50ZXJhY3Rpb25zW01lZGlhSW50ZXJhY3Rpb25zW1wiUGxheVwiXSA9IDBdID0gXCJQbGF5XCI7XHJcbiAgICBNZWRpYUludGVyYWN0aW9uc1tNZWRpYUludGVyYWN0aW9uc1tcIlBhdXNlXCJdID0gMV0gPSBcIlBhdXNlXCI7XHJcbiAgICBNZWRpYUludGVyYWN0aW9uc1tNZWRpYUludGVyYWN0aW9uc1tcIlNlZWtlZFwiXSA9IDJdID0gXCJTZWVrZWRcIjtcclxuICAgIE1lZGlhSW50ZXJhY3Rpb25zW01lZGlhSW50ZXJhY3Rpb25zW1wiVm9sdW1lQ2hhbmdlXCJdID0gM10gPSBcIlZvbHVtZUNoYW5nZVwiO1xyXG59KShNZWRpYUludGVyYWN0aW9ucyB8fCAoTWVkaWFJbnRlcmFjdGlvbnMgPSB7fSkpO1xyXG5leHBvcnRzLlJlcGxheWVyRXZlbnRzID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKFJlcGxheWVyRXZlbnRzKSB7XHJcbiAgICBSZXBsYXllckV2ZW50c1tcIlN0YXJ0XCJdID0gXCJzdGFydFwiO1xyXG4gICAgUmVwbGF5ZXJFdmVudHNbXCJQYXVzZVwiXSA9IFwicGF1c2VcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiUmVzdW1lXCJdID0gXCJyZXN1bWVcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiUmVzaXplXCJdID0gXCJyZXNpemVcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiRmluaXNoXCJdID0gXCJmaW5pc2hcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiRnVsbHNuYXBzaG90UmVidWlsZGVkXCJdID0gXCJmdWxsc25hcHNob3QtcmVidWlsZGVkXCI7XHJcbiAgICBSZXBsYXllckV2ZW50c1tcIkxvYWRTdHlsZXNoZWV0U3RhcnRcIl0gPSBcImxvYWQtc3R5bGVzaGVldC1zdGFydFwiO1xyXG4gICAgUmVwbGF5ZXJFdmVudHNbXCJMb2FkU3R5bGVzaGVldEVuZFwiXSA9IFwibG9hZC1zdHlsZXNoZWV0LWVuZFwiO1xyXG4gICAgUmVwbGF5ZXJFdmVudHNbXCJTa2lwU3RhcnRcIl0gPSBcInNraXAtc3RhcnRcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiU2tpcEVuZFwiXSA9IFwic2tpcC1lbmRcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IFwibW91c2UtaW50ZXJhY3Rpb25cIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiRXZlbnRDYXN0XCJdID0gXCJldmVudC1jYXN0XCI7XHJcbiAgICBSZXBsYXllckV2ZW50c1tcIkN1c3RvbUV2ZW50XCJdID0gXCJjdXN0b20tZXZlbnRcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiRmx1c2hcIl0gPSBcImZsdXNoXCI7XHJcbiAgICBSZXBsYXllckV2ZW50c1tcIlN0YXRlQ2hhbmdlXCJdID0gXCJzdGF0ZS1jaGFuZ2VcIjtcclxuICAgIFJlcGxheWVyRXZlbnRzW1wiUGxheUJhY2tcIl0gPSBcInBsYXktYmFja1wiO1xyXG59KShleHBvcnRzLlJlcGxheWVyRXZlbnRzIHx8IChleHBvcnRzLlJlcGxheWVyRXZlbnRzID0ge30pKTtcblxuZnVuY3Rpb24gb24odHlwZSwgZm4sIHRhcmdldCkge1xyXG4gICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IGRvY3VtZW50OyB9XHJcbiAgICB2YXIgb3B0aW9ucyA9IHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogdHlwZSA9PT0gJ3Njcm9sbCcgPyB0cnVlIDogZmFsc2UgfTtcclxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7IH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYXA6IHt9LFxyXG4gICAgICAgIGdldElkOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZiAoIW4gfHwgIW4uX19zbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuLl9fc24uaWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwW2lkXSB8fCBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlTm9kZUZyb21NYXA6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpZCA9IG4uX19zbiAmJiBuLl9fc24uaWQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtpZF07XHJcbiAgICAgICAgICAgIGlmIChuLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICAgICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVOb2RlRnJvbU1hcChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KGlkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxudmFyIERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9ICdQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsJyArXHJcbiAgICAnXFxyXFxuJyArXHJcbiAgICAnbm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsJyArXHJcbiAgICAnXFxyXFxuJyArXHJcbiAgICAnb3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLic7XHJcbmV4cG9ydHMubWlycm9yID0ge1xyXG4gICAgbWFwOiB7fSxcclxuICAgIGdldElkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH0sXHJcbiAgICBnZXROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZU5vZGVGcm9tTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgfSxcclxuICAgIGhhczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICB9LFxyXG59O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlByb3h5ICYmIHdpbmRvdy5SZWZsZWN0KSB7XHJcbiAgICBleHBvcnRzLm1pcnJvciA9IG5ldyBQcm94eShleHBvcnRzLm1pcnJvciwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdtYXAnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgdmFyIHByZXZpb3VzID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH0sIHJlbWFpbmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBkLCBpc1Jldm9rZWQsIHdpbikge1xyXG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB7IHdpbiA9IHdpbmRvdzsgfVxyXG4gICAgdmFyIG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xyXG4gICAgd2luLk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgaXNSZXZva2VkXHJcbiAgICAgICAgPyBkXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5zZXQuY2FsbChfdGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgJiYgb3JpZ2luYWwuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIG9yaWdpbmFsIHx8IHt9LCB0cnVlKTsgfTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaChzb3VyY2UsIG5hbWUsIHJlcGxhY2VtZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghKG5hbWUgaW4gc291cmNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxfMSA9IHNvdXJjZVtuYW1lXTtcclxuICAgICAgICB2YXIgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsXzEpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkLCB7XHJcbiAgICAgICAgICAgICAgICBfX3Jyd2ViX29yaWdpbmFsX186IHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxfMSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB3cmFwcGVkO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZVtuYW1lXSA9IG9yaWdpbmFsXzE7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuICh3aW5kb3cuaW5uZXJIZWlnaHQgfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHx8XHJcbiAgICAgICAgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcclxuICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggfHxcclxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkgfHxcclxuICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCbG9ja2VkKG5vZGUsIGJsb2NrQ2xhc3MpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgIHZhciBuZWVkQmxvY2tfMSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2tDbGFzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuY2xvc2VzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jbG9zZXN0KCcuJyArIGJsb2NrQ2xhc3MpICE9PSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmVlZEJsb2NrXzEgPSBub2RlLmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tDbGFzcy50ZXN0KGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWVkQmxvY2tfMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmVlZEJsb2NrXzEgfHwgaXNCbG9ja2VkKG5vZGUucGFyZW50Tm9kZSwgYmxvY2tDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICByZXR1cm4gaXNCbG9ja2VkKG5vZGUucGFyZW50Tm9kZSwgYmxvY2tDbGFzcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNCbG9ja2VkKG5vZGUucGFyZW50Tm9kZSwgYmxvY2tDbGFzcyk7XHJcbn1cclxuZnVuY3Rpb24gaXNJZ25vcmVkKG4pIHtcclxuICAgIGlmICghbiB8fCBuLl9fc24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoJ19fc24nIGluIG4pIHtcclxuICAgICAgICByZXR1cm4gbi5fX3NuLmlkID09PSBJR05PUkVEX05PREU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IpIHtcclxuICAgIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBpZCA9IG1pcnJvci5nZXRJZCh0YXJnZXQpO1xyXG4gICAgaWYgKCFtaXJyb3IuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQW5jZXN0b3JSZW1vdmVkKHRhcmdldC5wYXJlbnROb2RlLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHBvbHlmaWxsJDEod2luKSB7XHJcbiAgICBpZiAod2luID09PSB2b2lkIDApIHsgd2luID0gd2luZG93OyB9XHJcbiAgICBpZiAoJ05vZGVMaXN0JyBpbiB3aW4gJiYgIXdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xyXG4gICAgICAgIHdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZVxyXG4gICAgICAgICAgICAuZm9yRWFjaDtcclxuICAgIH1cclxuICAgIGlmICgnRE9NVG9rZW5MaXN0JyBpbiB3aW4gJiYgIXdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcclxuICAgICAgICB3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gQXJyYXkucHJvdG90eXBlXHJcbiAgICAgICAgICAgIC5mb3JFYWNoO1xyXG4gICAgfVxyXG4gICAgaWYgKCFOb2RlLnByb3RvdHlwZS5jb250YWlucykge1xyXG4gICAgICAgIE5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoISgwIGluIGFyZ3VtZW50cykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbnZhciBUcmVlSW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZUluZGV4KCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIFRyZWVJbmRleC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFRyZWVOb2RlID0gdGhpcy5pbmRleGVzLmdldChtdXRhdGlvbi5wYXJlbnRJZCk7XHJcbiAgICAgICAgdmFyIHRyZWVOb2RlID0ge1xyXG4gICAgICAgICAgICBpZDogbXV0YXRpb24ubm9kZS5pZCxcclxuICAgICAgICAgICAgbXV0YXRpb246IG11dGF0aW9uLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXBhcmVudFRyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJlZVt0cmVlTm9kZS5pZF0gPSB0cmVlTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyZWVOb2RlLnBhcmVudCA9IHBhcmVudFRyZWVOb2RlO1xyXG4gICAgICAgICAgICBwYXJlbnRUcmVlTm9kZS5jaGlsZHJlblt0cmVlTm9kZS5pZF0gPSB0cmVlTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbmRleGVzLnNldCh0cmVlTm9kZS5pZCwgdHJlZU5vZGUpO1xyXG4gICAgfTtcclxuICAgIFRyZWVJbmRleC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG11dGF0aW9uLCBtaXJyb3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwYXJlbnRUcmVlTm9kZSA9IHRoaXMuaW5kZXhlcy5nZXQobXV0YXRpb24ucGFyZW50SWQpO1xyXG4gICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuaW5kZXhlcy5nZXQobXV0YXRpb24uaWQpO1xyXG4gICAgICAgIHZhciBkZWVwUmVtb3ZlRnJvbU1pcnJvciA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVJZFNldC5hZGQoaWQpO1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG1pcnJvci5nZXROb2RlKGlkKTtcclxuICAgICAgICAgICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ19fc24nIGluIGNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBSZW1vdmVGcm9tTWlycm9yKGNoaWxkTm9kZS5fX3NuLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZGVlcFJlbW92ZUZyb21UcmVlSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVJZFNldC5hZGQobm9kZS5pZCk7XHJcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gZGVlcFJlbW92ZUZyb21UcmVlSW5kZXgobik7IH0pO1xyXG4gICAgICAgICAgICB2YXIgX3RyZWVOb2RlID0gX3RoaXMuaW5kZXhlcy5nZXQobm9kZS5pZCk7XHJcbiAgICAgICAgICAgIGlmIChfdHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcGFyZW50VHJlZU5vZGUgPSBfdHJlZU5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKF9wYXJlbnRUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdHJlZU5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfcGFyZW50VHJlZU5vZGUuY2hpbGRyZW5bX3RyZWVOb2RlLmlkXTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmRleGVzLmRlbGV0ZShtdXRhdGlvbi5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghdHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlTXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xyXG4gICAgICAgICAgICBkZWVwUmVtb3ZlRnJvbU1pcnJvcihtdXRhdGlvbi5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFwYXJlbnRUcmVlTm9kZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy50cmVlW3RyZWVOb2RlLmlkXTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleGVzLmRlbGV0ZSh0cmVlTm9kZS5pZCk7XHJcbiAgICAgICAgICAgIGRlZXBSZW1vdmVGcm9tVHJlZUluZGV4KHRyZWVOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0cmVlTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRUcmVlTm9kZS5jaGlsZHJlblt0cmVlTm9kZS5pZF07XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlcy5kZWxldGUobXV0YXRpb24uaWQpO1xyXG4gICAgICAgICAgICBkZWVwUmVtb3ZlRnJvbVRyZWVJbmRleCh0cmVlTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRyZWVJbmRleC5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uIChtdXRhdGlvbikge1xyXG4gICAgICAgIHZhciB0cmVlTm9kZSA9IHRoaXMuaW5kZXhlcy5nZXQobXV0YXRpb24uaWQpO1xyXG4gICAgICAgIGlmICh0cmVlTm9kZSkge1xyXG4gICAgICAgICAgICB0cmVlTm9kZS50ZXh0cy5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dE11dGF0aW9ucy5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHJlZUluZGV4LnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbiAobXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgdHJlZU5vZGUgPSB0aGlzLmluZGV4ZXMuZ2V0KG11dGF0aW9uLmlkKTtcclxuICAgICAgICBpZiAodHJlZU5vZGUpIHtcclxuICAgICAgICAgICAgdHJlZU5vZGUuYXR0cmlidXRlcy5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUcmVlSW5kZXgucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxNYXAuc2V0KGQuaWQsIGQpO1xyXG4gICAgfTtcclxuICAgIFRyZWVJbmRleC5wcm90b3R5cGUuaW5wdXQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRNYXAuc2V0KGQuaWQsIGQpO1xyXG4gICAgfTtcclxuICAgIFRyZWVJbmRleC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2MgPSB0aGlzLCB0cmVlID0gX2MudHJlZSwgcmVtb3ZlTm9kZU11dGF0aW9ucyA9IF9jLnJlbW92ZU5vZGVNdXRhdGlvbnMsIHRleHRNdXRhdGlvbnMgPSBfYy50ZXh0TXV0YXRpb25zLCBhdHRyaWJ1dGVNdXRhdGlvbnMgPSBfYy5hdHRyaWJ1dGVNdXRhdGlvbnM7XHJcbiAgICAgICAgdmFyIGJhdGNoTXV0YXRpb25EYXRhID0ge1xyXG4gICAgICAgICAgICBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24sXHJcbiAgICAgICAgICAgIHJlbW92ZXM6IHJlbW92ZU5vZGVNdXRhdGlvbnMsXHJcbiAgICAgICAgICAgIHRleHRzOiB0ZXh0TXV0YXRpb25zLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVNdXRhdGlvbnMsXHJcbiAgICAgICAgICAgIGFkZHM6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAodHJlZU5vZGUsIHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUlkU2V0LmFkZCh0cmVlTm9kZS5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmF0Y2hNdXRhdGlvbkRhdGEudGV4dHMgPSBiYXRjaE11dGF0aW9uRGF0YS50ZXh0c1xyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZW1vdmVkID8gW10gOiB0cmVlTm9kZS50ZXh0cylcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICFfdGhpcy5yZW1vdmVJZFNldC5oYXMobS5pZCk7IH0pO1xyXG4gICAgICAgICAgICBiYXRjaE11dGF0aW9uRGF0YS5hdHRyaWJ1dGVzID0gYmF0Y2hNdXRhdGlvbkRhdGEuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZW1vdmVkID8gW10gOiB0cmVlTm9kZS5hdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobSkgeyByZXR1cm4gIV90aGlzLnJlbW92ZUlkU2V0LmhhcyhtLmlkKTsgfSk7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMucmVtb3ZlSWRTZXQuaGFzKHRyZWVOb2RlLmlkKSAmJlxyXG4gICAgICAgICAgICAgICAgIV90aGlzLnJlbW92ZUlkU2V0Lmhhcyh0cmVlTm9kZS5tdXRhdGlvbi5wYXJlbnRJZCkgJiZcclxuICAgICAgICAgICAgICAgICFyZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaE11dGF0aW9uRGF0YS5hZGRzLnB1c2godHJlZU5vZGUubXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWVOb2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0cmVlTm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gd2FsayhuLCBmYWxzZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0cmVlTm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gd2FsayhuLCB0cnVlKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC52YWx1ZXModHJlZSkuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gd2FsayhuLCBmYWxzZSk7IH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gX192YWx1ZXModGhpcy5zY3JvbGxNYXAua2V5cygpKSwgX2UgPSBfZC5uZXh0KCk7ICFfZS5kb25lOyBfZSA9IF9kLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW1vdmVJZFNldC5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxNYXAuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9lICYmICFfZS5kb25lICYmIChfYSA9IF9kLnJldHVybikpIF9hLmNhbGwoX2QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyh0aGlzLmlucHV0TWFwLmtleXMoKSksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9nLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVtb3ZlSWRTZXQuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRNYXAuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9nICYmICFfZy5kb25lICYmIChfYiA9IF9mLnJldHVybikpIF9iLmNhbGwoX2YpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjcm9sbE1hcCA9IG5ldyBNYXAodGhpcy5zY3JvbGxNYXApO1xyXG4gICAgICAgIHZhciBpbnB1dE1hcCA9IG5ldyBNYXAodGhpcy5pbnB1dE1hcCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG11dGF0aW9uRGF0YTogYmF0Y2hNdXRhdGlvbkRhdGEsXHJcbiAgICAgICAgICAgIHNjcm9sbE1hcDogc2Nyb2xsTWFwLFxyXG4gICAgICAgICAgICBpbnB1dE1hcDogaW5wdXRNYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBUcmVlSW5kZXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5kZXhlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZU5vZGVNdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLnRleHRNdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU11dGF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dE1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH07XHJcbiAgICBUcmVlSW5kZXgucHJvdG90eXBlLmlkUmVtb3ZlZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUlkU2V0LmhhcyhpZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyZWVJbmRleDtcclxufSgpKTtcclxuZnVuY3Rpb24gcXVldWVUb1Jlc29sdmVUcmVlcyhxdWV1ZSkge1xyXG4gICAgdmFyIGVfMywgX2E7XHJcbiAgICB2YXIgcXVldWVOb2RlTWFwID0ge307XHJcbiAgICB2YXIgcHV0SW50b01hcCA9IGZ1bmN0aW9uIChtLCBwYXJlbnQpIHtcclxuICAgICAgICB2YXIgbm9kZUluVHJlZSA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IG0sXHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBxdWV1ZU5vZGVNYXBbbS5ub2RlLmlkXSA9IG5vZGVJblRyZWU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVJblRyZWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIHF1ZXVlTm9kZVRyZWVzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIHF1ZXVlXzEgPSBfX3ZhbHVlcyhxdWV1ZSksIHF1ZXVlXzFfMSA9IHF1ZXVlXzEubmV4dCgpOyAhcXVldWVfMV8xLmRvbmU7IHF1ZXVlXzFfMSA9IHF1ZXVlXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IHF1ZXVlXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIG5leHRJZCA9IG11dGF0aW9uLm5leHRJZCwgcGFyZW50SWQgPSBtdXRhdGlvbi5wYXJlbnRJZDtcclxuICAgICAgICAgICAgaWYgKG5leHRJZCAmJiBuZXh0SWQgaW4gcXVldWVOb2RlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEluVHJlZSA9IHF1ZXVlTm9kZU1hcFtuZXh0SWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRJblRyZWUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IG5leHRJblRyZWUucGFyZW50LmNoaWxkcmVuLmluZGV4T2YobmV4dEluVHJlZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEluVHJlZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgcHV0SW50b01hcChtdXRhdGlvbiwgbmV4dEluVHJlZS5wYXJlbnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBxdWV1ZU5vZGVUcmVlcy5pbmRleE9mKG5leHRJblRyZWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTm9kZVRyZWVzLnNwbGljZShpZHgsIDAsIHB1dEludG9NYXAobXV0YXRpb24sIG51bGwpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRJZCBpbiBxdWV1ZU5vZGVNYXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJblRyZWUgPSBxdWV1ZU5vZGVNYXBbcGFyZW50SWRdO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50SW5UcmVlLmNoaWxkcmVuLnB1c2gocHV0SW50b01hcChtdXRhdGlvbiwgcGFyZW50SW5UcmVlKSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxdWV1ZU5vZGVUcmVlcy5wdXNoKHB1dEludG9NYXAobXV0YXRpb24sIG51bGwpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlXzFfMSAmJiAhcXVldWVfMV8xLmRvbmUgJiYgKF9hID0gcXVldWVfMS5yZXR1cm4pKSBfYS5jYWxsKHF1ZXVlXzEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVldWVOb2RlVHJlZXM7XHJcbn1cclxuZnVuY3Rpb24gaXRlcmF0ZVJlc29sdmVUcmVlKHRyZWUsIGNiKSB7XHJcbiAgICBjYih0cmVlLnZhbHVlKTtcclxuICAgIGZvciAodmFyIGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaXRlcmF0ZVJlc29sdmVUcmVlKHRyZWUuY2hpbGRyZW5baV0sIGNiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0lmcmFtZUlOb2RlKG5vZGUpIHtcclxuICAgIGlmICgnX19zbicgaW4gbm9kZSkge1xyXG4gICAgICAgIHJldHVybiAobm9kZS5fX3NuLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiYgbm9kZS5fX3NuLnRhZ05hbWUgPT09ICdpZnJhbWUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBnZXRCYXNlRGltZW5zaW9uKG5vZGUsIHJvb3RJZnJhbWUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gKF9iID0gKF9hID0gbm9kZS5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mcmFtZUVsZW1lbnQ7XHJcbiAgICBpZiAoIWZyYW1lRWxlbWVudCB8fCBmcmFtZUVsZW1lbnQgPT09IHJvb3RJZnJhbWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICByZWxhdGl2ZVNjYWxlOiAxLFxyXG4gICAgICAgICAgICBhYnNvbHV0ZVNjYWxlOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgZnJhbWVEaW1lbnNpb24gPSBmcmFtZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgZnJhbWVCYXNlRGltZW5zaW9uID0gZ2V0QmFzZURpbWVuc2lvbihmcmFtZUVsZW1lbnQsIHJvb3RJZnJhbWUpO1xyXG4gICAgdmFyIHJlbGF0aXZlU2NhbGUgPSBmcmFtZURpbWVuc2lvbi5oZWlnaHQgLyBmcmFtZUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBmcmFtZURpbWVuc2lvbi54ICogZnJhbWVCYXNlRGltZW5zaW9uLnJlbGF0aXZlU2NhbGUgK1xyXG4gICAgICAgICAgICBmcmFtZUJhc2VEaW1lbnNpb24ueCxcclxuICAgICAgICB5OiBmcmFtZURpbWVuc2lvbi55ICogZnJhbWVCYXNlRGltZW5zaW9uLnJlbGF0aXZlU2NhbGUgK1xyXG4gICAgICAgICAgICBmcmFtZUJhc2VEaW1lbnNpb24ueSxcclxuICAgICAgICByZWxhdGl2ZVNjYWxlOiByZWxhdGl2ZVNjYWxlLFxyXG4gICAgICAgIGFic29sdXRlU2NhbGU6IGZyYW1lQmFzZURpbWVuc2lvbi5hYnNvbHV0ZVNjYWxlICogcmVsYXRpdmVTY2FsZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihuID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uc2hhZG93Um9vdCk7XHJcbn1cclxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdE1pbGxpc2Vjb25kcywgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge1xyXG4gICAgICAgIGlzSW1tZWRpYXRlOiBmYWxzZSxcclxuICAgICAgICBpc1RyYWlsaW5nOiBmYWxzZVxyXG4gICAgfTsgfVxyXG4gICAgdmFyIHRpbWVvdXRJZDtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICB2YXIgZG9MYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGltZW91dElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaXNJbW1lZGlhdGUgfHwgb3B0aW9ucy5pc1RyYWlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2hvdWxkQ2FsbE5vdyA9IG9wdGlvbnMuaXNJbW1lZGlhdGUgJiYgdGltZW91dElkID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRpbWVvdXRJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRvTGF0ZXIsIHdhaXRNaWxsaXNlY29uZHMpO1xyXG4gICAgICAgIGlmIChzaG91bGRDYWxsTm93KSB7XHJcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG52YXIgT1JJR0lOQUxfQVRUUklCVVRFX05BTUUkMSA9ICdfX3Jyd2ViX29yaWdpbmFsX18nO1xyXG5mdW5jdGlvbiBpczJEQ2FudmFzQmxhbmsoY2FudmFzKSB7XHJcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHZhciBjaHVua1NpemUgPSA1MDtcclxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4ICs9IGNodW5rU2l6ZSkge1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSArPSBjaHVua1NpemUpIHtcclxuICAgICAgICAgICAgdmFyIGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEdldEltYWdlRGF0YSA9IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FJDEgaW4gZ2V0SW1hZ2VEYXRhXHJcbiAgICAgICAgICAgICAgICA/IGdldEltYWdlRGF0YVtPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSQxXVxyXG4gICAgICAgICAgICAgICAgOiBnZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShvcmlnaW5hbEdldEltYWdlRGF0YS5jYWxsKGN0eCwgeCwgeSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4KSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMuaGVpZ2h0IC0geSkpLmRhdGEuYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKHBpeGVsQnVmZmVyLnNvbWUoZnVuY3Rpb24gKHBpeGVsKSB7IHJldHVybiBwaXhlbCAhPT0gMDsgfSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNEaXNhYmxlUmVtb3RlQ29udHJvbChub2RlKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZGlzYWJsZUNsYXNzID0gJ2Nvc2VlLWRpc2FibGUtcmVtb3RlLWNvbnRyb2wnO1xyXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XHJcbiAgICAgICAgdmFyIG5lZWREaXNhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG5vZGUuY2xvc2VzdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNsb3Nlc3QoJy4nICsgZGlzYWJsZUNsYXNzKSAhPT0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZWREaXNhYmxlID0gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoZGlzYWJsZUNsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5lZWREaXNhYmxlIHx8IGlzRGlzYWJsZVJlbW90ZUNvbnRyb2wobm9kZS5wYXJlbnROb2RlKTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBub2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICAgIHJldHVybiBpc0Rpc2FibGVSZW1vdGVDb250cm9sKG5vZGUucGFyZW50Tm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNEaXNhYmxlUmVtb3RlQ29udHJvbChub2RlLnBhcmVudE5vZGUpO1xyXG59XG5cbnZhciB1dGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgb246IG9uLFxuICAgIGNyZWF0ZU1pcnJvcjogY3JlYXRlTWlycm9yLFxuICAgIGdldCBfbWlycm9yICgpIHsgcmV0dXJuIGV4cG9ydHMubWlycm9yOyB9LFxuICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICBob29rU2V0dGVyOiBob29rU2V0dGVyLFxuICAgIHBhdGNoOiBwYXRjaCxcbiAgICBnZXRXaW5kb3dIZWlnaHQ6IGdldFdpbmRvd0hlaWdodCxcbiAgICBnZXRXaW5kb3dXaWR0aDogZ2V0V2luZG93V2lkdGgsXG4gICAgaXNCbG9ja2VkOiBpc0Jsb2NrZWQsXG4gICAgaXNJZ25vcmVkOiBpc0lnbm9yZWQsXG4gICAgaXNBbmNlc3RvclJlbW92ZWQ6IGlzQW5jZXN0b3JSZW1vdmVkLFxuICAgIGlzVG91Y2hFdmVudDogaXNUb3VjaEV2ZW50LFxuICAgIHBvbHlmaWxsOiBwb2x5ZmlsbCQxLFxuICAgIFRyZWVJbmRleDogVHJlZUluZGV4LFxuICAgIHF1ZXVlVG9SZXNvbHZlVHJlZXM6IHF1ZXVlVG9SZXNvbHZlVHJlZXMsXG4gICAgaXRlcmF0ZVJlc29sdmVUcmVlOiBpdGVyYXRlUmVzb2x2ZVRyZWUsXG4gICAgaXNJZnJhbWVJTm9kZTogaXNJZnJhbWVJTm9kZSxcbiAgICBnZXRCYXNlRGltZW5zaW9uOiBnZXRCYXNlRGltZW5zaW9uLFxuICAgIGhhc1NoYWRvd1Jvb3Q6IGhhc1NoYWRvd1Jvb3QsXG4gICAgZGVib3VuY2U6IGRlYm91bmNlLFxuICAgIGlzMkRDYW52YXNCbGFuazogaXMyRENhbnZhc0JsYW5rLFxuICAgIGlzRGlzYWJsZVJlbW90ZUNvbnRyb2w6IGlzRGlzYWJsZVJlbW90ZUNvbnRyb2xcbn0pO1xuXG5mdW5jdGlvbiBpc05vZGVJbkxpbmtlZExpc3Qobikge1xyXG4gICAgcmV0dXJuICdfX2xuJyBpbiBuO1xyXG59XHJcbnZhciBEb3VibGVMaW5rZWRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvdWJsZUxpbmtlZExpc3QoKSB7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBEb3VibGVMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBvdXRzaWRlIG9mIGxpc3QgcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBvc2l0aW9uOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Lm5leHQpIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgfTtcclxuICAgIERvdWJsZUxpbmtlZExpc3QucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciBub2RlID0ge1xyXG4gICAgICAgICAgICB2YWx1ZTogbixcclxuICAgICAgICAgICAgcHJldmlvdXM6IG51bGwsXHJcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBuLl9fbG4gPSBub2RlO1xyXG4gICAgICAgIGlmIChuLnByZXZpb3VzU2libGluZyAmJiBpc05vZGVJbkxpbmtlZExpc3Qobi5wcmV2aW91c1NpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0O1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICBub2RlLnByZXZpb3VzID0gbi5wcmV2aW91c1NpYmxpbmcuX19sbjtcclxuICAgICAgICAgICAgbi5wcmV2aW91c1NpYmxpbmcuX19sbi5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG4ubmV4dFNpYmxpbmcgJiZcclxuICAgICAgICAgICAgaXNOb2RlSW5MaW5rZWRMaXN0KG4ubmV4dFNpYmxpbmcpICYmXHJcbiAgICAgICAgICAgIG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cztcclxuICAgICAgICAgICAgbm9kZS5wcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IG4ubmV4dFNpYmxpbmcuX19sbjtcclxuICAgICAgICAgICAgbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgfTtcclxuICAgIERvdWJsZUxpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gbi5fX2xuO1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjdXJyZW50LnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLl9fbG4pIHtcclxuICAgICAgICAgICAgZGVsZXRlIG4uX19sbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRG91YmxlTGlua2VkTGlzdDtcclxufSgpKTtcclxudmFyIG1vdmVLZXkgPSBmdW5jdGlvbiAoaWQsIHBhcmVudElkKSB7IHJldHVybiBcIlwiLmNvbmNhdChpZCwgXCJAXCIpLmNvbmNhdChwYXJlbnRJZCk7IH07XHJcbmZ1bmN0aW9uIGlzSU5vZGUobikge1xyXG4gICAgcmV0dXJuICdfX3NuJyBpbiBuO1xyXG59XHJcbnZhciBNdXRhdGlvbkJ1ZmZlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNdXRhdGlvbkJ1ZmZlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRleHRzID0gW107XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XHJcbiAgICAgICAgdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXBSZW1vdmVzID0gW107XHJcbiAgICAgICAgdGhpcy5tb3ZlZE1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuYWRkZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmRyb3BwZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb25zID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xyXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5wcm9jZXNzTXV0YXRpb24pO1xyXG4gICAgICAgICAgICBfdGhpcy5lbWl0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuZnJvemVuIHx8IF90aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhZGRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBhZGRMaXN0ID0gbmV3IERvdWJsZUxpbmtlZExpc3QoKTtcclxuICAgICAgICAgICAgdmFyIGdldE5leHRJZCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSBuO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZCA9IElHTk9SRURfTk9ERTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0SWQgPT09IElHTk9SRURfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5zID0gbnMgJiYgbnMubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkID0gbnMgJiYgX3RoaXMubWlycm9yLmdldElkKG5zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0SWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwdXNoQWRkID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hhZG93SG9zdCA9IG4uZ2V0Um9vdE5vZGVcclxuICAgICAgICAgICAgICAgICAgICA/IChfYSA9IG4uZ2V0Um9vdE5vZGUoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3RcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFNoYWRvd0hvc3QgPSBzaGFkb3dIb3N0O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChfYyA9IChfYiA9IHJvb3RTaGFkb3dIb3N0ID09PSBudWxsIHx8IHJvb3RTaGFkb3dIb3N0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb290U2hhZG93SG9zdC5nZXRSb290Tm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwocm9vdFNoYWRvd0hvc3QpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaG9zdClcclxuICAgICAgICAgICAgICAgICAgICByb290U2hhZG93SG9zdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2UgPSAoX2QgPSByb290U2hhZG93SG9zdCA9PT0gbnVsbCB8fCByb290U2hhZG93SG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9vdFNoYWRvd0hvc3QuZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKHJvb3RTaGFkb3dIb3N0KSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmhvc3QpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vdEluRG9jID0gIV90aGlzLmRvYy5jb250YWlucyhuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghcm9vdFNoYWRvd0hvc3QgfHwgIV90aGlzLmRvYy5jb250YWlucyhyb290U2hhZG93SG9zdCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuLnBhcmVudE5vZGUgfHwgbm90SW5Eb2MpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3Qobi5wYXJlbnROb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gX3RoaXMubWlycm9yLmdldElkKHNoYWRvd0hvc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5taXJyb3IuZ2V0SWQobi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0SWQgPSBnZXROZXh0SWQobik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IC0xIHx8IG5leHRJZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkTGlzdC5hZGROb2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNuID0gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jOiBfdGhpcy5kb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBfdGhpcy5taXJyb3IubWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IF90aGlzLmJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogX3RoaXMuYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBfdGhpcy5tYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IF90aGlzLm1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IF90aGlzLmlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogX3RoaXMubWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiBfdGhpcy5tYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBfdGhpcy5tYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogX3RoaXMuc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiBfdGhpcy5yZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBfdGhpcy5pbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemU6IGZ1bmN0aW9uIChjdXJyZW50Tikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZnJhbWVJTm9kZShjdXJyZW50TikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KG4uc2hhZG93Um9vdCwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IGZ1bmN0aW9uIChpZnJhbWUsIGNoaWxkU24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlUmVtb3RlQ29udHJvbEZuOiBfdGhpcy5kaXNhYmxlUmVtb3RlQ29udHJvbEZuLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZDogbmV4dElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBzbixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKF90aGlzLm1hcFJlbW92ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3IucmVtb3ZlTm9kZUZyb21NYXAoX3RoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhfdGhpcy5tb3ZlZFNldCksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudFJlbW92ZWQoX3RoaXMucmVtb3ZlcywgbiwgX3RoaXMubWlycm9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMubW92ZWRTZXQuaGFzKG4ucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhfdGhpcy5hZGRlZFNldCksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KF90aGlzLmRyb3BwZWRTZXQsIG4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1BhcmVudFJlbW92ZWQoX3RoaXMucmVtb3ZlcywgbiwgX3RoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQoX3RoaXMubW92ZWRTZXQsIG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmVlZFNuYXBzaG90ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQoY2FuZGlkYXRlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0SWQgPSBnZXROZXh0SWQoY2FuZGlkYXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGNhbmRpZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IGFkZExpc3QubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUgPSBhZGRMaXN0LmdldChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gX3RoaXMubWlycm9yLmdldElkKF9ub2RlLnZhbHVlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJZCA9IGdldE5leHRJZChfbm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWRkTGlzdC5oZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShhZGRMaXN0LmhlYWQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcy5sZW5ndGggPD0gMCB8fCBhZGRzLmxlbmd0aCA8IF90aGlzLmFkZGVkU2V0LnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFNuYXBzaG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGUucHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKG5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobm9kZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5lZWRTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW92ZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRha2VGdWxsU25hcHNob3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbXV0YXRpb24gOiB0YWtlIHNuYXBzaG90Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0czogX3RoaXMudGV4dHNcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5taXJyb3IuZ2V0SWQodGV4dC5ub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dC52YWx1ZSxcclxuICAgICAgICAgICAgICAgIH0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIF90aGlzLm1pcnJvci5oYXModGV4dC5pZCk7IH0pLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogX3RoaXMuYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyByZXR1cm4gKHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogX3RoaXMubWlycm9yLmdldElkKGF0dHJpYnV0ZS5ub2RlKSxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGUuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIH0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyByZXR1cm4gX3RoaXMubWlycm9yLmhhcyhhdHRyaWJ1dGUuaWQpOyB9KSxcclxuICAgICAgICAgICAgICAgIHJlbW92ZXM6IF90aGlzLnJlbW92ZXMsXHJcbiAgICAgICAgICAgICAgICBhZGRzOiBhZGRzLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXBheWxvYWQudGV4dHMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5hdHRyaWJ1dGVzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQucmVtb3Zlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLmFkZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5tb3ZlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgX3RoaXMubW92ZWRNYXAgPSB7fTtcclxuICAgICAgICAgICAgX3RoaXMubXV0YXRpb25DYihwYXlsb2FkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XHJcbiAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmlzQ29udGFpbklnbm9yZUNsYXNzKG0udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAobS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGFyYWN0ZXJEYXRhJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG0udGFyZ2V0LnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kaXNhYmxlUmVtb3RlQ29udHJvbEZuICYmIG0udGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVSZW1vdGVDb250cm9sKG0udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzYWJsZVJlbW90ZUNvbnRyb2xGbih3aW5kb3cubG9jYXRpb24uaHJlZiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNhYmxlUmVtb3RlQ29udHJvbEZuKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MpICYmIHZhbHVlICE9PSBtLm9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udGFyZ2V0Lm5vZGVUeXBlID09PSBtLnRhcmdldC5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IG0udGFyZ2V0LmNsYXNzTGlzdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS50YXJnZXQubm9kZVR5cGUgPT09IG0udGFyZ2V0LlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0ID0gbS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmVlZE1hc2tpbmdUZXh0KG0udGFyZ2V0LCBfdGhpcy5tYXNrVGV4dENsYXNzLCBfdGhpcy5tYXNrVGV4dFNlbGVjdG9yKSAmJiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMubWFza1RleHRGblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF90aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsYXNzTGlzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCAnKicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtLnRhcmdldC5nZXRBdHRyaWJ1dGUobS5hdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobS5hdHRyaWJ1dGVOYW1lID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udGFyZ2V0Lm5vZGVUeXBlID09PSBtLnRhcmdldC5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IG0udGFyZ2V0LmNsYXNzTGlzdC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobS50YXJnZXQubm9kZVR5cGUgPT09IG0udGFyZ2V0LlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0ID0gbS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBfdGhpcy5tYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbS50YXJnZXQudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG0udGFyZ2V0LmdldEF0dHJpYnV0ZSgndHlwZScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IF90aGlzLm1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzKSB8fCB2YWx1ZSA9PT0gbS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGUgPT09IG0udGFyZ2V0OyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG0udGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uYXR0cmlidXRlTmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gX3RoaXMuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgbS5vbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXR0cmlidXRlcy5zdHlsZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXMuc3R5bGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlcy5zdHlsZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU9iaiA9IGl0ZW0uYXR0cmlidXRlcy5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoQXJyYXkuZnJvbSh0YXJnZXQuc3R5bGUpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbmFtZSA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UHJpb3JpdHkgPSB0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJpb3JpdHkgIT09IG9sZC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UHJpb3JpdHkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU9ialtwbmFtZV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlT2JqW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMoQXJyYXkuZnJvbShvbGQuc3R5bGUpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbmFtZSA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZSkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlT2JqW3BuYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbbS5hdHRyaWJ1dGVOYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShfdGhpcy5kb2MsIG0udGFyZ2V0LnRhZ05hbWUsIG0uYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOb2RlQWRkZWRfMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlbkFkZHMobiwgbS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vZGVBZGRlZF8xID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBtLnJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVBZGRlZF8xICYmIF90aGlzLmFkZGVkU2V0LmhhcyhuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0NvbnRhaW5JZ25vcmVDbGFzcyhuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMubWlycm9yLmdldElkKG0udGFyZ2V0Lmhvc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLm1pcnJvci5nZXRJZChtLnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MpIHx8IGlzSWdub3JlZChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hZGRlZFNldC5oYXMobikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBEZWxldGUoX3RoaXMuYWRkZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuYWRkZWRTZXQuaGFzKG0udGFyZ2V0KSAmJiBub2RlSWQgPT09IC0xKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCBfdGhpcy5taXJyb3IpKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1vdmVkU2V0LmhhcyhuKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubW92ZWRNYXBbbW92ZUtleShub2RlSWQsIHBhcmVudElkKV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBEZWxldGUoX3RoaXMubW92ZWRTZXQsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3Zlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NoYWRvdzogaXNTaGFkb3dSb290KG0udGFyZ2V0KSA/IHRydWUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXBSZW1vdmVzLnB1c2gobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2VuQWRkcyA9IGZ1bmN0aW9uIChuLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmRpc2FibGVSZW1vdGVDb250cm9sRm4gJiYgdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEaXNhYmxlUmVtb3RlQ29udHJvbCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzYWJsZVJlbW90ZUNvbnRyb2xGbih3aW5kb3cubG9jYXRpb24uaHJlZiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNhYmxlUmVtb3RlQ29udHJvbEZuKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiBpc0Jsb2NrZWQodGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgaXNJZ25vcmVkKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNDb250YWluSWdub3JlQ2xhc3ModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0NvbnRhaW5JZ25vcmVDbGFzcyhuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0lOb2RlKG4pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMubW92ZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgaXNJTm9kZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSB0YXJnZXQuX19zbi5pZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vdmVkTWFwW21vdmVLZXkobi5fX3NuLmlkLCB0YXJnZXRJZCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuZGVsZXRlKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG4sIF90aGlzLmJsb2NrQ2xhc3MpKVxyXG4gICAgICAgICAgICAgICAgbi5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTikgeyByZXR1cm4gX3RoaXMuZ2VuQWRkcyhjaGlsZE4pOyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgTXV0YXRpb25CdWZmZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucywgdGFrZUZ1bGxTbmFwc2hvdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAnbXV0YXRpb25DYicsXHJcbiAgICAgICAgICAgICdibG9ja0NsYXNzJyxcclxuICAgICAgICAgICAgJ2Jsb2NrU2VsZWN0b3InLFxyXG4gICAgICAgICAgICAnbWFza1RleHRDbGFzcycsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJyxcclxuICAgICAgICAgICAgJ2lubGluZVN0eWxlc2hlZXQnLFxyXG4gICAgICAgICAgICAnbWFza0lucHV0T3B0aW9ucycsXHJcbiAgICAgICAgICAgICdtYXNrVGV4dEZuJyxcclxuICAgICAgICAgICAgJ21hc2tJbnB1dEZuJyxcclxuICAgICAgICAgICAgJ3JlY29yZENhbnZhcycsXHJcbiAgICAgICAgICAgICdpbmxpbmVJbWFnZXMnLFxyXG4gICAgICAgICAgICAnc2xpbURPTU9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnZG9jJyxcclxuICAgICAgICAgICAgJ21pcnJvcicsXHJcbiAgICAgICAgICAgICdpZnJhbWVNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3NoYWRvd0RvbU1hbmFnZXInLFxyXG4gICAgICAgICAgICAnY2FudmFzTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdpZ25vcmVDbGFzcycsXHJcbiAgICAgICAgICAgICdkaXNhYmxlUmVtb3RlQ29udHJvbEZuJyxcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBfdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudGFrZUZ1bGxTbmFwc2hvdCA9IHRha2VGdWxsU25hcHNob3Q7XHJcbiAgICB9O1xyXG4gICAgTXV0YXRpb25CdWZmZXIucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgfTtcclxuICAgIE11dGF0aW9uQnVmZmVyLnByb3RvdHlwZS51bmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmZyZWV6ZSgpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgfTtcclxuICAgIE11dGF0aW9uQnVmZmVyLnByb3RvdHlwZS5pc0Zyb3plbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm96ZW47XHJcbiAgICB9O1xyXG4gICAgTXV0YXRpb25CdWZmZXIucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5sb2NrKCk7XHJcbiAgICB9O1xyXG4gICAgTXV0YXRpb25CdWZmZXIucHJvdG90eXBlLnVubG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci51bmxvY2soKTtcclxuICAgICAgICB0aGlzLmVtaXQoKTtcclxuICAgIH07XHJcbiAgICBNdXRhdGlvbkJ1ZmZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICB9O1xyXG4gICAgTXV0YXRpb25CdWZmZXIucHJvdG90eXBlLmlzQ29udGFpbklnbm9yZUNsYXNzID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pZ25vcmVDbGFzcyB8fCAhdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmlnbm9yZUNsYXNzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNdXRhdGlvbkJ1ZmZlcjtcclxufSgpKTtcclxuZnVuY3Rpb24gZGVlcERlbGV0ZShhZGRzU2V0LCBuKSB7XHJcbiAgICBhZGRzU2V0LmRlbGV0ZShuKTtcclxuICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE4pIHsgcmV0dXJuIGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKTsgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4sIG1pcnJvcikge1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSBuLnBhcmVudE5vZGU7XHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyZW50SWQgPSBtaXJyb3IuZ2V0SWQocGFyZW50Tm9kZSk7XHJcbiAgICBpZiAocmVtb3Zlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmlkID09PSBwYXJlbnRJZDsgfSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgcGFyZW50Tm9kZSwgbWlycm9yKTtcclxufVxyXG5mdW5jdGlvbiBpc0FuY2VzdG9ySW5TZXQoc2V0LCBuKSB7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG4ucGFyZW50Tm9kZTtcclxuICAgIGlmICghcGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChzZXQuaGFzKHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBbmNlc3RvckluU2V0KHNldCwgcGFyZW50Tm9kZSk7XHJcbn1cblxudmFyIG11dGF0aW9uQnVmZmVycyA9IFtdO1xyXG52YXIgcmVtb3RlQ29udHJvbGxQYXJhbSA9IHsgY29udHJvbGxpbmc6IGZhbHNlLCBzY3JvbGw6IGZhbHNlIH07XHJcbnZhciBpc0NTU0dyb3VwaW5nUnVsZVN1cHBvcnRlZCA9IHR5cGVvZiBDU1NHcm91cGluZ1J1bGUgIT09ICd1bmRlZmluZWQnO1xyXG52YXIgaXNDU1NNZWRpYVJ1bGVTdXBwb3J0ZWQgPSB0eXBlb2YgQ1NTTWVkaWFSdWxlICE9PSAndW5kZWZpbmVkJztcclxudmFyIGlzQ1NTU3VwcG9ydHNSdWxlU3VwcG9ydGVkID0gdHlwZW9mIENTU1N1cHBvcnRzUnVsZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBpc0NTU0NvbmRpdGlvblJ1bGVTdXBwb3J0ZWQgPSB0eXBlb2YgQ1NTQ29uZGl0aW9uUnVsZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdwYXRoJyBpbiBldmVudCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucywgcm9vdEVsLCB0YWtlRnVsbFNuYXBzaG90KSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgdmFyIG11dGF0aW9uQnVmZmVyID0gbmV3IE11dGF0aW9uQnVmZmVyKCk7XHJcbiAgICBtdXRhdGlvbkJ1ZmZlcnMucHVzaChtdXRhdGlvbkJ1ZmZlcik7XHJcbiAgICBtdXRhdGlvbkJ1ZmZlci5pbml0KG9wdGlvbnMsIHRha2VGdWxsU25hcHNob3QpO1xyXG4gICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHxcclxuICAgICAgICB3aW5kb3cuX19yck11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICB2YXIgYW5ndWxhclpvbmVTeW1ib2wgPSAoX2IgPSAoX2EgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuWm9uZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fc3ltYm9sX18pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAnTXV0YXRpb25PYnNlcnZlcicpO1xyXG4gICAgaWYgKGFuZ3VsYXJab25lU3ltYm9sICYmXHJcbiAgICAgICAgd2luZG93W2FuZ3VsYXJab25lU3ltYm9sXSkge1xyXG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93W2FuZ3VsYXJab25lU3ltYm9sXTtcclxuICAgIH1cclxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBtdXRhdGlvbk9ic2VydmVyQ3RvcihtdXRhdGlvbkJ1ZmZlci5wcm9jZXNzTXV0YXRpb25zLmJpbmQobXV0YXRpb25CdWZmZXIpKTtcclxuICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsLCB7XHJcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9ic2VydmVyO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNb3ZlT2JzZXJ2ZXIoX2EpIHtcclxuICAgIHZhciBtb3VzZW1vdmVDYiA9IF9hLm1vdXNlbW92ZUNiLCBzYW1wbGluZyA9IF9hLnNhbXBsaW5nLCBkb2MgPSBfYS5kb2MsIG1pcnJvciA9IF9hLm1pcnJvcjtcclxuICAgIGlmIChzYW1wbGluZy5tb3VzZW1vdmUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH1cclxuICAgIHZhciB0aHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlID09PSAnbnVtYmVyJyA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xyXG4gICAgdmFyIGNhbGxiYWNrVGhyZXNob2xkID0gdHlwZW9mIHNhbXBsaW5nLm1vdXNlbW92ZUNhbGxiYWNrID09PSAnbnVtYmVyJ1xyXG4gICAgICAgID8gc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2tcclxuICAgICAgICA6IDUwMDtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIHZhciB0aW1lQmFzZWxpbmU7XHJcbiAgICB2YXIgd3JhcHBlZENiID0gdGhyb3R0bGUoZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciB0b3RhbE9mZnNldCA9IERhdGUubm93KCkgLSB0aW1lQmFzZWxpbmU7XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IocG9zaXRpb25zLm1hcChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBwLnRpbWVPZmZzZXQgLT0gdG90YWxPZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0pLCBzb3VyY2UpO1xyXG4gICAgICAgIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XHJcbiAgICB9LCBjYWxsYmFja1RocmVzaG9sZCk7XHJcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSB0aHJvdHRsZShmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XHJcbiAgICAgICAgdmFyIF9hID0gaXNUb3VjaEV2ZW50KGV2dClcclxuICAgICAgICAgICAgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF1cclxuICAgICAgICAgICAgOiBldnQsIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcclxuICAgICAgICBpZiAoIXRpbWVCYXNlbGluZSkge1xyXG4gICAgICAgICAgICB0aW1lQmFzZWxpbmUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3NpdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIHg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgIHk6IGNsaWVudFksXHJcbiAgICAgICAgICAgIGlkOiBtaXJyb3IuZ2V0SWQodGFyZ2V0KSxcclxuICAgICAgICAgICAgdGltZU9mZnNldDogRGF0ZS5ub3coKSAtIHRpbWVCYXNlbGluZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB3cmFwcGVkQ2IodHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZ0IGluc3RhbmNlb2YgRHJhZ0V2ZW50XHJcbiAgICAgICAgICAgID8gZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5EcmFnXHJcbiAgICAgICAgICAgIDogZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudFxyXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZVxyXG4gICAgICAgICAgICAgICAgOiBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSk7XHJcbiAgICB9LCB0aHJlc2hvbGQsIHtcclxuICAgICAgICB0cmFpbGluZzogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIHZhciBoYW5kbGVycyA9IFtcclxuICAgICAgICBvbignbW91c2Vtb3ZlJywgdXBkYXRlUG9zaXRpb24sIGRvYyksXHJcbiAgICAgICAgb24oJ3RvdWNobW92ZScsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgICAgIG9uKCdkcmFnJywgdXBkYXRlUG9zaXRpb24sIGRvYyksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKF9hKSB7XHJcbiAgICB2YXIgbW91c2VJbnRlcmFjdGlvbkNiID0gX2EubW91c2VJbnRlcmFjdGlvbkNiLCBkb2MgPSBfYS5kb2MsIG1pcnJvciA9IF9hLm1pcnJvciwgYmxvY2tDbGFzcyA9IF9hLmJsb2NrQ2xhc3MsIHNhbXBsaW5nID0gX2Euc2FtcGxpbmc7XHJcbiAgICBpZiAoc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGRpc2FibGVNYXAgPSBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB0cnVlIHx8XHJcbiAgICAgICAgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDogc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbjtcclxuICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG4gICAgdmFyIGdldEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnRLZXkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChyZW1vdGVDb250cm9sbFBhcmFtLmNvbnRyb2xsaW5nICYmICFldmVudC5pc1RydXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZSA9IGlzVG91Y2hFdmVudChldmVudCkgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xyXG4gICAgICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFgsIGNsaWVudFkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgICAgIG1vdXNlSW50ZXJhY3Rpb25DYih7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSxcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIHg6IGNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICB5OiBjbGllbnRZLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5rZXlzKGV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMpXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiZcclxuICAgICAgICAgICAgIWtleS5lbmRzV2l0aCgnX0RlcGFydGVkJykgJiZcclxuICAgICAgICAgICAgZGlzYWJsZU1hcFtrZXldICE9PSBmYWxzZTtcclxuICAgIH0pXHJcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50S2V5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50S2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgZG9jKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkgeyByZXR1cm4gaCgpOyB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdFNjcm9sbE9ic2VydmVyKF9hKSB7XHJcbiAgICB2YXIgc2Nyb2xsQ2IgPSBfYS5zY3JvbGxDYiwgZG9jID0gX2EuZG9jLCBtaXJyb3IgPSBfYS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBfYS5ibG9ja0NsYXNzLCBzYW1wbGluZyA9IF9hLnNhbXBsaW5nO1xyXG4gICAgdmFyIHVwZGF0ZVBvc2l0aW9uID0gdGhyb3R0bGUoZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldnQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gZG9jKSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JvbGxFbCA9IChkb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgc2Nyb2xsQ2Ioe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgeDogc2Nyb2xsRWwuc2Nyb2xsTGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHNjcm9sbEVsLnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsaW5nOiByZW1vdGVDb250cm9sbFBhcmFtLmNvbnRyb2xsaW5nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjcm9sbENiKHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIHg6IHRhcmdldC5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICAgICAgeTogdGFyZ2V0LnNjcm9sbFRvcCxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsaW5nOiByZW1vdGVDb250cm9sbFBhcmFtLmNvbnRyb2xsaW5nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBzYW1wbGluZy5zY3JvbGwgfHwgMTAwKTtcclxuICAgIHJldHVybiBvbignc2Nyb2xsJywgdXBkYXRlUG9zaXRpb24sIGRvYyk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIoX2EpIHtcclxuICAgIHZhciB2aWV3cG9ydFJlc2l6ZUNiID0gX2Eudmlld3BvcnRSZXNpemVDYjtcclxuICAgIHZhciBsYXN0SCA9IC0xO1xyXG4gICAgdmFyIGxhc3RXID0gLTE7XHJcbiAgICB2YXIgdXBkYXRlRGltZW5zaW9uID0gdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xyXG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xyXG4gICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIod2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxhc3RIID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBsYXN0VyA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH0sIDIwMCk7XHJcbiAgICByZXR1cm4gb24oJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbiwgd2luZG93KTtcclxufVxyXG5mdW5jdGlvbiB3cmFwRXZlbnRXaXRoVXNlclRyaWdnZXJlZEZsYWcodiwgZW5hYmxlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBfX2Fzc2lnbih7fSwgdik7XHJcbiAgICBpZiAoIWVuYWJsZSlcclxuICAgICAgICBkZWxldGUgdmFsdWUudXNlclRyaWdnZXJlZDtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG52YXIgSU5QVVRfVEFHUyA9IFsnSU5QVVQnLCAnVEVYVEFSRUEnLCAnU0VMRUNUJ107XHJcbnZhciBsYXN0SW5wdXRWYWx1ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIGluaXRJbnB1dE9ic2VydmVyKF9hKSB7XHJcbiAgICB2YXIgaW5wdXRDYiA9IF9hLmlucHV0Q2IsIGRvYyA9IF9hLmRvYywgbWlycm9yID0gX2EubWlycm9yLCBibG9ja0NsYXNzID0gX2EuYmxvY2tDbGFzcywgaWdub3JlQ2xhc3MgPSBfYS5pZ25vcmVDbGFzcywgbWFza0lucHV0T3B0aW9ucyA9IF9hLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuID0gX2EubWFza0lucHV0Rm4sIHNhbXBsaW5nID0gX2Euc2FtcGxpbmcsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gX2EudXNlclRyaWdnZXJlZE9uSW5wdXQ7XHJcbiAgICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgIHZhciB1c2VyVHJpZ2dlcmVkID0gZXZlbnQuaXNUcnVzdGVkO1xyXG4gICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUgPT09ICdPUFRJT04nKVxyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoIXRhcmdldCB8fFxyXG4gICAgICAgICAgICAhdGFyZ2V0LnRhZ05hbWUgfHxcclxuICAgICAgICAgICAgSU5QVVRfVEFHUy5pbmRleE9mKHRhcmdldC50YWdOYW1lKSA8IDAgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHlwZSA9IHRhcmdldC50eXBlO1xyXG4gICAgICAgIGlmIChpZ25vcmVDbGFzcyAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZW1vdGVDb250cm9sbFBhcmFtLmNvbnRyb2xsaW5nICYmICFldmVudC5pc1RydXN0ZWQgJiYgdHlwZSAhPT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHQgPSB0YXJnZXQudmFsdWU7XHJcbiAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgaXNDaGVja2VkID0gdGFyZ2V0LmNoZWNrZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hc2tJbnB1dE9wdGlvbnNbdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uc1t0eXBlXSkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gJyc7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IHRhcmdldC5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IHRhcmdldC5jbGFzc0xpc3QudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gdGFyZ2V0LlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NMaXN0ID0gdGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHQgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFyZ2V0LnRhZ05hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNiV2l0aERlZHVwKHRhcmdldCwgd3JhcEV2ZW50V2l0aFVzZXJUcmlnZ2VyZWRGbGFnKHsgdGV4dDogdGV4dCwgaXNDaGVja2VkOiBpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQ6IHVzZXJUcmlnZ2VyZWQgfSwgdXNlclRyaWdnZXJlZE9uSW5wdXQpKTtcclxuICAgICAgICB2YXIgbmFtZSA9IHRhcmdldC5uYW1lO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncmFkaW8nICYmIG5hbWUgJiYgaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGRvY1xyXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdW25hbWU9XFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCJdXCIpKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiV2l0aERlZHVwKGVsLCB3cmFwRXZlbnRXaXRoVXNlclRyaWdnZXJlZEZsYWcoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBlbC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkOiAhaXNDaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyVHJpZ2dlcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9LCB1c2VyVHJpZ2dlcmVkT25JbnB1dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjYldpdGhEZWR1cCh0YXJnZXQsIHYpIHtcclxuICAgICAgICB2YXIgbGFzdElucHV0VmFsdWUgPSBsYXN0SW5wdXRWYWx1ZU1hcC5nZXQodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWxhc3RJbnB1dFZhbHVlIHx8XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlLnRleHQgIT09IHYudGV4dCB8fFxyXG4gICAgICAgICAgICBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYuaXNDaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlTWFwLnNldCh0YXJnZXQsIHYpO1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICAgICAgaW5wdXRDYihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdiksIHsgaWQ6IGlkIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgZXZlbnRzID0gc2FtcGxpbmcuaW5wdXQgPT09ICdsYXN0JyA/IFsnY2hhbmdlJ10gOiBbJ2lucHV0JywgJ2NoYW5nZSddO1xyXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzLm1hcChmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiBvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgZG9jKTsgfSk7XHJcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJyk7XHJcbiAgICB2YXIgaG9va1Byb3BlcnRpZXMgPSBbXHJcbiAgICAgICAgW0hUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsICdjaGVja2VkJ10sXHJcbiAgICAgICAgW0hUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJ10sXHJcbiAgICAgICAgW0hUTUxUZXh0QXJlYUVsZW1lbnQucHJvdG90eXBlLCAndmFsdWUnXSxcclxuICAgICAgICBbSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWRJbmRleCddLFxyXG4gICAgICAgIFtIVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsICdzZWxlY3RlZCddLFxyXG4gICAgXTtcclxuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IgJiYgcHJvcGVydHlEZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2guYXBwbHkoaGFuZGxlcnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChob29rUHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvb2tTZXR0ZXIocFswXSwgcFsxXSwge1xyXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyKHsgdGFyZ2V0OiB0aGlzIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpLCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHJ1bGUpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoY2hpbGRSdWxlLCBwb3MpIHtcclxuICAgICAgICBpZiAoKGlzQ1NTR3JvdXBpbmdSdWxlU3VwcG9ydGVkICYmXHJcbiAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaXNDU1NNZWRpYVJ1bGVTdXBwb3J0ZWQgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaXNDU1NTdXBwb3J0c1J1bGVTdXBwb3J0ZWQgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTU3VwcG9ydHNSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaXNDU1NDb25kaXRpb25SdWxlU3VwcG9ydGVkICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpKSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFJ1bGUuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBydWxlcy5pbmRleE9mKGNoaWxkUnVsZSk7XHJcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IEFycmF5LmZyb20oY2hpbGRSdWxlLnBhcmVudFN0eWxlU2hlZXQuY3NzUnVsZXMpO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBydWxlcy5pbmRleE9mKGNoaWxkUnVsZSk7XHJcbiAgICAgICAgICAgIHBvcy51bnNoaWZ0KGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuICAgIHJldHVybiByZWN1cnNlKHJ1bGUsIHBvc2l0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihfYSwgX2IpIHtcclxuICAgIHZhciBzdHlsZVNoZWV0UnVsZUNiID0gX2Euc3R5bGVTaGVldFJ1bGVDYiwgbWlycm9yID0gX2EubWlycm9yO1xyXG4gICAgdmFyIHdpbiA9IF9iLndpbjtcclxuICAgIHZhciBpbnNlcnRSdWxlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGU7XHJcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIChydWxlLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBpZCA9IG1pcnJvci5nZXRJZCh0aGlzLm93bmVyTm9kZSk7XHJcbiAgICAgICAgaWYgKGlkICE9PSAtMSkge1xyXG4gICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIGFkZHM6IFt7IHJ1bGU6IHJ1bGUsIGluZGV4OiBpbmRleCB9XSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNlcnRSdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGRlbGV0ZVJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZTtcclxuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGlkID0gbWlycm9yLmdldElkKHRoaXMub3duZXJOb2RlKTtcclxuICAgICAgICBpZiAoaWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXg6IGluZGV4IH1dLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGV0ZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICB2YXIgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzID0ge307XHJcbiAgICBpZiAoaXNDU1NHcm91cGluZ1J1bGVTdXBwb3J0ZWQpIHtcclxuICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTR3JvdXBpbmdSdWxlID0gd2luLkNTU0dyb3VwaW5nUnVsZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChpc0NTU01lZGlhUnVsZVN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQ1NTQ29uZGl0aW9uUnVsZVN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTQ29uZGl0aW9uUnVsZSA9IHdpbi5DU1NDb25kaXRpb25SdWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDU1NTdXBwb3J0c1J1bGVTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU1N1cHBvcnRzUnVsZSA9IHdpbi5DU1NTdXBwb3J0c1J1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHVubW9kaWZpZWRGdW5jdGlvbnMgPSB7fTtcclxuICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCB0eXBlS2V5ID0gX2JbMF0sIHR5cGUgPSBfYlsxXTtcclxuICAgICAgICB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldID0ge1xyXG4gICAgICAgICAgICBpbnNlcnRSdWxlOiB0eXBlLnByb3RvdHlwZS5pbnNlcnRSdWxlLFxyXG4gICAgICAgICAgICBkZWxldGVSdWxlOiB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIChydWxlLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IuZ2V0SWQodGhpcy5wYXJlbnRTdHlsZVNoZWV0Lm93bmVyTm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChpZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRSdWxlQ2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzKSksIGZhbHNlKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBmYWxzZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gbWlycm9yLmdldElkKHRoaXMucGFyZW50U3R5bGVTaGVldC5vd25lck5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW3sgaW5kZXg6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpcykpLCBmYWxzZSksIFtpbmRleF0sIGZhbHNlKSB9XSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gaW5zZXJ0UnVsZTtcclxuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCB0eXBlS2V5ID0gX2JbMF0sIHR5cGUgPSBfYlsxXTtcclxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZTtcclxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcihfYSwgX2IpIHtcclxuICAgIHZhciBzdHlsZURlY2xhcmF0aW9uQ2IgPSBfYS5zdHlsZURlY2xhcmF0aW9uQ2IsIG1pcnJvciA9IF9hLm1pcnJvcjtcclxuICAgIHZhciB3aW4gPSBfYi53aW47XHJcbiAgICB2YXIgc2V0UHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGlkID0gbWlycm9yLmdldElkKChfYiA9IChfYSA9IHRoaXMucGFyZW50UnVsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudFN0eWxlU2hlZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lck5vZGUpO1xyXG4gICAgICAgIGlmIChpZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgIGlkOiBpZCxcclxuICAgICAgICAgICAgICAgIHNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXMucGFyZW50UnVsZSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0UHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICB2YXIgcmVtb3ZlUHJvcGVydHkgPSB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHk7XHJcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBpZCA9IG1pcnJvci5nZXRJZCgoX2IgPSAoX2EgPSB0aGlzLnBhcmVudFJ1bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRTdHlsZVNoZWV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJOb2RlKTtcclxuICAgICAgICBpZiAoaWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpcy5wYXJlbnRSdWxlKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdmVQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIoX2EpIHtcclxuICAgIHZhciBtZWRpYUludGVyYWN0aW9uQ2IgPSBfYS5tZWRpYUludGVyYWN0aW9uQ2IsIGJsb2NrQ2xhc3MgPSBfYS5ibG9ja0NsYXNzLCBtaXJyb3IgPSBfYS5taXJyb3IsIHNhbXBsaW5nID0gX2Euc2FtcGxpbmc7XHJcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRocm90dGxlKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYSA9IHRhcmdldCwgY3VycmVudFRpbWUgPSBfYS5jdXJyZW50VGltZSwgdm9sdW1lID0gX2Eudm9sdW1lLCBtdXRlZCA9IF9hLm11dGVkO1xyXG4gICAgICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIGlkOiBtaXJyb3IuZ2V0SWQodGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiBjdXJyZW50VGltZSxcclxuICAgICAgICAgICAgICAgIHZvbHVtZTogdm9sdW1lLFxyXG4gICAgICAgICAgICAgICAgbXV0ZWQ6IG11dGVkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBzYW1wbGluZy5tZWRpYSB8fCA1MDApO1xyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVycyA9IFtcclxuICAgICAgICBvbigncGxheScsIGhhbmRsZXIoMCkpLFxyXG4gICAgICAgIG9uKCdwYXVzZScsIGhhbmRsZXIoMSkpLFxyXG4gICAgICAgIG9uKCdzZWVrZWQnLCBoYW5kbGVyKDIpKSxcclxuICAgICAgICBvbigndm9sdW1lY2hhbmdlJywgaGFuZGxlcigzKSksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0Rm9udE9ic2VydmVyKF9hKSB7XHJcbiAgICB2YXIgZm9udENiID0gX2EuZm9udENiLCBkb2MgPSBfYS5kb2M7XHJcbiAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCF3aW4pIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGhhbmRsZXJzID0gW107XHJcbiAgICB2YXIgZm9udE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB2YXIgb3JpZ2luYWxGb250RmFjZSA9IHdpbi5Gb250RmFjZTtcclxuICAgIHdpbi5Gb250RmFjZSA9IGZ1bmN0aW9uIEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycykge1xyXG4gICAgICAgIHZhciBmb250RmFjZSA9IG5ldyBvcmlnaW5hbEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycyk7XHJcbiAgICAgICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcclxuICAgICAgICAgICAgZmFtaWx5OiBmYW1pbHksXHJcbiAgICAgICAgICAgIGJ1ZmZlcjogdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyxcclxuICAgICAgICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gc291cmNlXHJcbiAgICAgICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShzb3VyY2UpKSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvbnRGYWNlO1xyXG4gICAgfTtcclxuICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoKGRvYy5mb250cywgJ2FkZCcsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm9udEZhY2UpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udENiKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRNYXAuZGVsZXRlKGZvbnRGYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZm9udEZhY2VdKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBoYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aW4uRm9udEZhY2UgPSBvcmlnaW5hbEZvbnRGYWNlO1xyXG4gICAgfSk7XHJcbiAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkgeyByZXR1cm4gaCgpOyB9KTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VIb29rcyhvLCBob29rcykge1xyXG4gICAgdmFyIG11dGF0aW9uQ2IgPSBvLm11dGF0aW9uQ2IsIG1vdXNlbW92ZUNiID0gby5tb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiID0gby5tb3VzZUludGVyYWN0aW9uQ2IsIHNjcm9sbENiID0gby5zY3JvbGxDYiwgdmlld3BvcnRSZXNpemVDYiA9IG8udmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiA9IG8uaW5wdXRDYiwgbWVkaWFJbnRlcmFjdGlvbkNiID0gby5tZWRpYUludGVyYWN0aW9uQ2IsIHN0eWxlU2hlZXRSdWxlQ2IgPSBvLnN0eWxlU2hlZXRSdWxlQ2IsIHN0eWxlRGVjbGFyYXRpb25DYiA9IG8uc3R5bGVEZWNsYXJhdGlvbkNiLCBjYW52YXNNdXRhdGlvbkNiID0gby5jYW52YXNNdXRhdGlvbkNiLCBmb250Q2IgPSBvLmZvbnRDYjtcclxuICAgIG8ubXV0YXRpb25DYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLm11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm11dGF0aW9uLmFwcGx5KGhvb2tzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZW1vdmVDYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLm1vdXNlbW92ZSkge1xyXG4gICAgICAgICAgICBob29rcy5tb3VzZW1vdmUuYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2Vtb3ZlQ2IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgby5tb3VzZUludGVyYWN0aW9uQ2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob29rcy5tb3VzZUludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm1vdXNlSW50ZXJhY3Rpb24uYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHApLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIG8uc2Nyb2xsQ2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob29rcy5zY3JvbGwpIHtcclxuICAgICAgICAgICAgaG9va3Muc2Nyb2xsLmFwcGx5KGhvb2tzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjcm9sbENiLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHApLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIG8udmlld3BvcnRSZXNpemVDYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLnZpZXdwb3J0UmVzaXplKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnZpZXdwb3J0UmVzaXplLmFwcGx5KGhvb2tzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplQ2IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgby5pbnB1dENiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgcFtfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaG9va3MuaW5wdXQpIHtcclxuICAgICAgICAgICAgaG9va3MuaW5wdXQuYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXRDYi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgIH07XHJcbiAgICBvLm1lZGlhSW50ZXJhY3Rpb25DYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLm1lZGlhSW50ZWFjdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tZWRpYUludGVhY3Rpb24uYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHApLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIG8uc3R5bGVTaGVldFJ1bGVDYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLnN0eWxlU2hlZXRSdWxlKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlU2hlZXRSdWxlLmFwcGx5KGhvb2tzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0eWxlU2hlZXRSdWxlQ2IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgby5zdHlsZURlY2xhcmF0aW9uQ2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob29rcy5zdHlsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0eWxlRGVjbGFyYXRpb24uYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHApLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIG8uY2FudmFzTXV0YXRpb25DYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvb2tzLmNhbnZhc011dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmNhbnZhc011dGF0aW9uLmFwcGx5KGhvb2tzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbnZhc011dGF0aW9uQ2IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocCksIGZhbHNlKSk7XHJcbiAgICB9O1xyXG4gICAgby5mb250Q2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHAgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob29rcy5mb250KSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmZvbnQuYXBwbHkoaG9va3MsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwKSwgZmFsc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9udENiLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHApLCBmYWxzZSkpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbml0T2JzZXJ2ZXJzKG8sIGhvb2tzLCB0YWtlRnVsbFNuYXBzaG90KSB7XHJcbiAgICB2YXIgZV8xLCBfYTtcclxuICAgIGlmIChob29rcyA9PT0gdm9pZCAwKSB7IGhvb2tzID0ge307IH1cclxuICAgIHZhciBjdXJyZW50V2luZG93ID0gby5kb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgbWVyZ2VIb29rcyhvLCBob29rcyk7XHJcbiAgICB2YXIgbXV0YXRpb25PYnNlcnZlciA9IGluaXRNdXRhdGlvbk9ic2VydmVyKG8sIG8uZG9jLCB0YWtlRnVsbFNuYXBzaG90KTtcclxuICAgIHZhciBtb3VzZW1vdmVIYW5kbGVyID0gaW5pdE1vdmVPYnNlcnZlcihvKTtcclxuICAgIHZhciBtb3VzZUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICB2YXIgc2Nyb2xsSGFuZGxlciA9IGluaXRTY3JvbGxPYnNlcnZlcihvKTtcclxuICAgIHZhciB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIgPSBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcihvKTtcclxuICAgIHZhciBpbnB1dEhhbmRsZXIgPSBpbml0SW5wdXRPYnNlcnZlcihvKTtcclxuICAgIHZhciBtZWRpYUludGVyYWN0aW9uSGFuZGxlciA9IGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICB2YXIgc3R5bGVTaGVldE9ic2VydmVyID0gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihvLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcclxuICAgIHZhciBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKG8sIHtcclxuICAgICAgICB3aW46IGN1cnJlbnRXaW5kb3csXHJcbiAgICB9KTtcclxuICAgIHZhciBmb250T2JzZXJ2ZXIgPSBvLmNvbGxlY3RGb250cyA/IGluaXRGb250T2JzZXJ2ZXIobykgOiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB2YXIgcGx1Z2luSGFuZGxlcnMgPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhvLnBsdWdpbnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgcGx1Z2luSGFuZGxlcnMucHVzaChwbHVnaW4ub2JzZXJ2ZXIocGx1Z2luLmNhbGxiYWNrLCBjdXJyZW50V2luZG93LCBwbHVnaW4ub3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIucmVzZXQoKTsgfSk7XHJcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xyXG4gICAgICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XHJcbiAgICAgICAgc2Nyb2xsSGFuZGxlcigpO1xyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xyXG4gICAgICAgIGlucHV0SGFuZGxlcigpO1xyXG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XHJcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XHJcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgZm9udE9ic2VydmVyKCk7XHJcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkgeyByZXR1cm4gaCgpOyB9KTtcclxuICAgIH07XHJcbn1cblxudmFyIElmcmFtZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSWZyYW1lTWFuYWdlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICB9XHJcbiAgICBJZnJhbWVNYW5hZ2VyLnByb3RvdHlwZS5hZGRJZnJhbWUgPSBmdW5jdGlvbiAoaWZyYW1lRWwpIHtcclxuICAgICAgICB0aGlzLmlmcmFtZXMuc2V0KGlmcmFtZUVsLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBJZnJhbWVNYW5hZ2VyLnByb3RvdHlwZS5hZGRMb2FkTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICB0aGlzLmxvYWRMaXN0ZW5lciA9IGNiO1xyXG4gICAgfTtcclxuICAgIElmcmFtZU1hbmFnZXIucHJvdG90eXBlLmF0dGFjaElmcmFtZSA9IGZ1bmN0aW9uIChpZnJhbWVFbCwgY2hpbGRTbikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGlmcmFtZUVsLl9fc24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkU24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcclxuICAgICAgICAgICAgdGV4dHM6IFtdLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcclxuICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5sb2FkTGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGlmcmFtZUVsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSWZyYW1lTWFuYWdlcjtcclxufSgpKTtcblxudmFyIFNoYWRvd0RvbU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2hhZG93RG9tTWFuYWdlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlUGF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcclxuICAgICAgICB0aGlzLnNjcm9sbENiID0gb3B0aW9ucy5zY3JvbGxDYjtcclxuICAgICAgICB0aGlzLmJ5cGFzc09wdGlvbnMgPSBvcHRpb25zLmJ5cGFzc09wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICB0aGlzLnRha2VGdWxsU25hcHNob3QgPSBvcHRpb25zLnRha2VGdWxsU25hcHNob3Q7XHJcbiAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZVBhdGNoZXMucHVzaChwYXRjaChIVE1MRWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dSb290ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRTaGFkb3dSb290KHRoaXMuc2hhZG93Um9vdCwgdGhpcy5vd25lckRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIFNoYWRvd0RvbU1hbmFnZXIucHJvdG90eXBlLmFkZFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoc2hhZG93Um9vdCwgZG9jKSB7XHJcbiAgICAgICAgaW5pdE11dGF0aW9uT2JzZXJ2ZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuYnlwYXNzT3B0aW9ucyksIHsgZG9jOiBkb2MsIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYiwgbWlycm9yOiB0aGlzLm1pcnJvciwgc2hhZG93RG9tTWFuYWdlcjogdGhpcyB9KSwgc2hhZG93Um9vdCwgdGhpcy50YWtlRnVsbFNuYXBzaG90KTtcclxuICAgICAgICBpbml0U2Nyb2xsT2JzZXJ2ZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuYnlwYXNzT3B0aW9ucyksIHsgc2Nyb2xsQ2I6IHRoaXMuc2Nyb2xsQ2IsIGRvYzogc2hhZG93Um9vdCwgbWlycm9yOiB0aGlzLm1pcnJvciB9KSk7XHJcbiAgICB9O1xyXG4gICAgU2hhZG93RG9tTWFuYWdlci5wcm90b3R5cGUub2JzZXJ2ZUF0dGFjaFNoYWRvdyA9IGZ1bmN0aW9uIChpZnJhbWVFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdykge1xyXG4gICAgICAgICAgICB2YXIgbWFuYWdlcl8xID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlUGF0Y2hlcy5wdXNoKHBhdGNoKGlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXJfMS5hZGRTaGFkb3dSb290KHRoaXMuc2hhZG93Um9vdCwgaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFkb3dSb290O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaGFkb3dEb21NYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlc3RvcmVQYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHJlc3RvcmVQYXRjaCkgeyByZXR1cm4gcmVzdG9yZVBhdGNoKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTaGFkb3dEb21NYW5hZ2VyO1xyXG59KCkpO1xuXG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIG1pcnJvciwgaWdub3JlQ2xhc3MpIHtcclxuICAgIHZhciBlXzEsIF9hO1xyXG4gICAgdmFyIGhhbmRsZXJzID0gW107XHJcbiAgICB2YXIgcHJvcHMyRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlKTtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzSWdub3JlZCA9IHRoaXMuY2FudmFzLmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MpICYmICFpc0lnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RyYXdJbWFnZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihfdGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdhbmlEYXRhVVJMJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihfdGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdkYXRhVVJMJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYikge1xyXG4gICAgICAgICAgICB2YXIgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdkYXRhVVJMJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcHMyRF8xID0gX192YWx1ZXMocHJvcHMyRCksIHByb3BzMkRfMV8xID0gcHJvcHMyRF8xLm5leHQoKTsgIXByb3BzMkRfMV8xLmRvbmU7IHByb3BzMkRfMV8xID0gcHJvcHMyRF8xLm5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzMkRfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICBfbG9vcF8xKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMyRF8xXzEgJiYgIXByb3BzMkRfMV8xLmRvbmUgJiYgKF9hID0gcHJvcHMyRF8xLnJldHVybikpIF9hLmNhbGwocHJvcHMyRF8xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgaWdub3JlQ2xhc3MpIHtcclxuICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCAnZ2V0Q29udGV4dCcsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGlzSWdub3JlZCA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKHRoaXMsIGJsb2NrQ2xhc3MpICYmICFpc0lnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgnX19jb250ZXh0JyBpbiB0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHQgPSBjb250ZXh0VHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtjb250ZXh0VHlwZV0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBwYXRjaCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxuXG4vKlxuICogYmFzZTY0LWFycmF5YnVmZmVyIDEuMC4yIDxodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyPlxuICogQ29weXJpZ2h0IChjKSAyMDIyIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gKi9cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbi8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBjaGFycy5sZW5ndGg7IGkkMisrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQyKV0gPSBpJDI7XG59XG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSwgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMildO1xuICAgICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xufTtcblxudmFyIHdlYkdMVmFyTWFwJDEgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHZhcmlhYmxlTGlzdEZvciQxKGN0eCwgY3Rvcikge1xyXG4gICAgdmFyIGNvbnRleHRNYXAgPSB3ZWJHTFZhck1hcCQxLmdldChjdHgpO1xyXG4gICAgaWYgKCFjb250ZXh0TWFwKSB7XHJcbiAgICAgICAgY29udGV4dE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB3ZWJHTFZhck1hcCQxLnNldChjdHgsIGNvbnRleHRNYXApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xyXG4gICAgICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0TWFwLmdldChjdG9yKTtcclxufVxyXG52YXIgc2F2ZVdlYkdMVmFyID0gZnVuY3Rpb24gKHZhbHVlLCB3aW4sIGN0eCkge1xyXG4gICAgaWYgKCF2YWx1ZSB8fFxyXG4gICAgICAgICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgdmFyIGxpc3QgPSB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIG5hbWUpO1xyXG4gICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKHZhbHVlKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBpbmRleCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgIGxpc3QucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn07XHJcbnZhciBpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSwgd2luKSB7XHJcbiAgICB2YXIgd2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gW1xyXG4gICAgICAgICdXZWJHTEFjdGl2ZUluZm8nLFxyXG4gICAgICAgICdXZWJHTEJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMRnJhbWVidWZmZXInLFxyXG4gICAgICAgICdXZWJHTFByb2dyYW0nLFxyXG4gICAgICAgICdXZWJHTFJlbmRlcmJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMU2hhZGVyJyxcclxuICAgICAgICAnV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQnLFxyXG4gICAgICAgICdXZWJHTFRleHR1cmUnLFxyXG4gICAgICAgICdXZWJHTFVuaWZvcm1Mb2NhdGlvbicsXHJcbiAgICAgICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3QnLFxyXG4gICAgICAgICdXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTJyxcclxuICAgIF07XHJcbiAgICB2YXIgc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzID0gd2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdHlwZW9mIHdpbltuYW1lXSA9PT0gJ2Z1bmN0aW9uJzsgfSk7XHJcbiAgICByZXR1cm4gQm9vbGVhbihzdXBwb3J0ZWRXZWJHTENvbnN0cnVjdG9yTmFtZXMuZmluZChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiB3aW5bbmFtZV07IH0pKTtcclxufTtcblxuZnVuY3Rpb24gcGF0Y2hHTFByb3RvdHlwZShwcm90b3R5cGUsIHR5cGUsIGNiLCBibG9ja0NsYXNzLCBtaXJyb3IsIHdpbiwgaWdub3JlQ2xhc3MpIHtcclxuICAgIHZhciBlXzEsIF9hO1xyXG4gICAgdmFyIGhhbmRsZXJzID0gW107XHJcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wc18xID0gX192YWx1ZXMocHJvcHMpLCBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKTsgIXByb3BzXzFfMS5kb25lOyBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChwcm90b3R5cGUsIHByb3AsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0LCB3aW4sIHByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0lnbm9yZWQgPSB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuY29udGFpbnMoaWdub3JlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZCh0aGlzLmNhbnZhcywgYmxvY2tDbGFzcykgJiYgIWlzSWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiAnYW5pRGF0YVVSTCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvb2tIYW5kbGVyID0gaG9va1NldHRlcihwcm90b3R5cGUsIHByb3AsIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6ICdhbmlEYXRhVVJMJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAocHJvcHNfMV8xICYmICFwcm9wc18xXzEuZG9uZSAmJiAoX2EgPSBwcm9wc18xLnJldHVybikpIF9hLmNhbGwocHJvcHNfMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVycztcclxufVxyXG5mdW5jdGlvbiBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIG1pcnJvciwgaWdub3JlQ2xhc3MpIHtcclxuICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG4gICAgaGFuZGxlcnMucHVzaC5hcHBseShoYW5kbGVycywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wsIGNiLCBibG9ja0NsYXNzLCBtaXJyb3IsIHdpbiwgaWdub3JlQ2xhc3MpKSwgZmFsc2UpKTtcclxuICAgIGlmICh0eXBlb2Ygd2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaC5hcHBseShoYW5kbGVycywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHBhdGNoR0xQcm90b3R5cGUod2luLldlYkdMMlJlbmRlcmluZ0NvbnRleHQucHJvdG90eXBlLCBDYW52YXNDb250ZXh0LldlYkdMMiwgY2IsIGJsb2NrQ2xhc3MsIG1pcnJvciwgd2luLCBpZ25vcmVDbGFzcykpLCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxufVxuXG52YXIgQ2FudmFzTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYW52YXNNYW5hZ2VyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yYWZTdGFtcHMgPSB7IGxhdGVzdElkOiAwLCBpbnZva2VJZDogbnVsbCB9O1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdGcmFtZSA9IHRoaXMucmFmU3RhbXBzLmludm9rZUlkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCAhPT0gdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQ7XHJcbiAgICAgICAgICAgIGlmIChuZXdGcmFtZSB8fCAhdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZCA9IHRoaXMucmFmU3RhbXBzLmxhdGVzdElkO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLnNldCh0YXJnZXQsIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KHRhcmdldCkucHVzaChtdXRhdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICBpZiAob3B0aW9ucy5yZWNvcmRDYW52YXMgPT09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIob3B0aW9ucy53aW4sIG9wdGlvbnMuYmxvY2tDbGFzcywgb3B0aW9ucy5pZ25vcmVDbGFzcyk7XHJcbiAgICB9XHJcbiAgICBDYW52YXNNYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzICYmIHRoaXMucmVzZXRPYnNlcnZlcnMoKTtcclxuICAgIH07XHJcbiAgICBDYW52YXNNYW5hZ2VyLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhbnZhc01hbmFnZXIucHJvdG90eXBlLnVuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzTWFuYWdlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzTWFuYWdlci5wcm90b3R5cGUudW5sb2NrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzTWFuYWdlci5wcm90b3R5cGUuaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAod2luLCBibG9ja0NsYXNzLCBpZ25vcmVDbGFzcykge1xyXG4gICAgICAgIHRoaXMuc3RhcnRSQUZUaW1lc3RhbXBpbmcoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0UGVuZGluZ0NhbnZhc011dGF0aW9uRmx1c2hlcigpO1xyXG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgaWdub3JlQ2xhc3MpO1xyXG4gICAgICAgIHZhciBjYW52YXMyRFJlc2V0ID0gaW5pdENhbnZhczJETXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIHRoaXMubWlycm9yLCBpZ25vcmVDbGFzcyk7XHJcbiAgICAgICAgdmFyIGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCB0aGlzLm1pcnJvciwgaWdub3JlQ2xhc3MpO1xyXG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHRSZXNldCgpO1xyXG4gICAgICAgICAgICBjYW52YXMyRFJlc2V0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhc1dlYkdMMWFuZDJSZXNldCgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzTWFuYWdlci5wcm90b3R5cGUuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpOyB9KTtcclxuICAgIH07XHJcbiAgICBDYW52YXNNYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJBRlRpbWVzdGFtcGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzZXRMYXRlc3RSQUZUaW1lc3RhbXAgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJhZlN0YW1wcy5sYXRlc3RJZCA9IHRpbWVzdGFtcDtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2V0TGF0ZXN0UkFGVGltZXN0YW1wKTtcclxuICAgIH07XHJcbiAgICBDYW52YXNNYW5hZ2VyLnByb3RvdHlwZS5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBjYW52YXMpIHtcclxuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FudmFzTWFuYWdlci5wcm90b3R5cGUuZmx1c2hQZW5kaW5nQ2FudmFzTXV0YXRpb25Gb3IgPSBmdW5jdGlvbiAoY2FudmFzLCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZXNXaXRoVHlwZSA9IHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5nZXQoY2FudmFzKTtcclxuICAgICAgICBpZiAoIXZhbHVlc1dpdGhUeXBlIHx8IGlkID09PSAtMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLnR5cGU7IHZhciByZXN0ID0gX19yZXN0KHZhbHVlLCBbXCJ0eXBlXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSB2YWx1ZXNXaXRoVHlwZVswXS50eXBlO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7IGlkOiBpZCwgdHlwZTogdHlwZSwgY29tbWFuZHM6IHZhbHVlcyB9KTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZGVsZXRlKGNhbnZhcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhbnZhc01hbmFnZXI7XHJcbn0oKSk7XG5cbmZ1bmN0aW9uIHdyYXBFdmVudChlKSB7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGUpLCB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcclxufVxyXG52YXIgd3JhcHBlZEVtaXQ7XHJcbnZhciB0YWtlRnVsbFNuYXBzaG90O1xyXG52YXIgaXNNb2JpbGUgPSAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbnZhciBpc1NhZmFyaSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpIDw9IC0xO1xyXG5mdW5jdGlvbiBjYW52YXNIYW5kbGUocGFyYW0pIHtcclxuICAgIHZhciBfYTtcclxuICAgIHZhciBjYW52YXMgPSBwYXJhbS50YXJnZXQ7XHJcbiAgICB2YXIgZ2wgPSAoX2EgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xyXG4gICAgaWYgKGdsKSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG4gICAgICAgIGlmICgoYXR0cmlicyA9PT0gbnVsbCB8fCBhdHRyaWJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdHRyaWJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGNsb25lIFdlYkdMIGNvbnRleHQgYXMgaXQgaGFzIHByZXNlcnZlRHJhd2luZ0J1ZmZlcj1mYWxzZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcXVhbGl0eSA9IGlzTW9iaWxlID8gMC4zIDogMC4xO1xyXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggPj0gMTAyNCB8fCBjYW52YXMuaGVpZ2h0ID49IDEwMjQpIHtcclxuICAgICAgICAgICAgcXVhbGl0eSA9IDAuMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGUgPSBpc1NhZmFyaSA/ICdpbWFnZS9qcGVnJyA6ICdpbWFnZS93ZWJwJztcclxuICAgICAgICBwYXJhbS5wLmFyZ3MgPSBbY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaXMyRENhbnZhc0JsYW5rKGNhbnZhcykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBwYXJhbS5wLmFyZ3MgPSBbcGFyYW0udGFyZ2V0LnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuNSldO1xyXG4gICAgfVxyXG4gICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICB0eXBlOiBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgIGRhdGE6IF9fYXNzaWduKHsgc291cmNlOiBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLkNhbnZhc011dGF0aW9uIH0sIHBhcmFtLnApLFxyXG4gICAgfSkpO1xyXG59XHJcbnZhciB3ZWJnbFRpbWVJZCA9IG51bGw7XHJcbnZhciBkdXJhdGlvbldlYmdsID0gaXNNb2JpbGUgPyAxMDAgOiAyMDA7XHJcbnZhciB0aHJvdHRsZUNhbnZhc0ZuID0gZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICBpZiAod2ViZ2xUaW1lSWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgd2ViZ2xUaW1lSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYW52YXNIYW5kbGUocGFyYW0pO1xyXG4gICAgICAgIHdlYmdsVGltZUlkID0gbnVsbDtcclxuICAgIH0sIGR1cmF0aW9uV2ViZ2wpO1xyXG59O1xyXG52YXIgZGVib3VuY2VDYW52YXNGbiA9IGRlYm91bmNlKGNhbnZhc0hhbmRsZSwgMTAwKTtcclxudmFyIG1pcnJvciA9IGNyZWF0ZU1pcnJvcigpO1xyXG5mdW5jdGlvbiByZWNvcmQob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIHZhciBlbWl0ID0gb3B0aW9ucy5lbWl0LCBjaGVja291dEV2ZXJ5Tm1zID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5Tm1zLCBjaGVja291dEV2ZXJ5TnRoID0gb3B0aW9ucy5jaGVja291dEV2ZXJ5TnRoLCBfYSA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tDbGFzcyA9IF9hID09PSB2b2lkIDAgPyAncnItYmxvY2snIDogX2EsIF9iID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCBibG9ja1NlbGVjdG9yID0gX2IgPT09IHZvaWQgMCA/IG51bGwgOiBfYiwgX2MgPSBvcHRpb25zLmlnbm9yZUNsYXNzLCBpZ25vcmVDbGFzcyA9IF9jID09PSB2b2lkIDAgPyAncnItaWdub3JlJyA6IF9jLCBfZCA9IG9wdGlvbnMubWFza1RleHRDbGFzcywgbWFza1RleHRDbGFzcyA9IF9kID09PSB2b2lkIDAgPyAncnItbWFzaycgOiBfZCwgX2UgPSBvcHRpb25zLm1hc2tUZXh0U2VsZWN0b3IsIG1hc2tUZXh0U2VsZWN0b3IgPSBfZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9lLCBfZiA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2YsIG1hc2tBbGxJbnB1dHMgPSBvcHRpb25zLm1hc2tBbGxJbnB1dHMsIF9tYXNrSW5wdXRPcHRpb25zID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBfc2xpbURPTU9wdGlvbnMgPSBvcHRpb25zLnNsaW1ET01PcHRpb25zLCBtYXNrSW5wdXRGbiA9IG9wdGlvbnMubWFza0lucHV0Rm4sIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIGhvb2tzID0gb3B0aW9ucy5ob29rcywgcGFja0ZuID0gb3B0aW9ucy5wYWNrRm4sIF9nID0gb3B0aW9ucy5zYW1wbGluZywgc2FtcGxpbmcgPSBfZyA9PT0gdm9pZCAwID8ge30gOiBfZywgbW91c2Vtb3ZlV2FpdCA9IG9wdGlvbnMubW91c2Vtb3ZlV2FpdCwgX2ggPSBvcHRpb25zLnJlY29yZENhbnZhcywgcmVjb3JkQ2FudmFzID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2gsIF9qID0gb3B0aW9ucy51c2VyVHJpZ2dlcmVkT25JbnB1dCwgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmNvbGxlY3RGb250cywgY29sbGVjdEZvbnRzID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2ssIF9sID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9sID09PSB2b2lkIDAgPyBmYWxzZSA6IF9sLCBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zLCBfbSA9IG9wdGlvbnMua2VlcElmcmFtZVNyY0ZuLCBrZWVwSWZyYW1lU3JjRm4gPSBfbSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0gOiBfbSwgZGlzYWJsZVJlbW90ZUNvbnRyb2xGbiA9IG9wdGlvbnMuZGlzYWJsZVJlbW90ZUNvbnRyb2xGbjtcclxuICAgIGlmICghZW1pdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW1pdCBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdXNlbW92ZVdhaXQgIT09IHVuZGVmaW5lZCAmJiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNhbXBsaW5nLm1vdXNlbW92ZSA9IG1vdXNlbW92ZVdhaXQ7XHJcbiAgICB9XHJcbiAgICB2YXIgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWVcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgY29sb3I6IHRydWUsXHJcbiAgICAgICAgICAgIGRhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCc6IHRydWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxyXG4gICAgICAgICAgICBtb250aDogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2VhcmNoOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZWw6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IHRydWUsXHJcbiAgICAgICAgICAgIHRpbWU6IHRydWUsXHJcbiAgICAgICAgICAgIHVybDogdHJ1ZSxcclxuICAgICAgICAgICAgd2VlazogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dGFyZWE6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogX21hc2tJbnB1dE9wdGlvbnMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IF9tYXNrSW5wdXRPcHRpb25zXHJcbiAgICAgICAgICAgIDogeyBwYXNzd29yZDogdHJ1ZSB9O1xyXG4gICAgdmFyIHNsaW1ET01PcHRpb25zID0gX3NsaW1ET01PcHRpb25zID09PSB0cnVlIHx8IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCdcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgc2NyaXB0OiB0cnVlLFxyXG4gICAgICAgICAgICBjb21tZW50OiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhU29jaWFsOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFIdHRwRXF1aXY6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCcsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09ICdhbGwnLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA/IF9zbGltRE9NT3B0aW9uc1xyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgcG9seWZpbGwkMSgpO1xyXG4gICAgdmFyIGxhc3RGdWxsU25hcHNob3RFdmVudDtcclxuICAgIHZhciBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xyXG4gICAgdmFyIGV2ZW50UHJvY2Vzc29yID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHBsdWdpbnMgfHwgW10pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmV2ZW50UHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHBsdWdpbi5ldmVudFByb2Nlc3NvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhY2tGbikge1xyXG4gICAgICAgICAgICBlID0gcGFja0ZuKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH07XHJcbiAgICB3cmFwcGVkRW1pdCA9IGZ1bmN0aW9uIChlLCBpc0NoZWNrb3V0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoKF9hID0gbXV0YXRpb25CdWZmZXJzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNGcm96ZW4oKSkgJiZcclxuICAgICAgICAgICAgZS50eXBlICE9PSBleHBvcnRzLkV2ZW50VHlwZS5GdWxsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgIShlLnR5cGUgPT09IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS5zb3VyY2UgPT09IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24pKSB7XHJcbiAgICAgICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChidWYpIHsgcmV0dXJuIGJ1Zi51bmZyZWV6ZSgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW1pdChldmVudFByb2Nlc3NvcihlKSwgaXNDaGVja291dCk7XHJcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuRnVsbFNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGU7XHJcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGUudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhLnNvdXJjZSA9PT0gZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgZS5kYXRhLmlzQXR0YWNoSWZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XHJcbiAgICAgICAgICAgIHZhciBleGNlZWRDb3VudCA9IGNoZWNrb3V0RXZlcnlOdGggJiYgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50ID49IGNoZWNrb3V0RXZlcnlOdGg7XHJcbiAgICAgICAgICAgIHZhciBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJlxyXG4gICAgICAgICAgICAgICAgZS50aW1lc3RhbXAgLSBsYXN0RnVsbFNuYXBzaG90RXZlbnQudGltZXN0YW1wID4gY2hlY2tvdXRFdmVyeU5tcztcclxuICAgICAgICAgICAgaWYgKGV4Y2VlZENvdW50IHx8IGV4Y2VlZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRha2VGdWxsU25hcHNob3QodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHdyYXBwZWRNdXRhdGlvbkVtaXQgPSBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgIGRhdGE6IF9fYXNzaWduKHsgc291cmNlOiBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk11dGF0aW9uIH0sIG0pLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbiAgICB2YXIgd3JhcHBlZFNjcm9sbEVtaXQgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbih7IHNvdXJjZTogZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5TY3JvbGwgfSwgcCksXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuICAgIHZhciB3cmFwcGVkQ2FudmFzTXV0YXRpb25FbWl0ID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gbWlycm9yLmdldE5vZGUocC5pZCk7XHJcbiAgICAgICAgaWYgKHRhcmdldCAmJiAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhpZ25vcmVDbGFzcykpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gJ2NvbW1hbmRzJyBpbiBwID8gcC5jb21tYW5kc1swXS5wcm9wZXJ0eSA6IHAucHJvcGVydHk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2RhdGFVUkwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7IHA6IHsgaWQ6IHAuaWQsIHByb3BlcnR5OiAnZGF0YVVSTCcsIGFyZ3M6IFtdLCB0eXBlOiBwLnR5cGUgfSwgdGFyZ2V0OiB0YXJnZXQgfTtcclxuICAgICAgICAgICAgICAgIGRlYm91bmNlQ2FudmFzRm4ocGFyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09PSAnYW5pRGF0YVVSTCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHsgcDogeyBpZDogcC5pZCwgcHJvcGVydHk6ICdhbmlEYXRhVVJMJywgYXJnczogW10sIHR5cGU6IHAudHlwZSB9LCB0YXJnZXQ6IHRhcmdldCB9O1xyXG4gICAgICAgICAgICAgICAgdGhyb3R0bGVDYW52YXNGbihwYXJhbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb24gfSwgcCksXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGlmcmFtZU1hbmFnZXIgPSBuZXcgSWZyYW1lTWFuYWdlcih7XHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgIH0pO1xyXG4gICAgdmFyIGNhbnZhc01hbmFnZXIgPSBuZXcgQ2FudmFzTWFuYWdlcih7XHJcbiAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcclxuICAgICAgICB3aW46IHdpbmRvdyxcclxuICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxyXG4gICAgICAgIG1pcnJvcjogbWlycm9yLFxyXG4gICAgICAgIGlnbm9yZUNsYXNzOiBpZ25vcmVDbGFzc1xyXG4gICAgfSk7XHJcbiAgICB2YXIgc2hhZG93RG9tTWFuYWdlciA9IG5ldyBTaGFkb3dEb21NYW5hZ2VyKHtcclxuICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxyXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcclxuICAgICAgICBieXBhc3NPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcsXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgaWZyYW1lTWFuYWdlcjogaWZyYW1lTWFuYWdlcixcclxuICAgICAgICAgICAgaWdub3JlQ2xhc3M6IGlnbm9yZUNsYXNzLFxyXG4gICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90OiB0YWtlRnVsbFNuYXBzaG90LFxyXG4gICAgICAgICAgICBjYW52YXNNYW5hZ2VyOiBjYW52YXNNYW5hZ2VyLFxyXG4gICAgICAgICAgICBkaXNhYmxlUmVtb3RlQ29udHJvbEZuOiBkaXNhYmxlUmVtb3RlQ29udHJvbEZuLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWlycm9yOiBtaXJyb3IsXHJcbiAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdDogdGFrZUZ1bGxTbmFwc2hvdCxcclxuICAgIH0pO1xyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdCA9IGZ1bmN0aW9uIChpc0NoZWNrb3V0KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGlmIChpc0NoZWNrb3V0ID09PSB2b2lkIDApIHsgaXNDaGVja291dCA9IGZhbHNlOyB9XHJcbiAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuTWV0YSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZ2V0V2luZG93V2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZ2V0V2luZG93SGVpZ2h0KCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksIGlzQ2hlY2tvdXQpO1xyXG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uIChidWYpIHsgcmV0dXJuIGJ1Zi5sb2NrKCk7IH0pO1xyXG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChzbmFwc2hvdChkb2N1bWVudCwge1xyXG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrQWxsSW5wdXRzOiBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBzbGltRE9NOiBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZTogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0lmcmFtZUlOb2RlKG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuLnNoYWRvd1Jvb3QsIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25JZnJhbWVMb2FkOiBmdW5jdGlvbiAoaWZyYW1lLCBjaGlsZFNuKSB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmF0dGFjaElmcmFtZShpZnJhbWUsIGNoaWxkU24pO1xyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5vYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICBkaXNhYmxlUmVtb3RlQ29udHJvbEZuOiBkaXNhYmxlUmVtb3RlQ29udHJvbEZuLFxyXG4gICAgICAgIH0pLCAyKSwgbm9kZSA9IF9lWzBdLCBpZE5vZGVNYXAgPSBfZVsxXTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaXJyb3IubWFwID0gaWROb2RlTWFwO1xyXG4gICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IGV4cG9ydHMuRXZlbnRUeXBlLkZ1bGxTbmFwc2hvdCxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgICAgICAgIGluaXRpYWxPZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gKF9hID0gZG9jdW1lbnQgPT09IG51bGwgfHwgZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50LmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGRvY3VtZW50ID09PSBudWxsIHx8IGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IGRvY3VtZW50ID09PSBudWxsIHx8IGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudC5ib2R5KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGJ1ZikgeyByZXR1cm4gYnVmLnVubG9jaygpOyB9KTtcclxuICAgIH07XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBoYW5kbGVyc18xID0gW107XHJcbiAgICAgICAgaGFuZGxlcnNfMS5wdXNoKG9uKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuRG9tQ29udGVudExvYWRlZCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlXzEgPSBmdW5jdGlvbiAoZG9jKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIGluaXRPYnNlcnZlcnMoe1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZUNiOiBmdW5jdGlvbiAocG9zaXRpb25zLCBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbih7IHNvdXJjZTogZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uIH0sIGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXHJcbiAgICAgICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbih7IHNvdXJjZTogZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSB9LCBkKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW5wdXRDYjogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQgfSwgdiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYjogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbiB9LCBwKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGUgfSwgciksXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvbiB9LCByKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcclxuICAgICAgICAgICAgICAgIGZvbnRDYjogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oeyBzb3VyY2U6IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuRm9udCB9LCBwKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZUNsYXNzOiBpZ25vcmVDbGFzcyxcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZE9uSW5wdXQ6IHVzZXJUcmlnZ2VyZWRPbklucHV0LFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdEZvbnRzOiBjb2xsZWN0Rm9udHMsXHJcbiAgICAgICAgICAgICAgICBkb2M6IGRvYyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IsXHJcbiAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyOiBpZnJhbWVNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlcjogc2hhZG93RG9tTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGNhbnZhc01hbmFnZXI6IGNhbnZhc01hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiAoKF9hID0gcGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5vYnNlcnZlcjsgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcC5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAocGF5bG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGV4cG9ydHMuRXZlbnRUeXBlLlBsdWdpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW46IHAubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTsgfSkpIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZVJlbW90ZUNvbnRyb2xGbjogZGlzYWJsZVJlbW90ZUNvbnRyb2xGbixcclxuICAgICAgICAgICAgfSwgaG9va3MsIHRha2VGdWxsU25hcHNob3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRMb2FkTGlzdGVuZXIoZnVuY3Rpb24gKGlmcmFtZUVsKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzXzEucHVzaChvYnNlcnZlXzEoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGluaXRfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCgpO1xyXG4gICAgICAgICAgICBoYW5kbGVyc18xLnB1c2gob2JzZXJ2ZV8xKGRvY3VtZW50KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fFxyXG4gICAgICAgICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgIGluaXRfMSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlcnNfMS5wdXNoKG9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBleHBvcnRzLkV2ZW50VHlwZS5Mb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaW5pdF8xKCk7XHJcbiAgICAgICAgICAgIH0sIHdpbmRvdykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyc18xLmZvckVhY2goZnVuY3Rpb24gKGgpIHsgcmV0dXJuIGgoKTsgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XHJcbiAgICB9XHJcbn1cclxucmVjb3JkLmFkZEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gKHRhZywgcGF5bG9hZCkge1xyXG4gICAgaWYgKCF3cmFwcGVkRW1pdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGxlYXNlIGFkZCBjdXN0b20gZXZlbnQgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nJyk7XHJcbiAgICB9XHJcbiAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgIHR5cGU6IGV4cG9ydHMuRXZlbnRUeXBlLkN1c3RvbSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHRhZzogdGFnLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KSk7XHJcbn07XHJcbnJlY29yZC5mcmVlemVQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGJ1ZikgeyByZXR1cm4gYnVmLmZyZWV6ZSgpOyB9KTtcclxufTtcclxucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSBmdW5jdGlvbiAoaXNDaGVja291dCkge1xyXG4gICAgaWYgKCF0YWtlRnVsbFNuYXBzaG90KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgdGFrZSBmdWxsIHNuYXBzaG90IGFmdGVyIHN0YXJ0IHJlY29yZGluZycpO1xyXG4gICAgfVxyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdChpc0NoZWNrb3V0KTtcclxufTtcclxucmVjb3JkLnN0YXJ0UmVtb3RlQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJlbW90ZUNvbnRyb2xsUGFyYW0uY29udHJvbGxpbmcgPSB0cnVlO1xyXG59O1xyXG5yZWNvcmQuc3RvcFJlbW90ZUNvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZW1vdGVDb250cm9sbFBhcmFtLmNvbnRyb2xsaW5nID0gZmFsc2U7XHJcbn07XHJcbnJlY29yZC5zdGFydFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJlbW90ZUNvbnRyb2xsUGFyYW0uc2Nyb2xsID0gdHJ1ZTtcclxufTtcclxucmVjb3JkLnN0b3BTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZW1vdGVDb250cm9sbFBhcmFtLnNjcm9sbCA9IGZhbHNlO1xyXG59O1xyXG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xuXG4vLyAgICAgIFxuLy8gQW4gZXZlbnQgaGFuZGxlciBjYW4gdGFrZSBhbiBvcHRpb25hbCBldmVudCBhcmd1bWVudFxuLy8gYW5kIHNob3VsZCBub3QgcmV0dXJuIGEgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbi8vIEFuIGFycmF5IG9mIGFsbCBjdXJyZW50bHkgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVycyBmb3IgYSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4vLyBBIG1hcCBvZiBldmVudCB0eXBlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBldmVudCBoYW5kbGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICBcblxuLyoqIE1pdHQ6IFRpbnkgKH4yMDBiKSBmdW5jdGlvbmFsIGV2ZW50IGVtaXR0ZXIgLyBwdWJzdWIuXG4gKiAgQG5hbWUgbWl0dFxuICogIEByZXR1cm5zIHtNaXR0fVxuICovXG5mdW5jdGlvbiBtaXR0JDEoYWxsICAgICAgICAgICAgICAgICApIHtcblx0YWxsID0gYWxsIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdHlwZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVx0VHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLCBvciBgXCIqXCJgIGZvciBhbGwgZXZlbnRzXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gY2FsbCBpbiByZXNwb25zZSB0byBnaXZlbiBldmVudFxuXHRcdCAqIEBtZW1iZXJPZiBtaXR0XG5cdFx0ICovXG5cdFx0b246IGZ1bmN0aW9uIG9uKHR5cGUgICAgICAgICwgaGFuZGxlciAgICAgICAgICAgICAgKSB7XG5cdFx0XHQoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdHlwZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVx0VHlwZSBvZiBldmVudCB0byB1bnJlZ2lzdGVyIGBoYW5kbGVyYCBmcm9tLCBvciBgXCIqXCJgXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGhhbmRsZXIgSGFuZGxlciBmdW5jdGlvbiB0byByZW1vdmVcblx0XHQgKiBAbWVtYmVyT2YgbWl0dFxuXHRcdCAqL1xuXHRcdG9mZjogZnVuY3Rpb24gb2ZmKHR5cGUgICAgICAgICwgaGFuZGxlciAgICAgICAgICAgICAgKSB7XG5cdFx0XHRpZiAoYWxsW3R5cGVdKSB7XG5cdFx0XHRcdGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbnZva2UgYWxsIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cblx0XHQgKiBJZiBwcmVzZW50LCBgXCIqXCJgIGhhbmRsZXJzIGFyZSBpbnZva2VkIGFmdGVyIHR5cGUtbWF0Y2hlZCBoYW5kbGVycy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICBUaGUgZXZlbnQgdHlwZSB0byBpbnZva2Vcblx0XHQgKiBAcGFyYW0ge0FueX0gW2V2dF0gIEFueSB2YWx1ZSAob2JqZWN0IGlzIHJlY29tbWVuZGVkIGFuZCBwb3dlcmZ1bCksIHBhc3NlZCB0byBlYWNoIGhhbmRsZXJcblx0XHQgKiBAbWVtYmVyT2YgbWl0dFxuXHRcdCAqL1xuXHRcdGVtaXQ6IGZ1bmN0aW9uIGVtaXQodHlwZSAgICAgICAgLCBldnQgICAgICkge1xuXHRcdFx0KGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgaGFuZGxlcihldnQpOyB9KTtcblx0XHRcdChhbGxbJyonXSB8fCBbXSkuc2xpY2UoKS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgaGFuZGxlcih0eXBlLCBldnQpOyB9KTtcblx0XHR9XG5cdH07XG59XG5cbnZhciBtaXR0UHJveHkgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgICdkZWZhdWx0JzogbWl0dCQxXG59KTtcblxuZnVuY3Rpb24gcG9seWZpbGwodywgZCkge1xyXG4gICAgaWYgKHcgPT09IHZvaWQgMCkgeyB3ID0gd2luZG93OyB9XHJcbiAgICBpZiAoZCA9PT0gdm9pZCAwKSB7IGQgPSBkb2N1bWVudDsgfVxyXG4gICAgaWYgKCdzY3JvbGxCZWhhdmlvcicgaW4gZC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiZcclxuICAgICAgICB3Ll9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fICE9PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcclxuICAgIHZhciBTQ1JPTExfVElNRSA9IDQ2ODtcclxuICAgIHZhciBvcmlnaW5hbCA9IHtcclxuICAgICAgICBzY3JvbGw6IHcuc2Nyb2xsIHx8IHcuc2Nyb2xsVG8sXHJcbiAgICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXHJcbiAgICAgICAgZWxlbWVudFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3LFxyXG4gICAgfTtcclxuICAgIHZhciBub3cgPSB3LnBlcmZvcm1hbmNlICYmIHcucGVyZm9ybWFuY2Uubm93XHJcbiAgICAgICAgPyB3LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHcucGVyZm9ybWFuY2UpXHJcbiAgICAgICAgOiBEYXRlLm5vdztcclxuICAgIGZ1bmN0aW9uIGlzTWljcm9zb2Z0QnJvd3Nlcih1c2VyQWdlbnQpIHtcclxuICAgICAgICB2YXIgdXNlckFnZW50UGF0dGVybnMgPSBbJ01TSUUgJywgJ1RyaWRlbnQvJywgJ0VkZ2UvJ107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodXNlckFnZW50UGF0dGVybnMuam9pbignfCcpKS50ZXN0KHVzZXJBZ2VudCk7XHJcbiAgICB9XHJcbiAgICB2YXIgUk9VTkRJTkdfVE9MRVJBTkNFID0gaXNNaWNyb3NvZnRCcm93c2VyKHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAxIDogMDtcclxuICAgIGZ1bmN0aW9uIHNjcm9sbEVsZW1lbnQoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZWFzZShrKSB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoZmlyc3RBcmcpIHtcclxuICAgICAgICBpZiAoZmlyc3RBcmcgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgdHlwZW9mIGZpcnN0QXJnICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnYXV0bycgfHxcclxuICAgICAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdpbnN0YW50Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcgJiYgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmVoYXZpb3IgbWVtYmVyIG9mIFNjcm9sbE9wdGlvbnMgJyArXHJcbiAgICAgICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yICtcclxuICAgICAgICAgICAgJyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZW51bWVyYXRpb24gU2Nyb2xsQmVoYXZpb3IuJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsIGF4aXMpIHtcclxuICAgICAgICBpZiAoYXhpcyA9PT0gJ1knKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGllbnRIZWlnaHQgKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChheGlzID09PSAnWCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsaWVudFdpZHRoICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2FuT3ZlcmZsb3coZWwsIGF4aXMpIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3dWYWx1ZSA9IHcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbClbJ292ZXJmbG93JyArIGF4aXNdO1xyXG4gICAgICAgIHJldHVybiBvdmVyZmxvd1ZhbHVlID09PSAnYXV0bycgfHwgb3ZlcmZsb3dWYWx1ZSA9PT0gJ3Njcm9sbCc7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwpIHtcclxuICAgICAgICB2YXIgaXNTY3JvbGxhYmxlWSA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1knKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1knKTtcclxuICAgICAgICB2YXIgaXNTY3JvbGxhYmxlWCA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1gnKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1gnKTtcclxuICAgICAgICByZXR1cm4gaXNTY3JvbGxhYmxlWSB8fCBpc1Njcm9sbGFibGVYO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcclxuICAgICAgICB3aGlsZSAoZWwgIT09IGQuYm9keSAmJiBpc1Njcm9sbGFibGUoZWwpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGUgfHwgZWwuaG9zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRYO1xyXG4gICAgICAgIHZhciBjdXJyZW50WTtcclxuICAgICAgICB2YXIgZWxhcHNlZCA9ICh0aW1lIC0gY29udGV4dC5zdGFydFRpbWUpIC8gU0NST0xMX1RJTUU7XHJcbiAgICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XHJcbiAgICAgICAgdmFsdWUgPSBlYXNlKGVsYXBzZWQpO1xyXG4gICAgICAgIGN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgICAgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuICAgICAgICBjb250ZXh0Lm1ldGhvZC5jYWxsKGNvbnRleHQuc2Nyb2xsYWJsZSwgY3VycmVudFgsIGN1cnJlbnRZKTtcclxuICAgICAgICBpZiAoY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjdXJyZW50WSAhPT0gY29udGV4dC55KSB7XHJcbiAgICAgICAgICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAuYmluZCh3LCBjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc21vb3RoU2Nyb2xsKGVsLCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbGFibGU7XHJcbiAgICAgICAgdmFyIHN0YXJ0WDtcclxuICAgICAgICB2YXIgc3RhcnRZO1xyXG4gICAgICAgIHZhciBtZXRob2Q7XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xyXG4gICAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XHJcbiAgICAgICAgICAgIHNjcm9sbGFibGUgPSB3O1xyXG4gICAgICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjcm9sbGFibGUgPSBlbDtcclxuICAgICAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGVwKHtcclxuICAgICAgICAgICAgc2Nyb2xsYWJsZTogc2Nyb2xsYWJsZSxcclxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxyXG4gICAgICAgICAgICBzdGFydFg6IHN0YXJ0WCxcclxuICAgICAgICAgICAgc3RhcnRZOiBzdGFydFksXHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3LnNjcm9sbCA9IHcuc2Nyb2xsVG8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbCh3LCBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF1cclxuICAgICAgICAgICAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LCBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxyXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc21vb3RoU2Nyb2xsLmNhbGwodywgZC5ib2R5LCBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxyXG4gICAgICAgICAgICA6IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0LCBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcclxuICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldCk7XHJcbiAgICB9O1xyXG4gICAgdy5zY3JvbGxCeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwodywgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwLCBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxyXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnRzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgOiAwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbCh3LCBkLmJvZHksIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLCB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxyXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF1cclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc2Nyb2xsTGVmdCwgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLnRvcFxyXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMV1cclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc2Nyb2xsVG9wKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xyXG4gICAgICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMF0udG9wO1xyXG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKHRoaXMsIHRoaXMsIHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsTGVmdCA6IH5+bGVmdCwgdHlwZW9mIHRvcCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbFRvcCA6IH5+dG9wKTtcclxuICAgIH07XHJcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnRcclxuICAgICAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMF0gKyB0aGlzLnNjcm9sbExlZnQsIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcFxyXG4gICAgICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1sxXSArIHRoaXMuc2Nyb2xsVG9wKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbCh7XHJcbiAgICAgICAgICAgIGxlZnQ6IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXHJcbiAgICAgICAgICAgIHRvcDogfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3AsXHJcbiAgICAgICAgICAgIGJlaGF2aW9yOiBhcmd1bWVudHNbMF0uYmVoYXZpb3IsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjcm9sbGFibGVQYXJlbnQgPSBmaW5kU2Nyb2xsYWJsZVBhcmVudCh0aGlzKTtcclxuICAgICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xyXG4gICAgICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbCh0aGlzLCBzY3JvbGxhYmxlUGFyZW50LCBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCwgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3ApO1xyXG4gICAgICAgICAgICBpZiAody5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB3LnNjcm9sbEJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcGFyZW50UmVjdHMudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3LnNjcm9sbEJ5KHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGNsaWVudFJlY3RzLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG52YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGltZXIoYWN0aW9ucywgc3BlZWQpIHtcclxuICAgICAgICBpZiAoYWN0aW9ucyA9PT0gdm9pZCAwKSB7IGFjdGlvbnMgPSBbXTsgfVxyXG4gICAgICAgIHRoaXMudGltZU9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5yYWYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IGFjdGlvbnM7XHJcbiAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgfVxyXG4gICAgVGltZXIucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRBY3Rpb25JbmRleChhY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDAsIGFjdGlvbik7XHJcbiAgICB9O1xyXG4gICAgVGltZXIucHJvdG90eXBlLmFkZEFjdGlvbnMgPSBmdW5jdGlvbiAoYWN0aW9ucykge1xyXG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IHRoaXMuYWN0aW9ucy5jb25jYXQoYWN0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgVGltZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudGltZU9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIGxhc3RUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2soKSB7XHJcbiAgICAgICAgICAgIHZhciB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgIHNlbGYudGltZU9mZnNldCArPSAodGltZSAtIGxhc3RUaW1lc3RhbXApICogc2VsZi5zcGVlZDtcclxuICAgICAgICAgICAgbGFzdFRpbWVzdGFtcCA9IHRpbWU7XHJcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi50aW1lT2Zmc2V0ID49IGFjdGlvbi5kZWxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uZG9BY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA+IDAgfHwgc2VsZi5saXZlTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoZWNrKTtcclxuICAgIH07XHJcbiAgICBUaW1lci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmFmKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKTtcclxuICAgICAgICAgICAgdGhpcy5yYWYgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICBUaW1lci5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcclxuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICB9O1xyXG4gICAgVGltZXIucHJvdG90eXBlLnRvZ2dsZUxpdmVNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcclxuICAgICAgICB0aGlzLmxpdmVNb2RlID0gbW9kZTtcclxuICAgIH07XHJcbiAgICBUaW1lci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFmICE9PSBudWxsO1xyXG4gICAgfTtcclxuICAgIFRpbWVyLnByb3RvdHlwZS5maW5kQWN0aW9uSW5kZXggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gMDtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbbWlkXS5kZWxheSA8IGFjdGlvbi5kZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aW9uc1ttaWRdLmRlbGF5ID4gYWN0aW9uLmRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lcjtcclxufSgpKTtcclxuZnVuY3Rpb24gYWRkRGVsYXkoZXZlbnQsIGJhc2VsaW5lVGltZSkge1xyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICBldmVudC5kYXRhLnNvdXJjZSA9PT0gZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUpIHtcclxuICAgICAgICB2YXIgZmlyc3RPZmZzZXQgPSBldmVudC5kYXRhLnBvc2l0aW9uc1swXS50aW1lT2Zmc2V0O1xyXG4gICAgICAgIHZhciBmaXJzdFRpbWVzdGFtcCA9IGV2ZW50LnRpbWVzdGFtcCArIGZpcnN0T2Zmc2V0O1xyXG4gICAgICAgIGV2ZW50LmRlbGF5ID0gZmlyc3RUaW1lc3RhbXAgLSBiYXNlbGluZVRpbWU7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0VGltZXN0YW1wIC0gYmFzZWxpbmVUaW1lO1xyXG4gICAgfVxyXG4gICAgZXZlbnQuZGVsYXkgPSBldmVudC50aW1lc3RhbXAgLSBiYXNlbGluZVRpbWU7XHJcbiAgICByZXR1cm4gZXZlbnQuZGVsYXk7XHJcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiB0KHQsbil7dmFyIGU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0W1N5bWJvbC5pdGVyYXRvcl07aWYoIWUpcmV0dXJuIHQ7dmFyIHIsbyxpPWUuY2FsbCh0KSxhPVtdO3RyeXtmb3IoOyh2b2lkIDA9PT1ufHxuLS0gPjApJiYhKHI9aS5uZXh0KCkpLmRvbmU7KWEucHVzaChyLnZhbHVlKTt9Y2F0Y2godCl7bz17ZXJyb3I6dH07fWZpbmFsbHl7dHJ5e3ImJiFyLmRvbmUmJihlPWkucmV0dXJuKSYmZS5jYWxsKGkpO31maW5hbGx5e2lmKG8pdGhyb3cgby5lcnJvcn19cmV0dXJuIGF9dmFyIG47IWZ1bmN0aW9uKHQpe3RbdC5Ob3RTdGFydGVkPTBdPVwiTm90U3RhcnRlZFwiLHRbdC5SdW5uaW5nPTFdPVwiUnVubmluZ1wiLHRbdC5TdG9wcGVkPTJdPVwiU3RvcHBlZFwiO30obnx8KG49e30pKTt2YXIgZT17dHlwZTpcInhzdGF0ZS5pbml0XCJ9O2Z1bmN0aW9uIHIodCl7cmV0dXJuIHZvaWQgMD09PXQ/W106W10uY29uY2F0KHQpfWZ1bmN0aW9uIG8odCl7cmV0dXJuIHt0eXBlOlwieHN0YXRlLmFzc2lnblwiLGFzc2lnbm1lbnQ6dH19ZnVuY3Rpb24gaSQxKHQsbil7cmV0dXJuIFwic3RyaW5nXCI9PXR5cGVvZih0PVwic3RyaW5nXCI9PXR5cGVvZiB0JiZuJiZuW3RdP25bdF06dCk/e3R5cGU6dH06XCJmdW5jdGlvblwiPT10eXBlb2YgdD97dHlwZTp0Lm5hbWUsZXhlYzp0fTp0fWZ1bmN0aW9uIGEodCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0PT09bn19ZnVuY3Rpb24gdSh0KXtyZXR1cm4gXCJzdHJpbmdcIj09dHlwZW9mIHQ/e3R5cGU6dH06dH1mdW5jdGlvbiBjKHQsbil7cmV0dXJuIHt2YWx1ZTp0LGNvbnRleHQ6bixhY3Rpb25zOltdLGNoYW5nZWQ6ITEsbWF0Y2hlczphKHQpfX1mdW5jdGlvbiBmKHQsbixlKXt2YXIgcj1uLG89ITE7cmV0dXJuIFt0LmZpbHRlcigoZnVuY3Rpb24odCl7aWYoXCJ4c3RhdGUuYXNzaWduXCI9PT10LnR5cGUpe289ITA7dmFyIG49T2JqZWN0LmFzc2lnbih7fSxyKTtyZXR1cm4gXCJmdW5jdGlvblwiPT10eXBlb2YgdC5hc3NpZ25tZW50P249dC5hc3NpZ25tZW50KHIsZSk6T2JqZWN0LmtleXModC5hc3NpZ25tZW50KS5mb3JFYWNoKChmdW5jdGlvbihvKXtuW29dPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQuYXNzaWdubWVudFtvXT90LmFzc2lnbm1lbnRbb10ocixlKTp0LmFzc2lnbm1lbnRbb107fSkpLHI9biwhMX1yZXR1cm4gITB9KSkscixvXX1mdW5jdGlvbiBzKG4sbyl7dm9pZCAwPT09byYmKG89e30pO3ZhciBzPXQoZihyKG4uc3RhdGVzW24uaW5pdGlhbF0uZW50cnkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGkkMSh0LG8uYWN0aW9ucyl9KSksbi5jb250ZXh0LGUpLDIpLGw9c1swXSx2PXNbMV0seT17Y29uZmlnOm4sX29wdGlvbnM6byxpbml0aWFsU3RhdGU6e3ZhbHVlOm4uaW5pdGlhbCxhY3Rpb25zOmwsY29udGV4dDp2LG1hdGNoZXM6YShuLmluaXRpYWwpfSx0cmFuc2l0aW9uOmZ1bmN0aW9uKGUsbyl7dmFyIHMsbCx2PVwic3RyaW5nXCI9PXR5cGVvZiBlP3t2YWx1ZTplLGNvbnRleHQ6bi5jb250ZXh0fTplLHA9di52YWx1ZSxnPXYuY29udGV4dCxkPXUobykseD1uLnN0YXRlc1twXTtpZih4Lm9uKXt2YXIgbT1yKHgub25bZC50eXBlXSk7dHJ5e2Zvcih2YXIgaD1mdW5jdGlvbih0KXt2YXIgbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcixlPW4mJnRbbl0scj0wO2lmKGUpcmV0dXJuIGUuY2FsbCh0KTtpZih0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpcmV0dXJuIHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHQmJnI+PXQubGVuZ3RoJiYodD12b2lkIDApLHt2YWx1ZTp0JiZ0W3IrK10sZG9uZTohdH19fTt0aHJvdyBuZXcgVHlwZUVycm9yKG4/XCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiOlwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKX0obSksYj1oLm5leHQoKTshYi5kb25lO2I9aC5uZXh0KCkpe3ZhciBTPWIudmFsdWU7aWYodm9pZCAwPT09UylyZXR1cm4gYyhwLGcpO3ZhciB3PVwic3RyaW5nXCI9PXR5cGVvZiBTP3t0YXJnZXQ6U306UyxqPXcudGFyZ2V0LEU9dy5hY3Rpb25zLFI9dm9pZCAwPT09RT9bXTpFLE49dy5jb25kLE89dm9pZCAwPT09Tj9mdW5jdGlvbigpe3JldHVybiAhMH06TixfPXZvaWQgMD09PWosaz1udWxsIT1qP2o6cCxUPW4uc3RhdGVzW2tdO2lmKE8oZyxkKSl7dmFyIHE9dChmKChfP3IoUik6W10uY29uY2F0KHguZXhpdCxSLFQuZW50cnkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGkkMSh0LHkuX29wdGlvbnMuYWN0aW9ucyl9KSksZyxkKSwzKSx6PXFbMF0sQT1xWzFdLEI9cVsyXSxDPW51bGwhPWo/ajpwO3JldHVybiB7dmFsdWU6Qyxjb250ZXh0OkEsYWN0aW9uczp6LGNoYW5nZWQ6aiE9PXB8fHoubGVuZ3RoPjB8fEIsbWF0Y2hlczphKEMpfX19fWNhdGNoKHQpe3M9e2Vycm9yOnR9O31maW5hbGx5e3RyeXtiJiYhYi5kb25lJiYobD1oLnJldHVybikmJmwuY2FsbChoKTt9ZmluYWxseXtpZihzKXRocm93IHMuZXJyb3J9fX1yZXR1cm4gYyhwLGcpfX07cmV0dXJuIHl9dmFyIGw9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5hY3Rpb25zLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciByPWUuZXhlYztyZXR1cm4gciYmcih0LmNvbnRleHQsbil9KSl9O2Z1bmN0aW9uIHYodCl7dmFyIHI9dC5pbml0aWFsU3RhdGUsbz1uLk5vdFN0YXJ0ZWQsaT1uZXcgU2V0LGM9e19tYWNoaW5lOnQsc2VuZDpmdW5jdGlvbihlKXtvPT09bi5SdW5uaW5nJiYocj10LnRyYW5zaXRpb24ocixlKSxsKHIsdShlKSksaS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdChyKX0pKSk7fSxzdWJzY3JpYmU6ZnVuY3Rpb24odCl7cmV0dXJuIGkuYWRkKHQpLHQocikse3Vuc3Vic2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVsZXRlKHQpfX19LHN0YXJ0OmZ1bmN0aW9uKGkpe2lmKGkpe3ZhciB1PVwib2JqZWN0XCI9PXR5cGVvZiBpP2k6e2NvbnRleHQ6dC5jb25maWcuY29udGV4dCx2YWx1ZTppfTtyPXt2YWx1ZTp1LnZhbHVlLGFjdGlvbnM6W10sY29udGV4dDp1LmNvbnRleHQsbWF0Y2hlczphKHUudmFsdWUpfTt9cmV0dXJuIG89bi5SdW5uaW5nLGwocixlKSxjfSxzdG9wOmZ1bmN0aW9uKCl7cmV0dXJuIG89bi5TdG9wcGVkLGkuY2xlYXIoKSxjfSxnZXQgc3RhdGUoKXtyZXR1cm4gcn0sZ2V0IHN0YXR1cygpe3JldHVybiBvfX07cmV0dXJuIGN9XG5cbmZ1bmN0aW9uIGRpc2NhcmRQcmlvclNuYXBzaG90cyhldmVudHMsIGJhc2VsaW5lVGltZSkge1xyXG4gICAgZm9yICh2YXIgaWR4ID0gZXZlbnRzLmxlbmd0aCAtIDE7IGlkeCA+PSAwOyBpZHgtLSkge1xyXG4gICAgICAgIHZhciBldmVudF8xID0gZXZlbnRzW2lkeF07XHJcbiAgICAgICAgaWYgKGV2ZW50XzEudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuTWV0YSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRfMS50aW1lc3RhbXAgPD0gYmFzZWxpbmVUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRzLnNsaWNlKGlkeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBsYXllclNlcnZpY2UoY29udGV4dCwgX2EpIHtcclxuICAgIHZhciBnZXRDYXN0Rm4gPSBfYS5nZXRDYXN0Rm4sIGFwcGx5RXZlbnRzU3luY2hyb25vdXNseSA9IF9hLmFwcGx5RXZlbnRzU3luY2hyb25vdXNseSwgZW1pdHRlciA9IF9hLmVtaXR0ZXI7XHJcbiAgICB2YXIgcGxheWVyTWFjaGluZSA9IHMoe1xyXG4gICAgICAgIGlkOiAncGxheWVyJyxcclxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgIGluaXRpYWw6ICdwYXVzZWQnLFxyXG4gICAgICAgIHN0YXRlczoge1xyXG4gICAgICAgICAgICBwbGF5aW5nOiB7XHJcbiAgICAgICAgICAgICAgICBvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFBBVVNFOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ3BhdXNlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsncGF1c2UnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIENBU1RfRVZFTlQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncGxheWluZycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6ICdjYXN0RXZlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgRU5EOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ3BhdXNlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsncmVzZXRMYXN0UGxheWVkRXZlbnQnLCAncGF1c2UnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIEFERF9FVkVOVDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdwbGF5aW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogWydhZGRFdmVudCddLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXVzZWQ6IHtcclxuICAgICAgICAgICAgICAgIG9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgUExBWToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdwbGF5aW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogWydyZWNvcmRUaW1lT2Zmc2V0JywgJ3BsYXknXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIENBU1RfRVZFTlQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAncGF1c2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogJ2Nhc3RFdmVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBUT19MSVZFOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ2xpdmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbJ3N0YXJ0TGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgQUREX0VWRU5UOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ3BhdXNlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsnYWRkRXZlbnQnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGl2ZToge1xyXG4gICAgICAgICAgICAgICAgb246IHtcclxuICAgICAgICAgICAgICAgICAgICBBRERfRVZFTlQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnbGl2ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsnYWRkRXZlbnQnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIENBU1RfRVZFTlQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnbGl2ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsnY2FzdEV2ZW50J10sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sIHtcclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIGNhc3RFdmVudDogbyh7XHJcbiAgICAgICAgICAgICAgICBsYXN0UGxheWVkRXZlbnQ6IGZ1bmN0aW9uIChjdHgsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdDQVNUX0VWRU5UJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucGF5bG9hZC5ldmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sYXN0UGxheWVkRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcmVjb3JkVGltZU9mZnNldDogbyhmdW5jdGlvbiAoY3R4LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVPZmZzZXQgPSBjdHgudGltZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmICgncGF5bG9hZCcgaW4gZXZlbnQgJiYgJ3RpbWVPZmZzZXQnIGluIGV2ZW50LnBheWxvYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0ID0gZXZlbnQucGF5bG9hZC50aW1lT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjdHgpLCB7IHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQsIGJhc2VsaW5lVGltZTogY3R4LmV2ZW50c1swXS50aW1lc3RhbXAgKyB0aW1lT2Zmc2V0IH0pO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcGxheTogZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2M7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZXIgPSBjdHgudGltZXIsIGV2ZW50cyA9IGN0eC5ldmVudHMsIGJhc2VsaW5lVGltZSA9IGN0eC5iYXNlbGluZVRpbWUsIGxhc3RQbGF5ZWRFdmVudCA9IGN0eC5sYXN0UGxheWVkRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aW1lci5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBldmVudHNfMSA9IF9fdmFsdWVzKGV2ZW50cyksIGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCk7ICFldmVudHNfMV8xLmRvbmU7IGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBldmVudHNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZWxheShldmVudF8yLCBiYXNlbGluZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzXzFfMSAmJiAhZXZlbnRzXzFfMS5kb25lICYmIChfYSA9IGV2ZW50c18xLnJldHVybikpIF9hLmNhbGwoZXZlbnRzXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmVlZGVkRXZlbnRzID0gZGlzY2FyZFByaW9yU25hcHNob3RzKGV2ZW50cywgYmFzZWxpbmVUaW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0UGxheWVkVGltZXN0YW1wID0gbGFzdFBsYXllZEV2ZW50ID09PSBudWxsIHx8IGxhc3RQbGF5ZWRFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFBsYXllZEV2ZW50LnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgICAgIGlmICgobGFzdFBsYXllZEV2ZW50ID09PSBudWxsIHx8IGxhc3RQbGF5ZWRFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFBsYXllZEV2ZW50LnR5cGUpID09PSBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBsYXllZEV2ZW50LmRhdGEuc291cmNlID09PSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQbGF5ZWRUaW1lc3RhbXAgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGxheWVkRXZlbnQudGltZXN0YW1wICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2MgPSBsYXN0UGxheWVkRXZlbnQuZGF0YS5wb3NpdGlvbnNbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50aW1lT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChiYXNlbGluZVRpbWUgPCAobGFzdFBsYXllZFRpbWVzdGFtcCB8fCAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlBsYXlCYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzeW5jRXZlbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoZXZlbnRfMykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UGxheWVkVGltZXN0YW1wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQbGF5ZWRUaW1lc3RhbXAgPCBiYXNlbGluZVRpbWUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50XzMudGltZXN0YW1wIDw9IGxhc3RQbGF5ZWRUaW1lc3RhbXAgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XzMgPT09IGxhc3RQbGF5ZWRFdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzMudGltZXN0YW1wIDwgYmFzZWxpbmVUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNFdmVudHMucHVzaChldmVudF8zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXN0Rm5fMSA9IGdldENhc3RGbihldmVudF8zLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0FjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RGbl8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGV2ZW50XzMuZGVsYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5lZWRlZEV2ZW50c18xID0gX192YWx1ZXMobmVlZGVkRXZlbnRzKSwgbmVlZGVkRXZlbnRzXzFfMSA9IG5lZWRlZEV2ZW50c18xLm5leHQoKTsgIW5lZWRlZEV2ZW50c18xXzEuZG9uZTsgbmVlZGVkRXZlbnRzXzFfMSA9IG5lZWRlZEV2ZW50c18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMyA9IG5lZWRlZEV2ZW50c18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEoZXZlbnRfMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkZWRFdmVudHNfMV8xICYmICFuZWVkZWRFdmVudHNfMV8xLmRvbmUgJiYgKF9iID0gbmVlZGVkRXZlbnRzXzEucmV0dXJuKSkgX2IuY2FsbChuZWVkZWRFdmVudHNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcGx5RXZlbnRzU3luY2hyb25vdXNseShzeW5jRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLkZsdXNoKTtcclxuICAgICAgICAgICAgICAgIHRpbWVyLmFkZEFjdGlvbnMoYWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB0aW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRpbWVyLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2V0TGFzdFBsYXllZEV2ZW50OiBvKGZ1bmN0aW9uIChjdHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3R4KSwgeyBsYXN0UGxheWVkRXZlbnQ6IG51bGwgfSk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBzdGFydExpdmU6IG8oe1xyXG4gICAgICAgICAgICAgICAgYmFzZWxpbmVUaW1lOiBmdW5jdGlvbiAoY3R4LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC50aW1lci50b2dnbGVMaXZlTW9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHgudGltZXIuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ1RPX0xJVkUnICYmIGV2ZW50LnBheWxvYWQuYmFzZWxpbmVUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5wYXlsb2FkLmJhc2VsaW5lVGltZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgYWRkRXZlbnQ6IG8oZnVuY3Rpb24gKGN0eCwgbWFjaGluZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZWxpbmVUaW1lID0gY3R4LmJhc2VsaW5lVGltZSwgdGltZXIgPSBjdHgudGltZXIsIGV2ZW50cyA9IGN0eC5ldmVudHM7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFjaGluZUV2ZW50LnR5cGUgPT09ICdBRERfRVZFTlQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzQgPSBtYWNoaW5lRXZlbnQucGF5bG9hZC5ldmVudDtcclxuICAgICAgICAgICAgICAgICAgICBhZGREZWxheShldmVudF80LCBiYXNlbGluZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBldmVudHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1tlbmRdIHx8IGV2ZW50c1tlbmRdLnRpbWVzdGFtcCA8PSBldmVudF80LnRpbWVzdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChldmVudF80KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzW21pZF0udGltZXN0YW1wIDw9IGV2ZW50XzQudGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIGV2ZW50XzQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNTeW5jID0gZXZlbnRfNC50aW1lc3RhbXAgPCBiYXNlbGluZVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhc3RGbl8yID0gZ2V0Q2FzdEZuKGV2ZW50XzQsIGlzU3luYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXN0Rm5fMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lci5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLmFkZEFjdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0FjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RGbl8yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGV2ZW50XzQuZGVsYXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3R4KSwgeyBldmVudHM6IGV2ZW50cyB9KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHYocGxheWVyTWFjaGluZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3BlZWRTZXJ2aWNlKGNvbnRleHQpIHtcclxuICAgIHZhciBzcGVlZE1hY2hpbmUgPSBzKHtcclxuICAgICAgICBpZDogJ3NwZWVkJyxcclxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgIGluaXRpYWw6ICdub3JtYWwnLFxyXG4gICAgICAgIHN0YXRlczoge1xyXG4gICAgICAgICAgICBub3JtYWw6IHtcclxuICAgICAgICAgICAgICAgIG9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgRkFTVF9GT1JXQVJEOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ3NraXBwaW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogWydyZWNvcmRTcGVlZCcsICdzZXRTcGVlZCddLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgU0VUX1NQRUVEOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ25vcm1hbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFsnc2V0U3BlZWQnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2tpcHBpbmc6IHtcclxuICAgICAgICAgICAgICAgIG9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgQkFDS19UT19OT1JNQUw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAnbm9ybWFsJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogWydyZXN0b3JlU3BlZWQnXSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFNFVF9TUEVFRDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbJ3NldFNwZWVkJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sIHtcclxuICAgICAgICBhY3Rpb25zOiB7XHJcbiAgICAgICAgICAgIHNldFNwZWVkOiBmdW5jdGlvbiAoY3R4LCBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCdwYXlsb2FkJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC50aW1lci5zZXRTcGVlZChldmVudC5wYXlsb2FkLnNwZWVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVjb3JkU3BlZWQ6IG8oe1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsU3BlZWQ6IGZ1bmN0aW9uIChjdHgpIHsgcmV0dXJuIGN0eC50aW1lci5zcGVlZDsgfSxcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHJlc3RvcmVTcGVlZDogZnVuY3Rpb24gKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRpbWVyLnNldFNwZWVkKGN0eC5ub3JtYWxTcGVlZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHYoc3BlZWRNYWNoaW5lKTtcclxufVxuXG52YXIgcnVsZXMgPSBmdW5jdGlvbiAoYmxvY2tDbGFzcykgeyByZXR1cm4gW1xyXG4gICAgXCIuXCIuY29uY2F0KGJsb2NrQ2xhc3MsIFwiIHsgYmFja2dyb3VuZDogY3VycmVudENvbG9yIH1cIiksXHJcbiAgICAnbm9zY3JpcHQgeyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0nLFxyXG5dOyB9O1xuXG52YXIgU3R5bGVSdWxlVHlwZTtcclxuKGZ1bmN0aW9uIChTdHlsZVJ1bGVUeXBlKSB7XHJcbiAgICBTdHlsZVJ1bGVUeXBlW1N0eWxlUnVsZVR5cGVbXCJJbnNlcnRcIl0gPSAwXSA9IFwiSW5zZXJ0XCI7XHJcbiAgICBTdHlsZVJ1bGVUeXBlW1N0eWxlUnVsZVR5cGVbXCJSZW1vdmVcIl0gPSAxXSA9IFwiUmVtb3ZlXCI7XHJcbiAgICBTdHlsZVJ1bGVUeXBlW1N0eWxlUnVsZVR5cGVbXCJTbmFwc2hvdFwiXSA9IDJdID0gXCJTbmFwc2hvdFwiO1xyXG4gICAgU3R5bGVSdWxlVHlwZVtTdHlsZVJ1bGVUeXBlW1wiU2V0UHJvcGVydHlcIl0gPSAzXSA9IFwiU2V0UHJvcGVydHlcIjtcclxuICAgIFN0eWxlUnVsZVR5cGVbU3R5bGVSdWxlVHlwZVtcIlJlbW92ZVByb3BlcnR5XCJdID0gNF0gPSBcIlJlbW92ZVByb3BlcnR5XCI7XHJcbn0pKFN0eWxlUnVsZVR5cGUgfHwgKFN0eWxlUnVsZVR5cGUgPSB7fSkpO1xyXG5mdW5jdGlvbiBnZXROZXN0ZWRSdWxlKHJ1bGVzLCBwb3NpdGlvbikge1xyXG4gICAgdmFyIHJ1bGUgPSBydWxlc1twb3NpdGlvblswXV07XHJcbiAgICBpZiAocG9zaXRpb24ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmVzdGVkUnVsZShydWxlLmNzc1J1bGVzW3Bvc2l0aW9uWzFdXVxyXG4gICAgICAgICAgICAuY3NzUnVsZXMsIHBvc2l0aW9uLnNsaWNlKDIpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbnNBbmRJbmRleChuZXN0ZWRJbmRleCkge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChuZXN0ZWRJbmRleCksIGZhbHNlKTtcclxuICAgIHZhciBpbmRleCA9IHBvc2l0aW9ucy5wb3AoKTtcclxuICAgIHJldHVybiB7IHBvc2l0aW9uczogcG9zaXRpb25zLCBpbmRleDogaW5kZXggfTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVZpcnR1YWxTdHlsZVJ1bGVzVG9Ob2RlKHN0b3JlZFJ1bGVzLCBzdHlsZU5vZGUpIHtcclxuICAgIHZhciBzaGVldCA9IHN0eWxlTm9kZS5zaGVldDtcclxuICAgIGlmICghc2hlZXQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzdG9yZWRSdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gU3R5bGVSdWxlVHlwZS5JbnNlcnQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUuaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gZ2V0UG9zaXRpb25zQW5kSW5kZXgocnVsZS5pbmRleCksIHBvc2l0aW9ucyA9IF9hLnBvc2l0aW9ucywgaW5kZXggPSBfYS5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUnVsZSA9IGdldE5lc3RlZFJ1bGUoc2hlZXQuY3NzUnVsZXMsIHBvc2l0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkUnVsZS5pbnNlcnRSdWxlKHJ1bGUuY3NzVGV4dCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLmNzc1RleHQsIHJ1bGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocnVsZS50eXBlID09PSBTdHlsZVJ1bGVUeXBlLlJlbW92ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZS5pbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRQb3NpdGlvbnNBbmRJbmRleChydWxlLmluZGV4KSwgcG9zaXRpb25zID0gX2IucG9zaXRpb25zLCBpbmRleCA9IF9iLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRSdWxlID0gZ2V0TmVzdGVkUnVsZShzaGVldC5jc3NSdWxlcywgcG9zaXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSdWxlLmRlbGV0ZVJ1bGUoaW5kZXggfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKHJ1bGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocnVsZS50eXBlID09PSBTdHlsZVJ1bGVUeXBlLlNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIHJlc3RvcmVTbmFwc2hvdE9mU3R5bGVSdWxlc1RvTm9kZShydWxlLmNzc1RleHRzLCBzdHlsZU5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChydWxlLnR5cGUgPT09IFN0eWxlUnVsZVR5cGUuU2V0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdmFyIG5hdGl2ZVJ1bGUgPSBnZXROZXN0ZWRSdWxlKHNoZWV0LmNzc1J1bGVzLCBydWxlLmluZGV4KTtcclxuICAgICAgICAgICAgbmF0aXZlUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShydWxlLnByb3BlcnR5LCBydWxlLnZhbHVlLCBydWxlLnByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocnVsZS50eXBlID09PSBTdHlsZVJ1bGVUeXBlLlJlbW92ZVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBuYXRpdmVSdWxlID0gZ2V0TmVzdGVkUnVsZShzaGVldC5jc3NSdWxlcywgcnVsZS5pbmRleCk7XHJcbiAgICAgICAgICAgIG5hdGl2ZVJ1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocnVsZS5wcm9wZXJ0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVzdG9yZVNuYXBzaG90T2ZTdHlsZVJ1bGVzVG9Ob2RlKGNzc1RleHRzLCBzdHlsZU5vZGUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nUnVsZXMgPSBBcnJheS5mcm9tKCgoX2EgPSBzdHlsZU5vZGUuc2hlZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jc3NSdWxlcykgfHwgW10pLm1hcChmdW5jdGlvbiAocnVsZSkgeyByZXR1cm4gcnVsZS5jc3NUZXh0OyB9KTtcclxuICAgICAgICB2YXIgZXhpc3RpbmdSdWxlc1JldmVyc2VkID0gT2JqZWN0LmVudHJpZXMoZXhpc3RpbmdSdWxlcykucmV2ZXJzZSgpO1xyXG4gICAgICAgIHZhciBsYXN0TWF0Y2hfMSA9IGV4aXN0aW5nUnVsZXMubGVuZ3RoO1xyXG4gICAgICAgIGV4aXN0aW5nUnVsZXNSZXZlcnNlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChfYSwgMiksIGluZGV4ID0gX2NbMF0sIHJ1bGUgPSBfY1sxXTtcclxuICAgICAgICAgICAgdmFyIGluZGV4T2YgPSBjc3NUZXh0cy5pbmRleE9mKHJ1bGUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhPZiA9PT0gLTEgfHwgaW5kZXhPZiA+IGxhc3RNYXRjaF8xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHN0eWxlTm9kZS5zaGVldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlbGV0ZVJ1bGUoTnVtYmVyKGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RNYXRjaF8xID0gaW5kZXhPZjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjc3NUZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjc3NUZXh0LCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gc3R5bGVOb2RlLnNoZWV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3NzUnVsZXNbaW5kZXhdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3NzVGV4dCkgIT09IGNzc1RleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBzdHlsZU5vZGUuc2hlZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbnNlcnRSdWxlKGNzc1RleHQsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0b3JlQ1NTUnVsZXMocGFyZW50RWxlbWVudCwgdmlydHVhbFN0eWxlUnVsZXNNYXApIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGNzc1RleHRzID0gQXJyYXkuZnJvbSgoKF9hID0gcGFyZW50RWxlbWVudC5zaGVldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzKSB8fCBbXSkubWFwKGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiBydWxlLmNzc1RleHQ7IH0pO1xyXG4gICAgICAgIHZpcnR1YWxTdHlsZVJ1bGVzTWFwLnNldChwYXJlbnRFbGVtZW50LCBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN0eWxlUnVsZVR5cGUuU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICBjc3NUZXh0czogY3NzVGV4dHMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG59XG5cbnZhciB3ZWJHTFZhck1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gdmFyaWFibGVMaXN0Rm9yKGN0eCwgY3Rvcikge1xyXG4gICAgdmFyIGNvbnRleHRNYXAgPSB3ZWJHTFZhck1hcC5nZXQoY3R4KTtcclxuICAgIGlmICghY29udGV4dE1hcCkge1xyXG4gICAgICAgIGNvbnRleHRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgd2ViR0xWYXJNYXAuc2V0KGN0eCwgY29udGV4dE1hcCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNvbnRleHRNYXAuaGFzKGN0b3IpKSB7XHJcbiAgICAgICAgY29udGV4dE1hcC5zZXQoY3RvciwgW10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHRNYXAuZ2V0KGN0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRleHQodGFyZ2V0LCB0eXBlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSBDYW52YXNDb250ZXh0LldlYkdMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGFyZ2V0LmdldENvbnRleHQoJ3dlYmdsJykgfHwgdGFyZ2V0LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRDb250ZXh0KCd3ZWJnbDInKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxudmFyIFdlYkdMVmFyaWFibGVDb25zdHJ1Y3RvcnNOYW1lcyA9IFtcclxuICAgICdXZWJHTEFjdGl2ZUluZm8nLFxyXG4gICAgJ1dlYkdMQnVmZmVyJyxcclxuICAgICdXZWJHTEZyYW1lYnVmZmVyJyxcclxuICAgICdXZWJHTFByb2dyYW0nLFxyXG4gICAgJ1dlYkdMUmVuZGVyYnVmZmVyJyxcclxuICAgICdXZWJHTFNoYWRlcicsXHJcbiAgICAnV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQnLFxyXG4gICAgJ1dlYkdMVGV4dHVyZScsXHJcbiAgICAnV2ViR0xVbmlmb3JtTG9jYXRpb24nLFxyXG4gICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3QnLFxyXG5dO1xyXG5mdW5jdGlvbiBzYXZlVG9XZWJHTFZhck1hcChjdHgsIHJlc3VsdCkge1xyXG4gICAgaWYgKCEocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmNvbnN0cnVjdG9yKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgbmFtZSA9IHJlc3VsdC5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgaWYgKCFXZWJHTFZhcmlhYmxlQ29uc3RydWN0b3JzTmFtZXMuaW5jbHVkZXMobmFtZSkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHZhcmlhYmxlcyA9IHZhcmlhYmxlTGlzdEZvcihjdHgsIG5hbWUpO1xyXG4gICAgaWYgKCF2YXJpYWJsZXMuaW5jbHVkZXMocmVzdWx0KSlcclxuICAgICAgICB2YXJpYWJsZXMucHVzaChyZXN1bHQpO1xyXG59XHJcbmZ1bmN0aW9uIGRlc2VyaWFsaXplQXJnKGltYWdlTWFwLCBjdHgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgaWYgKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAncnJfdHlwZScgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgIGlmICgnaW5kZXgnIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGFyZy5ycl90eXBlLCBpbmRleCA9IGFyZy5pbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZUxpc3RGb3IoY3R4LCBuYW1lXzEpW2luZGV4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnYXJncycgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gYXJnLnJyX3R5cGUsIGFyZ3MgPSBhcmcuYXJncztcclxuICAgICAgICAgICAgICAgIHZhciBjdG9yID0gd2luZG93W25hbWVfMl07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IChjdG9yLmJpbmQuYXBwbHkoY3RvciwgX19zcHJlYWRBcnJheShbdm9pZCAwXSwgX19yZWFkKGFyZ3MubWFwKGRlc2VyaWFsaXplQXJnKGltYWdlTWFwLCBjdHgpKSksIGZhbHNlKSkpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2Jhc2U2NCcgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKGFyZy5iYXNlNjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdzcmMnIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gaW1hZ2VNYXAuZ2V0KGFyZy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlXzEgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZV8xLnNyYyA9IGFyZy5zcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXAuc2V0KGFyZy5zcmMsIGltYWdlXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbWFnZV8xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJnLm1hcChkZXNlcmlhbGl6ZUFyZyhpbWFnZU1hcCwgY3R4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHdlYmdsTXV0YXRpb24oX2EpIHtcclxuICAgIHZhciBtdXRhdGlvbiA9IF9hLm11dGF0aW9uLCB0YXJnZXQgPSBfYS50YXJnZXQsIHR5cGUgPSBfYS50eXBlLCBpbWFnZU1hcCA9IF9hLmltYWdlTWFwLCBlcnJvckhhbmRsZXIgPSBfYS5lcnJvckhhbmRsZXI7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgobXV0YXRpb24ucHJvcGVydHkgPT09ICdkYXRhVVJMJyB8fCBtdXRhdGlvbi5wcm9wZXJ0eSA9PT0gJ2FuaURhdGFVUkwnKSAmJiB0eXBlb2YgbXV0YXRpb24uYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlXzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICAgICAgaW1hZ2VfMi5zcmMgPSBtdXRhdGlvbi5hcmdzWzBdO1xyXG4gICAgICAgICAgICBpbWFnZV8yLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdHgyZCA9IHRhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN0eDJkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4MmQuY2xlYXJSZWN0KDAsIDAsIGltYWdlXzIud2lkdGgsIGltYWdlXzIuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBjdHgyZC5kcmF3SW1hZ2UoaW1hZ2VfMiwgMCwgMCwgaW1hZ2VfMi53aWR0aCwgaW1hZ2VfMi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSBnZXRDb250ZXh0KHRhcmdldCwgdHlwZSk7XHJcbiAgICAgICAgaWYgKCFjdHgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAobXV0YXRpb24uc2V0dGVyKSB7XHJcbiAgICAgICAgICAgIGN0eFttdXRhdGlvbi5wcm9wZXJ0eV0gPSBtdXRhdGlvbi5hcmdzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGN0eFttdXRhdGlvbi5wcm9wZXJ0eV07XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBtdXRhdGlvbi5hcmdzLm1hcChkZXNlcmlhbGl6ZUFyZyhpbWFnZU1hcCwgY3R4KSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KGN0eCwgYXJncyk7XHJcbiAgICAgICAgc2F2ZVRvV2ViR0xWYXJNYXAoY3R4LCByZXN1bHQpO1xyXG4gICAgICAgIHZhciBkZWJ1Z01vZGUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZGVidWdNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5wcm9wZXJ0eSA9PT0gJ2NvbXBpbGVTaGFkZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN0eC5nZXRTaGFkZXJQYXJhbWV0ZXIoYXJnc1swXSwgY3R4LkNPTVBJTEVfU1RBVFVTKSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NvbWV0aGluZyB3ZW50IHdyb25nIGluIHJlcGxheScsIGN0eC5nZXRTaGFkZXJJbmZvTG9nKGFyZ3NbMF0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtdXRhdGlvbi5wcm9wZXJ0eSA9PT0gJ2xpbmtQcm9ncmFtJykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnZhbGlkYXRlUHJvZ3JhbShhcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgIGlmICghY3R4LmdldFByb2dyYW1QYXJhbWV0ZXIoYXJnc1swXSwgY3R4LkxJTktfU1RBVFVTKSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NvbWV0aGluZyB3ZW50IHdyb25nIGluIHJlcGxheScsIGN0eC5nZXRQcm9ncmFtSW5mb0xvZyhhcmdzWzBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdlYmdsRXJyb3IgPSBjdHguZ2V0RXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKHdlYmdsRXJyb3IgIT09IGN0eC5OT19FUlJPUikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoWydXRUJHTCBFUlJPUicsXHJcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xFcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAnb24gY29tbWFuZDonLFxyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLnByb3BlcnR5XSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKG11dGF0aW9uLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY2FudmFzTXV0YXRpb24kMShfYSkge1xyXG4gICAgdmFyIGV2ZW50ID0gX2EuZXZlbnQsIG11dGF0aW9uID0gX2EubXV0YXRpb24sIHRhcmdldCA9IF9hLnRhcmdldCwgaW1hZ2VNYXAgPSBfYS5pbWFnZU1hcCwgZXJyb3JIYW5kbGVyID0gX2EuZXJyb3JIYW5kbGVyO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgY3R4XzEgPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBpZiAobXV0YXRpb24uc2V0dGVyKSB7XHJcbiAgICAgICAgICAgIGN0eF8xW211dGF0aW9uLnByb3BlcnR5XSA9IG11dGF0aW9uLmFyZ3NbMF07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gY3R4XzFbbXV0YXRpb24ucHJvcGVydHldO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbi5wcm9wZXJ0eSA9PT0gJ2RyYXdJbWFnZScgJiZcclxuICAgICAgICAgICAgdHlwZW9mIG11dGF0aW9uLmFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGltYWdlTWFwLmdldChldmVudCk7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRpb24uYXJnc1swXSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkoY3R4XzEsIG11dGF0aW9uLmFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IG11dGF0aW9uLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbi5hcmdzWzBdID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseShjdHhfMSwgbXV0YXRpb24uYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKG11dGF0aW9uLnByb3BlcnR5ID09PSAnZGF0YVVSTCcgfHwgbXV0YXRpb24ucHJvcGVydHkgPT09ICdhbmlEYXRhVVJMJykgJiYgdHlwZW9mIG11dGF0aW9uLmFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWFnZV8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgIGltYWdlXzEuc3JjID0gbXV0YXRpb24uYXJnc1swXTtcclxuICAgICAgICAgICAgaW1hZ2VfMS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3R4XzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhfMS5kcmF3SW1hZ2UoaW1hZ2VfMSwgMCwgMCwgaW1hZ2VfMS53aWR0aCwgaW1hZ2VfMS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbC5hcHBseShjdHhfMSwgbXV0YXRpb24uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKG11dGF0aW9uLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY2FudmFzTXV0YXRpb24oX2EpIHtcclxuICAgIHZhciBldmVudCA9IF9hLmV2ZW50LCBtdXRhdGlvbiA9IF9hLm11dGF0aW9uLCB0YXJnZXQgPSBfYS50YXJnZXQsIGltYWdlTWFwID0gX2EuaW1hZ2VNYXAsIGVycm9ySGFuZGxlciA9IF9hLmVycm9ySGFuZGxlcjtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG11dGF0aW9ucyA9ICdjb21tYW5kcycgaW4gbXV0YXRpb24gPyBtdXRhdGlvbi5jb21tYW5kcyA6IFttdXRhdGlvbl07XHJcbiAgICAgICAgaWYgKFtDYW52YXNDb250ZXh0LldlYkdMLCBDYW52YXNDb250ZXh0LldlYkdMMl0uaW5jbHVkZXMobXV0YXRpb24udHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5wcm9wZXJ0eSA9PT0gJ2RhdGFVUkwnIHx8IGNvbW1hbmQucHJvcGVydHkgPT09ICdhbmlEYXRhVVJMJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmdsTXV0YXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbjogeyBwcm9wZXJ0eTogY29tbWFuZC5wcm9wZXJ0eSwgYXJnczogY29tbWFuZFsnYXJncyddIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG11dGF0aW9uLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU1hcDogaW1hZ2VNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xNdXRhdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiBjb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtdXRhdGlvbi50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VNYXA6IGltYWdlTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xyXG4gICAgICAgICAgICBjYW52YXNNdXRhdGlvbiQxKHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uOiBjb21tYW5kLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBpbWFnZU1hcDogaW1hZ2VNYXAsXHJcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvckhhbmRsZXIobXV0YXRpb24sIGVycm9yKTtcclxuICAgIH1cclxufVxuXG52YXIgU0tJUF9USU1FX1RIUkVTSE9MRCA9IDEwICogMTAwMDtcclxudmFyIFNLSVBfVElNRV9JTlRFUlZBTCA9IDUgKiAxMDAwO1xyXG52YXIgbWl0dCA9IG1pdHQkMSB8fCBtaXR0UHJveHk7XHJcbnZhciBSRVBMQVlfQ09OU09MRV9QUkVGSVggPSAnW3JlcGxheWVyXSc7XHJcbnZhciBkZWZhdWx0TW91c2VUYWlsQ29uZmlnID0ge1xyXG4gICAgZHVyYXRpb246IDUwMCxcclxuICAgIGxpbmVDYXA6ICdyb3VuZCcsXHJcbiAgICBsaW5lV2lkdGg6IDMsXHJcbiAgICBzdHJva2VTdHlsZTogJ3JlZCcsXHJcbn07XHJcbmZ1bmN0aW9uIGluZGljYXRlc1RvdWNoRGV2aWNlKGUpIHtcclxuICAgIHJldHVybiAoZS50eXBlID09IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICAoZS5kYXRhLnNvdXJjZSA9PSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSB8fFxyXG4gICAgICAgICAgICAoZS5kYXRhLnNvdXJjZSA9PSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS50eXBlID09IGV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hTdGFydCkpKTtcclxufVxyXG52YXIgUmVwbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVwbGF5ZXIoZXZlbnRzLCBjb25maWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubW91c2VUYWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWxQb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBtaXR0KCk7XHJcbiAgICAgICAgdGhpcy5sZWdhY3lfbWlzc2luZ05vZGVSZXRyeU1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBjcmVhdGVNaXJyb3IoKTtcclxuICAgICAgICB0aGlzLmZpcnN0RnVsbFNuYXBzaG90ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5ld0RvY3VtZW50UXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRvdWNoQWN0aXZlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1pc3NzZWRRdWV1ZU5vZGVUcmVlcyA9IFtdO1xyXG4gICAgICAgIGlmICghKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5saXZlTW9kZSkgJiYgZXZlbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXBsYXllciBuZWVkIGF0IGxlYXN0IDIgZXZlbnRzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGVmYXVsdENvbmZpZyA9IHtcclxuICAgICAgICAgICAgc3BlZWQ6IDEsXHJcbiAgICAgICAgICAgIG1heFNwZWVkOiAzNjAsXHJcbiAgICAgICAgICAgIHJvb3Q6IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgICAgIGxvYWRUaW1lb3V0OiAwLFxyXG4gICAgICAgICAgICBza2lwSW5hY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93V2FybmluZzogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvd0RlYnVnOiBmYWxzZSxcclxuICAgICAgICAgICAgYmxvY2tDbGFzczogJ3JyLWJsb2NrJyxcclxuICAgICAgICAgICAgbGl2ZU1vZGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbnNlcnRTdHlsZVJ1bGVzOiBbXSxcclxuICAgICAgICAgICAgdHJpZ2dlckZvY3VzOiB0cnVlLFxyXG4gICAgICAgICAgICBVTlNBRkVfcmVwbGF5Q2FudmFzOiBmYWxzZSxcclxuICAgICAgICAgICAgcGF1c2VBbmltYXRpb246IHRydWUsXHJcbiAgICAgICAgICAgIG1vdXNlVGFpbDogZGVmYXVsdE1vdXNlVGFpbENvbmZpZyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgY29uZmlnKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IHRoaXMuaGFuZGxlUmVzaXplLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5nZXRDYXN0Rm4gPSB0aGlzLmdldENhc3RGbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlFdmVudHNTeW5jaHJvbm91c2x5ID0gdGhpcy5hcHBseUV2ZW50c1N5bmNocm9ub3VzbHkuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXhwb3J0cy5SZXBsYXllckV2ZW50cy5SZXNpemUsIHRoaXMuaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB0aGlzLnNldHVwRG9tKCk7XHJcbiAgICAgICAgdGhpcy50cmVlSW5kZXggPSBuZXcgVHJlZUluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFBhcmVudE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRTdGF0ZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnZpcnR1YWxTdHlsZVJ1bGVzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5vbihleHBvcnRzLlJlcGxheWVyRXZlbnRzLkZsdXNoLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jO1xyXG4gICAgICAgICAgICB2YXIgX2QgPSBfdGhpcy50cmVlSW5kZXguZmx1c2goKSwgc2Nyb2xsTWFwID0gX2Quc2Nyb2xsTWFwLCBpbnB1dE1hcCA9IF9kLmlucHV0TWFwO1xyXG4gICAgICAgICAgICBfdGhpcy5mcmFnbWVudFBhcmVudE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQsIGZyYWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXN0b3JlUmVhbFBhcmVudChmcmFnLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXMoX3RoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAua2V5cygpKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gX2YudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdG9yZU5vZGVTaGVldChub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYSA9IF9lLnJldHVybikpIF9hLmNhbGwoX2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsZW1lbnRTdGF0ZU1hcC5jbGVhcigpO1xyXG4gICAgICAgICAgICBfdGhpcy52aXJ0dWFsU3R5bGVSdWxlc01hcC5jbGVhcigpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2cgPSBfX3ZhbHVlcyhzY3JvbGxNYXAudmFsdWVzKCkpLCBfaCA9IF9nLm5leHQoKTsgIV9oLmRvbmU7IF9oID0gX2cubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfaC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hcHBseVNjcm9sbChkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oICYmICFfaC5kb25lICYmIChfYiA9IF9nLnJldHVybikpIF9iLmNhbGwoX2cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IF9fdmFsdWVzKGlucHV0TWFwLnZhbHVlcygpKSwgX2sgPSBfai5uZXh0KCk7ICFfay5kb25lOyBfayA9IF9qLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXBwbHlJbnB1dChkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9rICYmICFfay5kb25lICYmIChfYyA9IF9qLnJldHVybikpIF9jLmNhbGwoX2opO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuUGxheUJhY2ssIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZmlyc3RGdWxsU25hcHNob3QgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5taXJyb3IucmVzZXQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgdGltZXIgPSBuZXcgVGltZXIoW10sIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuc3BlZWQpIHx8IGRlZmF1bHRDb25maWcuc3BlZWQpO1xyXG4gICAgICAgIHRoaXMuc2VydmljZSA9IGNyZWF0ZVBsYXllclNlcnZpY2Uoe1xyXG4gICAgICAgICAgICBldmVudHM6IGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcudW5wYWNrRm4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLnVucGFja0ZuKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYTEsIGEyKSB7IHJldHVybiBhMS50aW1lc3RhbXAgLSBhMi50aW1lc3RhbXA7IH0pLFxyXG4gICAgICAgICAgICB0aW1lcjogdGltZXIsXHJcbiAgICAgICAgICAgIHRpbWVPZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIGJhc2VsaW5lVGltZTogMCxcclxuICAgICAgICAgICAgbGFzdFBsYXllZEV2ZW50OiBudWxsLFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgZ2V0Q2FzdEZuOiB0aGlzLmdldENhc3RGbixcclxuICAgICAgICAgICAgYXBwbHlFdmVudHNTeW5jaHJvbm91c2x5OiB0aGlzLmFwcGx5RXZlbnRzU3luY2hyb25vdXNseSxcclxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5zdGFydCgpO1xyXG4gICAgICAgIHRoaXMuc2VydmljZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlN0YXRlQ2hhbmdlLCB7XHJcbiAgICAgICAgICAgICAgICBwbGF5ZXI6IHN0YXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNwZWVkU2VydmljZSA9IGNyZWF0ZVNwZWVkU2VydmljZSh7XHJcbiAgICAgICAgICAgIG5vcm1hbFNwZWVkOiAtMSxcclxuICAgICAgICAgICAgdGltZXI6IHRpbWVyLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3BlZWRTZXJ2aWNlLnN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5zcGVlZFNlcnZpY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5TdGF0ZUNoYW5nZSwge1xyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHN0YXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgZmlyc3RNZXRhID0gdGhpcy5zZXJ2aWNlLnN0YXRlLmNvbnRleHQuZXZlbnRzLmZpbmQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuTWV0YTsgfSk7XHJcbiAgICAgICAgdmFyIGZpcnN0RnVsbHNuYXBzaG90ID0gdGhpcy5zZXJ2aWNlLnN0YXRlLmNvbnRleHQuZXZlbnRzLmZpbmQoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuRnVsbFNuYXBzaG90OyB9KTtcclxuICAgICAgICBpZiAoZmlyc3RNZXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IGZpcnN0TWV0YS5kYXRhLCB3aWR0aF8xID0gX2Eud2lkdGgsIGhlaWdodF8xID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlJlc2l6ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aF8xLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XzEsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdEZ1bGxzbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5maXJzdEZ1bGxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0RnVsbFNuYXBzaG90ID0gZmlyc3RGdWxsc25hcHNob3Q7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWJ1aWxkRnVsbFNuYXBzaG90KGZpcnN0RnVsbHNuYXBzaG90KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZS5jb250ZW50V2luZG93LnNjcm9sbFRvKGZpcnN0RnVsbHNuYXBzaG90LmRhdGEuaW5pdGlhbE9mZnNldCk7XHJcbiAgICAgICAgICAgIH0sIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlLnN0YXRlLmNvbnRleHQuZXZlbnRzLmZpbmQoaW5kaWNhdGVzVG91Y2hEZXZpY2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2UuY2xhc3NMaXN0LmFkZCgndG91Y2gtZGV2aWNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcGxheWVyLnByb3RvdHlwZSwgXCJ0aW1lclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Uuc3RhdGUuY29udGV4dC50aW1lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgX3RoaXMuY29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNraXBJbmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tUb05vcm1hbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5zcGVlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zcGVlZFNlcnZpY2Uuc2VuZCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX1NQRUVEJyxcclxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVlZDogY29uZmlnLnNwZWVkLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLm1vdXNlVGFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tb3VzZVRhaWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3VzZVRhaWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlVGFpbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vdXNlVGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2VUYWlsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3VzZVRhaWwud2lkdGggPSBOdW1iZXIucGFyc2VGbG9hdCh0aGlzLmlmcmFtZS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3VzZVRhaWwuaGVpZ2h0ID0gTnVtYmVyLnBhcnNlRmxvYXQodGhpcy5pZnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlVGFpbC5jbGFzc0xpc3QuYWRkKCdyZXBsYXllci1tb3VzZS10YWlsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLm1vdXNlVGFpbCwgdGhpcy5pZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVRhaWwuc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuZ2V0TWV0YURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0RXZlbnQgPSB0aGlzLnNlcnZpY2Uuc3RhdGUuY29udGV4dC5ldmVudHNbMF07XHJcbiAgICAgICAgdmFyIGxhc3RFdmVudCA9IHRoaXMuc2VydmljZS5zdGF0ZS5jb250ZXh0LmV2ZW50c1t0aGlzLnNlcnZpY2Uuc3RhdGUuY29udGV4dC5ldmVudHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnRUaW1lOiBmaXJzdEV2ZW50LnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgZW5kVGltZTogbGFzdEV2ZW50LnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgdG90YWxUaW1lOiBsYXN0RXZlbnQudGltZXN0YW1wIC0gZmlyc3RFdmVudC50aW1lc3RhbXAsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIudGltZU9mZnNldCArIHRoaXMuZ2V0VGltZU9mZnNldCgpO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5nZXRUaW1lT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuc2VydmljZS5zdGF0ZS5jb250ZXh0LCBiYXNlbGluZVRpbWUgPSBfYS5iYXNlbGluZVRpbWUsIGV2ZW50cyA9IF9hLmV2ZW50cztcclxuICAgICAgICByZXR1cm4gYmFzZWxpbmVUaW1lIC0gZXZlbnRzWzBdLnRpbWVzdGFtcDtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuZ2V0TWlycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pcnJvcjtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICh0aW1lT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aW1lT2Zmc2V0ID09PSB2b2lkIDApIHsgdGltZU9mZnNldCA9IDA7IH1cclxuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlLnN0YXRlLm1hdGNoZXMoJ3BhdXNlZCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5zZW5kKHsgdHlwZTogJ1BMQVknLCBwYXlsb2FkOiB7IHRpbWVPZmZzZXQ6IHRpbWVPZmZzZXQgfSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5zZW5kKHsgdHlwZTogJ1BBVVNFJyB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLnNlbmQoeyB0eXBlOiAnUExBWScsIHBheWxvYWQ6IHsgdGltZU9mZnNldDogdGltZU9mZnNldCB9IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoX2EgPSB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmNsYXNzTGlzdC5yZW1vdmUoJ3Jyd2ViLXBhdXNlZCcpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuU3RhcnQpO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aW1lT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5zZXJ2aWNlLnN0YXRlLm1hdGNoZXMoJ3BsYXlpbmcnKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZpY2Uuc2VuZCh7IHR5cGU6ICdQQVVTRScgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGltZU9mZnNldCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KHRpbWVPZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZpY2Uuc2VuZCh7IHR5cGU6ICdQQVVTRScgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYSA9IHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uY2xhc3NMaXN0LmFkZCgncnJ3ZWItcGF1c2VkJyk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5QYXVzZSk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICh0aW1lT2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHRpbWVPZmZzZXQgPT09IHZvaWQgMCkgeyB0aW1lT2Zmc2V0ID0gMDsgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSAncmVzdW1lJyB3aWxsIGJlIGRlcGFydGVkIGluIDEuMC4gUGxlYXNlIHVzZSAncGxheScgbWV0aG9kIHdoaWNoIGhhcyB0aGUgc2FtZSBpbnRlcmZhY2UuXCIpO1xyXG4gICAgICAgIHRoaXMucGxheSh0aW1lT2Zmc2V0KTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlJlc3VtZSk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLnN0YXJ0TGl2ZSA9IGZ1bmN0aW9uIChiYXNlbGluZVRpbWUpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2Uuc2VuZCh7IHR5cGU6ICdUT19MSVZFJywgcGF5bG9hZDogeyBiYXNlbGluZVRpbWU6IGJhc2VsaW5lVGltZSB9IH0pO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChyYXdFdmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5jb25maWcudW5wYWNrRm5cclxuICAgICAgICAgICAgPyB0aGlzLmNvbmZpZy51bnBhY2tGbihyYXdFdmVudClcclxuICAgICAgICAgICAgOiByYXdFdmVudDtcclxuICAgICAgICBpZiAoaW5kaWNhdGVzVG91Y2hEZXZpY2UoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2UuY2xhc3NMaXN0LmFkZCgndG91Y2gtZGV2aWNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5zZW5kKHsgdHlwZTogJ0FERF9FVkVOVCcsIHBheWxvYWQ6IHsgZXZlbnQ6IGV2ZW50IH0gfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmVuYWJsZUludGVyYWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaWZyYW1lLnNldEF0dHJpYnV0ZSgnc2Nyb2xsaW5nJywgJ2F1dG8nKTtcclxuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5kaXNhYmxlSW50ZXJhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKCdzY3JvbGxpbmcnLCAnbm8nKTtcclxuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5yZXNldENhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5zZXR1cERvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB0aGlzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCgncmVwbGF5ZXItd3JhcHBlcicpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcclxuICAgICAgICB0aGlzLm1vdXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5jbGFzc0xpc3QuYWRkKCdyZXBsYXllci1tb3VzZScpO1xyXG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm1vdXNlKTtcclxuICAgICAgICBpZiAodGhpcy5jb25maWcubW91c2VUYWlsICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlVGFpbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlVGFpbC5jbGFzc0xpc3QuYWRkKCdyZXBsYXllci1tb3VzZS10YWlsJyk7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VUYWlsLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XHJcbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm1vdXNlVGFpbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbJ2FsbG93LXNhbWUtb3JpZ2luJ107XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLlVOU0FGRV9yZXBsYXlDYW52YXMpIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKCdhbGxvdy1zY3JpcHRzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5pZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgYXR0cmlidXRlcy5qb2luKCcgJykpO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZUludGVyYWN0KCk7XHJcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcclxuICAgICAgICBpZiAodGhpcy5pZnJhbWUuY29udGVudFdpbmRvdyAmJiB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgcG9seWZpbGwodGhpcy5pZnJhbWUuY29udGVudFdpbmRvdywgdGhpcy5pZnJhbWUuY29udGVudERvY3VtZW50KTtcclxuICAgICAgICAgICAgcG9seWZpbGwkMSh0aGlzLmlmcmFtZS5jb250ZW50V2luZG93KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcclxuICAgICAgICB2YXIgZV80LCBfYTtcclxuICAgICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoW3RoaXMubW91c2VUYWlsLCB0aGlzLmlmcmFtZV0pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBTdHJpbmcoZGltZW5zaW9uLndpZHRoKSk7XHJcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIFN0cmluZyhkaW1lbnNpb24uaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5hcHBseUV2ZW50c1N5bmNocm9ub3VzbHkgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XHJcbiAgICAgICAgdmFyIGVfNSwgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRzXzEgPSBfX3ZhbHVlcyhldmVudHMpLCBldmVudHNfMV8xID0gZXZlbnRzXzEubmV4dCgpOyAhZXZlbnRzXzFfMS5kb25lOyBldmVudHNfMV8xID0gZXZlbnRzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50XzEudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FdmVudFR5cGUuRG9tQ29udGVudExvYWRlZDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuRXZlbnRUeXBlLkxvYWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLkV2ZW50VHlwZS5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FdmVudFR5cGUuRnVsbFNuYXBzaG90OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FdmVudFR5cGUuTWV0YTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuRXZlbnRUeXBlLlBsdWdpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50XzEuZGF0YS5zb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjYXN0Rm4gPSB0aGlzLmdldENhc3RGbihldmVudF8xLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNhc3RGbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzXzFfMSAmJiAhZXZlbnRzXzFfMS5kb25lICYmIChfYSA9IGV2ZW50c18xLnJldHVybikpIF9hLmNhbGwoZXZlbnRzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubW91c2VQb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlQW5kSG92ZXIodGhpcy5tb3VzZVBvcy54LCB0aGlzLm1vdXNlUG9zLnksIHRoaXMubW91c2VQb3MuaWQsIHRydWUsIHRoaXMubW91c2VQb3MuZGVidWdEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb3VzZVBvcyA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMudG91Y2hBY3RpdmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5jbGFzc0xpc3QuYWRkKCd0b3VjaC1hY3RpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy50b3VjaEFjdGl2ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZS5jbGFzc0xpc3QucmVtb3ZlKCd0b3VjaC1hY3RpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b3VjaEFjdGl2ZSA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmdldENhc3RGbiA9IGZ1bmN0aW9uIChldmVudCwgaXNTeW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXNTeW5jID09PSB2b2lkIDApIHsgaXNTeW5jID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgY2FzdEZuO1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQ6XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FdmVudFR5cGUuTG9hZDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRXZlbnRUeXBlLkN1c3RvbTpcclxuICAgICAgICAgICAgICAgIGNhc3RGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5DdXN0b21FdmVudCwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuRXZlbnRUeXBlLk1ldGE6XHJcbiAgICAgICAgICAgICAgICBjYXN0Rm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlJlc2l6ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZXZlbnQuZGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBldmVudC5kYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkV2ZW50VHlwZS5GdWxsU25hcHNob3Q6XHJcbiAgICAgICAgICAgICAgICBjYXN0Rm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpcnN0RnVsbFNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5maXJzdEZ1bGxTbmFwc2hvdCA9PT0gZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0RnVsbFNuYXBzaG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RGdWxsU25hcHNob3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWJ1aWxkRnVsbFNuYXBzaG90KGV2ZW50LCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZS5jb250ZW50V2luZG93LnNjcm9sbFRvKGV2ZW50LmRhdGEuaW5pdGlhbE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDpcclxuICAgICAgICAgICAgICAgIGNhc3RGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZV82LCBfYTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hcHBseUluY3JlbWVudGFsKGV2ZW50LCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09IF90aGlzLm5leHRVc2VySW50ZXJhY3Rpb25FdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uZXh0VXNlckludGVyYWN0aW9uRXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5iYWNrVG9Ob3JtYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5za2lwSW5hY3RpdmUgJiYgIV90aGlzLm5leHRVc2VySW50ZXJhY3Rpb25FdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5zZXJ2aWNlLnN0YXRlLmNvbnRleHQuZXZlbnRzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZXZlbnQgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2V2ZW50LnRpbWVzdGFtcCA8PSBldmVudC50aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1VzZXJJbnRlcmFjdGlvbihfZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZXZlbnQuZGVsYXkgLSBldmVudC5kZWxheSA+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTS0lQX1RJTUVfVEhSRVNIT0xEICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zcGVlZFNlcnZpY2Uuc3RhdGUuY29udGV4dC50aW1lci5zcGVlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmV4dFVzZXJJbnRlcmFjdGlvbkV2ZW50ID0gX2V2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5uZXh0VXNlckludGVyYWN0aW9uRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwVGltZSA9IF90aGlzLm5leHRVc2VySW50ZXJhY3Rpb25FdmVudC5kZWxheSAtIGV2ZW50LmRlbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IE1hdGgubWluKE1hdGgucm91bmQoc2tpcFRpbWUgLyBTS0lQX1RJTUVfSU5URVJWQUwpLCBfdGhpcy5jb25maWcubWF4U3BlZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNwZWVkU2VydmljZS5zZW5kKHsgdHlwZTogJ0ZBU1RfRk9SV0FSRCcsIHBheWxvYWQ6IHBheWxvYWQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5Ta2lwU3RhcnQsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd3JhcHBlZENhc3RGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVfNywgX2E7XHJcbiAgICAgICAgICAgIGlmIChjYXN0Rm4pIHtcclxuICAgICAgICAgICAgICAgIGNhc3RGbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKF90aGlzLmNvbmZpZy5wbHVnaW5zIHx8IFtdKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW4gPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaGFuZGxlcihldmVudCwgaXNTeW5jLCB7IHJlcGxheWVyOiBfdGhpcyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV83XzEpIHsgZV83ID0geyBlcnJvcjogZV83XzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnNlcnZpY2Uuc2VuZCh7IHR5cGU6ICdDQVNUX0VWRU5UJywgcGF5bG9hZDogeyBldmVudDogZXZlbnQgfSB9KTtcclxuICAgICAgICAgICAgdmFyIGxhc3RfaW5kZXggPSBfdGhpcy5zZXJ2aWNlLnN0YXRlLmNvbnRleHQuZXZlbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gX3RoaXMuc2VydmljZS5zdGF0ZS5jb250ZXh0LmV2ZW50c1tsYXN0X2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0X2luZGV4IDwgX3RoaXMuc2VydmljZS5zdGF0ZS5jb250ZXh0LmV2ZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmFja1RvTm9ybWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VydmljZS5zZW5kKCdFTkQnKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5GaW5pc2gpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBleHBvcnRzLkV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5zb3VyY2UgPT09IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5wb3NpdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaF8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgTWF0aC5tYXgoMCwgLWV2ZW50LmRhdGEucG9zaXRpb25zWzBdLnRpbWVPZmZzZXQgKyA1MCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoXzEoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5FdmVudENhc3QsIGV2ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB3cmFwcGVkQ2FzdEZuO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5yZWJ1aWxkRnVsbFNuYXBzaG90ID0gZnVuY3Rpb24gKGV2ZW50LCBpc1N5bmMpIHtcclxuICAgICAgICB2YXIgZV84LCBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpc1N5bmMgPT09IHZvaWQgMCkgeyBpc1N5bmMgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICghdGhpcy5pZnJhbWUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ0xvb2tzIGxpa2UgeW91ciByZXBsYXllciBoYXMgYmVlbiBkZXN0cm95ZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmxlZ2FjeV9taXNzaW5nTm9kZVJldHJ5TWFwKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb3VuZCB1bnJlc29sdmVkIG1pc3Npbmcgbm9kZSBtYXAnLCB0aGlzLmxlZ2FjeV9taXNzaW5nTm9kZVJldHJ5TWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWdhY3lfbWlzc2luZ05vZGVSZXRyeU1hcCA9IHt9O1xyXG4gICAgICAgIHZhciBjb2xsZWN0ZWQgPSBbXTtcclxuICAgICAgICB0aGlzLm1pcnJvci5tYXAgPSByZWJ1aWxkKGV2ZW50LmRhdGEubm9kZSwge1xyXG4gICAgICAgICAgICBkb2M6IHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudCxcclxuICAgICAgICAgICAgYWZ0ZXJBcHBlbmQ6IGZ1bmN0aW9uIChidWlsdE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbGxlY3RJZnJhbWVBbmRBdHRhY2hEb2N1bWVudChjb2xsZWN0ZWQsIGJ1aWx0Tm9kZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxyXG4gICAgICAgIH0pWzFdO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG11dGF0aW9uSW5RdWV1ZSwgYnVpbHROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXNfMS5hdHRhY2hEb2N1bWVudFRvSWZyYW1lKG11dGF0aW9uSW5RdWV1ZSwgYnVpbHROb2RlKTtcclxuICAgICAgICAgICAgdGhpc18xLm5ld0RvY3VtZW50UXVldWUgPSB0aGlzXzEubmV3RG9jdW1lbnRRdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09IG11dGF0aW9uSW5RdWV1ZTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChidWlsdE5vZGUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2QgPSBidWlsdE5vZGUuY29udGVudERvY3VtZW50LCBkb2N1bWVudEVsZW1lbnRfMSA9IF9kLmRvY3VtZW50RWxlbWVudCwgaGVhZF8xID0gX2QuaGVhZDtcclxuICAgICAgICAgICAgICAgIHRoaXNfMS5pbnNlcnRTdHlsZVJ1bGVzKGRvY3VtZW50RWxlbWVudF8xLCBoZWFkXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2xsZWN0ZWRfMSA9IF9fdmFsdWVzKGNvbGxlY3RlZCksIGNvbGxlY3RlZF8xXzEgPSBjb2xsZWN0ZWRfMS5uZXh0KCk7ICFjb2xsZWN0ZWRfMV8xLmRvbmU7IGNvbGxlY3RlZF8xXzEgPSBjb2xsZWN0ZWRfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbGxlY3RlZF8xXzEudmFsdWUsIG11dGF0aW9uSW5RdWV1ZSA9IF9iLm11dGF0aW9uSW5RdWV1ZSwgYnVpbHROb2RlID0gX2IuYnVpbHROb2RlO1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShtdXRhdGlvbkluUXVldWUsIGJ1aWx0Tm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfOF8xKSB7IGVfOCA9IHsgZXJyb3I6IGVfOF8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWRfMV8xICYmICFjb2xsZWN0ZWRfMV8xLmRvbmUgJiYgKF9hID0gY29sbGVjdGVkXzEucmV0dXJuKSkgX2EuY2FsbChjb2xsZWN0ZWRfMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2MgPSB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQsIGRvY3VtZW50RWxlbWVudCA9IF9jLmRvY3VtZW50RWxlbWVudCwgaGVhZCA9IF9jLmhlYWQ7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRTdHlsZVJ1bGVzKGRvY3VtZW50RWxlbWVudCwgaGVhZCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2Uuc3RhdGUubWF0Y2hlcygncGxheWluZycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF1cclxuICAgICAgICAgICAgICAgIC5jbGFzc0xpc3QuYWRkKCdycndlYi1wYXVzZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5GdWxsc25hcHNob3RSZWJ1aWxkZWQsIGV2ZW50KTtcclxuICAgICAgICBpZiAoIWlzU3luYykge1xyXG4gICAgICAgICAgICB0aGlzLndhaXRGb3JTdHlsZXNoZWV0TG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuVU5TQUZFX3JlcGxheUNhbnZhcykge1xyXG4gICAgICAgICAgICB0aGlzLnByZWxvYWRBbGxJbWFnZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmluc2VydFN0eWxlUnVsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnRFbGVtZW50LCBoZWFkKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgIGRvY3VtZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoc3R5bGVFbCwgaGVhZCk7XHJcbiAgICAgICAgdmFyIGluamVjdFN0eWxlc1J1bGVzID0gcnVsZXModGhpcy5jb25maWcuYmxvY2tDbGFzcykuY29uY2F0KHRoaXMuY29uZmlnLmluc2VydFN0eWxlUnVsZXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5wYXVzZUFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICBpbmplY3RTdHlsZXNSdWxlcy5wdXNoKCdodG1sLnJyd2ViLXBhdXNlZCAqLCBodG1sLnJyd2ViLXBhdXNlZCAqOmJlZm9yZSwgaHRtbC5ycndlYi1wYXVzZWQgKjphZnRlciB7IGFuaW1hdGlvbi1wbGF5LXN0YXRlOiBwYXVzZWQgIWltcG9ydGFudDsgfScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpbmplY3RTdHlsZXNSdWxlcy5sZW5ndGg7IGlkeCsrKSB7XHJcbiAgICAgICAgICAgIHN0eWxlRWwuc2hlZXQuaW5zZXJ0UnVsZShpbmplY3RTdHlsZXNSdWxlc1tpZHhdLCBpZHgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuYXR0YWNoRG9jdW1lbnRUb0lmcmFtZSA9IGZ1bmN0aW9uIChtdXRhdGlvbiwgaWZyYW1lRWwpIHtcclxuICAgICAgICB2YXIgZV85LCBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb2xsZWN0ZWQgPSBbXTtcclxuICAgICAgICBpZiAoIWlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBpZnJhbWVFbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50XzEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYWdtZW50UGFyZW50TWFwLmhhcyhwYXJlbnRfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZyA9IHBhcmVudF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFsUGFyZW50ID0gdGhpcy5mcmFnbWVudFBhcmVudE1hcC5nZXQoZnJhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlUmVhbFBhcmVudChmcmFnLCByZWFsUGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudF8xID0gcGFyZW50XzEucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBidWlsZE5vZGVXaXRoU04obXV0YXRpb24ubm9kZSwge1xyXG4gICAgICAgICAgICBkb2M6IGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCxcclxuICAgICAgICAgICAgbWFwOiB0aGlzLm1pcnJvci5tYXAsXHJcbiAgICAgICAgICAgIGhhY2tDc3M6IHRydWUsXHJcbiAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFmdGVyQXBwZW5kOiBmdW5jdGlvbiAoYnVpbHROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xsZWN0SWZyYW1lQW5kQXR0YWNoRG9jdW1lbnQoY29sbGVjdGVkLCBidWlsdE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0Tm9kZS5fX3NuLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICBidWlsdE5vZGUuX19zbi50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdIVE1MJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCwgZG9jdW1lbnRFbGVtZW50ID0gX2EuZG9jdW1lbnRFbGVtZW50LCBoZWFkID0gX2EuaGVhZDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRTdHlsZVJ1bGVzKGRvY3VtZW50RWxlbWVudCwgaGVhZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKG11dGF0aW9uSW5RdWV1ZSwgYnVpbHROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXNfMi5hdHRhY2hEb2N1bWVudFRvSWZyYW1lKG11dGF0aW9uSW5RdWV1ZSwgYnVpbHROb2RlKTtcclxuICAgICAgICAgICAgdGhpc18yLm5ld0RvY3VtZW50UXVldWUgPSB0aGlzXzIubmV3RG9jdW1lbnRRdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09IG11dGF0aW9uSW5RdWV1ZTsgfSk7XHJcbiAgICAgICAgICAgIGlmIChidWlsdE5vZGUuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBidWlsdE5vZGUuY29udGVudERvY3VtZW50LCBkb2N1bWVudEVsZW1lbnQgPSBfYy5kb2N1bWVudEVsZW1lbnQsIGhlYWQgPSBfYy5oZWFkO1xyXG4gICAgICAgICAgICAgICAgdGhpc18yLmluc2VydFN0eWxlUnVsZXMoZG9jdW1lbnRFbGVtZW50LCBoZWFkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMiA9IHRoaXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgY29sbGVjdGVkXzIgPSBfX3ZhbHVlcyhjb2xsZWN0ZWQpLCBjb2xsZWN0ZWRfMl8xID0gY29sbGVjdGVkXzIubmV4dCgpOyAhY29sbGVjdGVkXzJfMS5kb25lOyBjb2xsZWN0ZWRfMl8xID0gY29sbGVjdGVkXzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBjb2xsZWN0ZWRfMl8xLnZhbHVlLCBtdXRhdGlvbkluUXVldWUgPSBfYi5tdXRhdGlvbkluUXVldWUsIGJ1aWx0Tm9kZSA9IF9iLmJ1aWx0Tm9kZTtcclxuICAgICAgICAgICAgICAgIF9sb29wXzIobXV0YXRpb25JblF1ZXVlLCBidWlsdE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzlfMSkgeyBlXzkgPSB7IGVycm9yOiBlXzlfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkXzJfMSAmJiAhY29sbGVjdGVkXzJfMS5kb25lICYmIChfYSA9IGNvbGxlY3RlZF8yLnJldHVybikpIF9hLmNhbGwoY29sbGVjdGVkXzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmNvbGxlY3RJZnJhbWVBbmRBdHRhY2hEb2N1bWVudCA9IGZ1bmN0aW9uIChjb2xsZWN0ZWQsIGJ1aWx0Tm9kZSkge1xyXG4gICAgICAgIGlmIChpc0lmcmFtZUlOb2RlKGJ1aWx0Tm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIG11dGF0aW9uSW5RdWV1ZSA9IHRoaXMubmV3RG9jdW1lbnRRdWV1ZS5maW5kKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnBhcmVudElkID09PSBidWlsdE5vZGUuX19zbi5pZDsgfSk7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbkluUXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKHsgbXV0YXRpb25JblF1ZXVlOiBtdXRhdGlvbkluUXVldWUsIGJ1aWx0Tm9kZTogYnVpbHROb2RlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS53YWl0Rm9yU3R5bGVzaGVldExvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGhlYWQgPSAoX2EgPSB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFkO1xyXG4gICAgICAgIGlmIChoZWFkKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmxvYWRTaGVldHNfMSA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdmFyIHRpbWVyXzE7XHJcbiAgICAgICAgICAgIHZhciBiZWZvcmVMb2FkU3RhdGVfMSA9IHRoaXMuc2VydmljZS5zdGF0ZTtcclxuICAgICAgICAgICAgdmFyIHN0YXRlSGFuZGxlcl8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlTG9hZFN0YXRlXzEgPSBfdGhpcy5zZXJ2aWNlLnN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXhwb3J0cy5SZXBsYXllckV2ZW50cy5TdGFydCwgc3RhdGVIYW5kbGVyXzEpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXhwb3J0cy5SZXBsYXllckV2ZW50cy5QYXVzZSwgc3RhdGVIYW5kbGVyXzEpO1xyXG4gICAgICAgICAgICB2YXIgdW5zdWJzY3JpYmVfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIub2ZmKGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuU3RhcnQsIHN0YXRlSGFuZGxlcl8xKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIub2ZmKGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuUGF1c2UsIHN0YXRlSGFuZGxlcl8xKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVhZFxyXG4gICAgICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXScpXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY3NzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNzcy5zaGVldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVubG9hZFNoZWV0c18xLmFkZChjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNzcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxvYWRTaGVldHNfMS5kZWxldGUoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVubG9hZFNoZWV0c18xLnNpemUgPT09IDAgJiYgdGltZXJfMSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVMb2FkU3RhdGVfMS5tYXRjaGVzKCdwbGF5aW5nJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbGF5KF90aGlzLmdldEN1cnJlbnRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci5lbWl0KGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuTG9hZFN0eWxlc2hlZXRFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZV8xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh1bmxvYWRTaGVldHNfMS5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLnNlbmQoeyB0eXBlOiAnUEFVU0UnIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXhwb3J0cy5SZXBsYXllckV2ZW50cy5Mb2FkU3R5bGVzaGVldFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHRpbWVyXzEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlTG9hZFN0YXRlXzEubWF0Y2hlcygncGxheWluZycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoX3RoaXMuZ2V0Q3VycmVudFRpbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyXzEgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZV8xKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5sb2FkVGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmhhc0ltYWdlQXJnID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICB2YXIgZV8xMCwgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYXJnc18xID0gX192YWx1ZXMoYXJncyksIGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKTsgIWFyZ3NfMV8xLmRvbmU7IGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmcgfHwgdHlwZW9mIGFyZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdycl90eXBlJyBpbiBhcmcgJiYgJ2FyZ3MnIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0ltYWdlQXJnKGFyZy5hcmdzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgncnJfdHlwZScgaW4gYXJnICYmIGFyZy5ycl90eXBlID09PSAnSFRNTEltYWdlRWxlbWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzSW1hZ2VBcmcoYXJnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMTBfMSkgeyBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzXzFfMSAmJiAhYXJnc18xXzEuZG9uZSAmJiAoX2EgPSBhcmdzXzEucmV0dXJuKSkgX2EuY2FsbChhcmdzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMCkgdGhyb3cgZV8xMC5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmdldEltYWdlQXJncyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgdmFyIGVfMTEsIF9hO1xyXG4gICAgICAgIHZhciBpbWFnZXMgPSBbXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhcmdzXzIgPSBfX3ZhbHVlcyhhcmdzKSwgYXJnc18yXzEgPSBhcmdzXzIubmV4dCgpOyAhYXJnc18yXzEuZG9uZTsgYXJnc18yXzEgPSBhcmdzXzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc18yXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyZyB8fCB0eXBlb2YgYXJnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3JyX3R5cGUnIGluIGFyZyAmJiAnYXJncycgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2guYXBwbHkoaW1hZ2VzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodGhpcy5nZXRJbWFnZUFyZ3MoYXJnLmFyZ3MpKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdycl90eXBlJyBpbiBhcmcgJiYgYXJnLnJyX3R5cGUgPT09ICdIVE1MSW1hZ2VFbGVtZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGFyZy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZXMucHVzaC5hcHBseShpbWFnZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLmdldEltYWdlQXJncyhhcmcpKSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xMV8xKSB7IGVfMTEgPSB7IGVycm9yOiBlXzExXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NfMl8xICYmICFhcmdzXzJfMS5kb25lICYmIChfYSA9IGFyZ3NfMi5yZXR1cm4pKSBfYS5jYWxsKGFyZ3NfMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzExKSB0aHJvdyBlXzExLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZXM7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLnByZWxvYWRBbGxJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMTIsIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlLnN0YXRlO1xyXG4gICAgICAgIHZhciBzdGF0ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNlcnZpY2Uuc3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXhwb3J0cy5SZXBsYXllckV2ZW50cy5TdGFydCwgc3RhdGVIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIub24oZXhwb3J0cy5SZXBsYXllckV2ZW50cy5QYXVzZSwgc3RhdGVIYW5kbGVyKTtcclxuICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChldmVudF8yKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudF8yLnR5cGUgPT09IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgICAgIGV2ZW50XzIuZGF0YS5zb3VyY2UgPT09IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb24pXHJcbiAgICAgICAgICAgICAgICBpZiAoJ2NvbW1hbmRzJyBpbiBldmVudF8yLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudF8yLmRhdGEuY29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMucHJlbG9hZEltYWdlcyhjLCBldmVudF8yKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzMucHJlbG9hZEltYWdlcyhldmVudF8yLmRhdGEsIGV2ZW50XzIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMyA9IHRoaXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnNlcnZpY2Uuc3RhdGUuY29udGV4dC5ldmVudHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMiA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMyhldmVudF8yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xMl8xKSB7IGVfMTIgPSB7IGVycm9yOiBlXzEyXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMikgdGhyb3cgZV8xMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uIChkYXRhLCBldmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGRhdGEucHJvcGVydHkgPT09ICdkcmF3SW1hZ2UnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBkYXRhLmFyZ3NbMF0gPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICF0aGlzLmltYWdlTWFwLmhhcyhldmVudCkpIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHZhciBpbWdkID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmNyZWF0ZUltYWdlRGF0YShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBpbWdkID09PSBudWxsIHx8IGltZ2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltZ2QuZGF0YTtcclxuICAgICAgICAgICAgSlNPTi5wYXJzZShkYXRhLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucHV0SW1hZ2VEYXRhKGltZ2QsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0ltYWdlQXJnKGRhdGEuYXJncykpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRJbWFnZUFyZ3MoZGF0YS5hcmdzKS5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW1hZ2VNYXAuc2V0KHVybCwgaW1hZ2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmFwcGx5SW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoZSwgaXNTeW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBkID0gZS5kYXRhO1xyXG4gICAgICAgIHN3aXRjaCAoZC5zb3VyY2UpIHtcclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk11dGF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5hZGRzLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF90aGlzLnRyZWVJbmRleC5hZGQobSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGQudGV4dHMuZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXR1cm4gX3RoaXMudHJlZUluZGV4LnRleHQobSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBfdGhpcy50cmVlSW5kZXguYXR0cmlidXRlKG0pOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkLnJlbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXR1cm4gX3RoaXMudHJlZUluZGV4LnJlbW92ZShtLCBfdGhpcy5taXJyb3IpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseU11dGF0aW9uKGQsIGlzU3luYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm4oXCJFeGNlcHRpb24gaW4gbXV0YXRpb24gXCIuY29uY2F0KGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpLCBkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5EcmFnOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuVG91Y2hNb3ZlOlxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBkLnBvc2l0aW9uc1tkLnBvc2l0aW9ucy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlUG9zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBsYXN0UG9zaXRpb24ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbGFzdFBvc2l0aW9uLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBsYXN0UG9zaXRpb24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnRGF0YTogZCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5wb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9BY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb3ZlQW5kSG92ZXIocC54LCBwLnksIHAuaWQsIGlzU3luYywgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IHAudGltZU9mZnNldCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50aW1lc3RhbXAgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlcnZpY2Uuc3RhdGUuY29udGV4dC5iYXNlbGluZVRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLmFkZEFjdGlvbihhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXIuYWRkQWN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9BY3Rpb246IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGUuZGVsYXkgLSAoKF9hID0gZC5wb3NpdGlvbnNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aW1lT2Zmc2V0KSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuaWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMyA9IG5ldyBFdmVudChleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zW2QudHlwZV0udG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5taXJyb3IuZ2V0Tm9kZShkLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdOb2RlTm90Rm91bmQoZCwgZC5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLk1vdXNlSW50ZXJhY3Rpb24sIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciB0cmlnZ2VyRm9jdXMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyRm9jdXM7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Nb3VzZUludGVyYWN0aW9ucy5CbHVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ2JsdXInIGluIHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmJsdXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMuRm9jdXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyRm9jdXMgJiYgdGFyZ2V0LmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2s6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC50eXBlID09PSBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQudHlwZSA9PT0gZXhwb3J0cy5Nb3VzZUludGVyYWN0aW9ucy5Ub3VjaEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2VQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGQueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZC5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0RhdGE6IGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQudHlwZSA9PT0gZXhwb3J0cy5Nb3VzZUludGVyYWN0aW9ucy5Ub3VjaFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsUG9zaXRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVBbmRIb3ZlcihkLngsIGQueSwgZC5pZCwgaXNTeW5jLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLnR5cGUgPT09IGV4cG9ydHMuTW91c2VJbnRlcmFjdGlvbnMuQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5tb3VzZS5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZC50eXBlID09PSBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMubW91c2Uub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3VzZS5jbGFzc0xpc3QuYWRkKCd0b3VjaC1hY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQudHlwZSA9PT0gZXhwb3J0cy5Nb3VzZUludGVyYWN0aW9ucy5Ub3VjaEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW91c2UuY2xhc3NMaXN0LnJlbW92ZSgndG91Y2gtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLk1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoQ2FuY2VsOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlLmNsYXNzTGlzdC5yZW1vdmUoJ3RvdWNoLWFjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLlNjcm9sbDoge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuaWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlSW5kZXguc2Nyb2xsKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVNjcm9sbChkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuVmlld3BvcnRSZXNpemU6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChleHBvcnRzLlJlcGxheWVyRXZlbnRzLlJlc2l6ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6IHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmlkID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUluZGV4LmlucHV0KGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUlucHV0KGQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLm1pcnJvci5nZXROb2RlKGQuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z05vZGVOb3RGb3VuZChkLCBkLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtZWRpYUVsID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5jdXJyZW50VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYUVsLmN1cnJlbnRUaW1lID0gZC5jdXJyZW50VGltZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQudm9sdW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRWwudm9sdW1lID0gZC52b2x1bWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLm11dGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRWwubXV0ZWQgPSBkLm11dGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC50eXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhRWwucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQudHlwZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYUVsLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc2hvd1dhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHJlcGxheSBtZWRpYSBpbnRlcmFjdGlvbnM6IFwiLmNvbmNhdChlcnJvci5tZXNzYWdlIHx8IGVycm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLlN0eWxlU2hlZXRSdWxlOiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5taXJyb3IuZ2V0Tm9kZShkLmlkKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdOb2RlTm90Rm91bmQoZCwgZC5pZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVFbCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMiA9IHRhcmdldC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVzaW5nVmlydHVhbFBhcmVudF8xID0gdGhpcy5mcmFnbWVudFBhcmVudE1hcC5oYXMocGFyZW50XzIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlU2hlZXRfMSA9IHVzaW5nVmlydHVhbFBhcmVudF8xID8gbnVsbCA6IHN0eWxlRWwuc2hlZXQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgcnVsZXNfMTtcclxuICAgICAgICAgICAgICAgIGlmICghc3R5bGVTaGVldF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXNfMSA9IHRoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlc18xID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAuc2V0KHRhcmdldCwgcnVsZXNfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuYWRkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuYWRkcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IF9hLnJ1bGUsIG5lc3RlZEluZGV4ID0gX2EuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVNoZWV0XzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldFBvc2l0aW9uc0FuZEluZGV4KG5lc3RlZEluZGV4KSwgcG9zaXRpb25zID0gX2IucG9zaXRpb25zLCBpbmRleCA9IF9iLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUnVsZSA9IGdldE5lc3RlZFJ1bGUoc3R5bGVTaGVldF8xLmNzc1J1bGVzLCBwb3NpdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSdWxlLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbmVzdGVkSW5kZXggPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4obmVzdGVkSW5kZXgsIHN0eWxlU2hlZXRfMS5jc3NSdWxlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0XzEuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzXzEgPT09IG51bGwgfHwgcnVsZXNfMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnVsZXNfMS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBydWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXN0ZWRJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTdHlsZVJ1bGVUeXBlLkluc2VydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yZW1vdmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5yZW1vdmVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRJbmRleCA9IF9hLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNpbmdWaXJ0dWFsUGFyZW50XzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzXzEgPT09IG51bGwgfHwgcnVsZXNfMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnVsZXNfMS5wdXNoKHsgaW5kZXg6IG5lc3RlZEluZGV4LCB0eXBlOiBTdHlsZVJ1bGVUeXBlLlJlbW92ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGdldFBvc2l0aW9uc0FuZEluZGV4KG5lc3RlZEluZGV4KSwgcG9zaXRpb25zID0gX2IucG9zaXRpb25zLCBpbmRleCA9IF9iLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkUnVsZSA9IGdldE5lc3RlZFJ1bGUoc3R5bGVTaGVldF8xLmNzc1J1bGVzLCBwb3NpdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSdWxlLmRlbGV0ZVJ1bGUoaW5kZXggfHwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0XzEgPT09IG51bGwgfHwgc3R5bGVTaGVldF8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZVNoZWV0XzEuZGVsZXRlUnVsZShuZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb246IHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLm1pcnJvci5nZXROb2RlKGQuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z05vZGVOb3RGb3VuZChkLCBkLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZUVsID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8zID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXNpbmdWaXJ0dWFsUGFyZW50ID0gdGhpcy5mcmFnbWVudFBhcmVudE1hcC5oYXMocGFyZW50XzMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlU2hlZXQgPSB1c2luZ1ZpcnR1YWxQYXJlbnQgPyBudWxsIDogc3R5bGVFbC5zaGVldDtcclxuICAgICAgICAgICAgICAgIHZhciBydWxlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSB0aGlzLnZpcnR1YWxTdHlsZVJ1bGVzTWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsU3R5bGVSdWxlc01hcC5zZXQodGFyZ2V0LCBydWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBnZXROZXN0ZWRSdWxlKHN0eWxlU2hlZXQucnVsZXMsIGQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlLnNldFByb3BlcnR5KGQuc2V0LnByb3BlcnR5LCBkLnNldC52YWx1ZSwgZC5zZXQucHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaChfX2Fzc2lnbih7IHR5cGU6IFN0eWxlUnVsZVR5cGUuU2V0UHJvcGVydHksIGluZGV4OiBkLmluZGV4IH0sIGQuc2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGQucmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlU2hlZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBnZXROZXN0ZWRSdWxlKHN0eWxlU2hlZXQucnVsZXMsIGQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGQucmVtb3ZlLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2goX19hc3NpZ24oeyB0eXBlOiBTdHlsZVJ1bGVUeXBlLlJlbW92ZVByb3BlcnR5LCBpbmRleDogZC5pbmRleCB9LCBkLnJlbW92ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5JbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5VTlNBRkVfcmVwbGF5Q2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMubWlycm9yLmdldE5vZGUoZC5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYnVnTm9kZU5vdEZvdW5kKGQsIGQuaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FudmFzTXV0YXRpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxyXG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uOiBkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlTWFwOiB0aGlzLmltYWdlTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdGhpcy53YXJuQ2FudmFzTXV0YXRpb25GYWlsZWQuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLkZvbnQ6IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGQuZmFtaWx5LCBkLmJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KEpTT04ucGFyc2UoZC5mb250U291cmNlKSkgOiBkLmZvbnRTb3VyY2UsIGQuZGVzY3JpcHRvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvbnRzLmFkZChmb250RmFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc2hvd1dhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuYXBwbHlNdXRhdGlvbiA9IGZ1bmN0aW9uIChkLCB1c2VWaXJ0dWFsUGFyZW50KSB7XHJcbiAgICAgICAgdmFyIGVfMTMsIF9hO1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZC5yZW1vdmVzLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5taXJyb3IuZ2V0Tm9kZShtdXRhdGlvbi5pZCk7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yZW1vdmVzLmZpbmQoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuaWQgPT09IG11dGF0aW9uLnBhcmVudElkOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy53YXJuTm9kZU5vdEZvdW5kKGQsIG11dGF0aW9uLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMudmlydHVhbFN0eWxlUnVsZXNNYXAuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpcnR1YWxTdHlsZVJ1bGVzTWFwLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpcy5taXJyb3IuZ2V0Tm9kZShtdXRhdGlvbi5wYXJlbnRJZCk7XHJcbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMud2Fybk5vZGVOb3RGb3VuZChkLCBtdXRhdGlvbi5wYXJlbnRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmlzU2hhZG93ICYmIGhhc1NoYWRvd1Jvb3QocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMubWlycm9yLnJlbW92ZU5vZGVGcm9tTWFwKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWFsVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciByZWFsUGFyZW50ID0gJ19fc24nIGluIHBhcmVudCA/IF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmdldChwYXJlbnQpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWxQYXJlbnQgJiYgcmVhbFBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcmVhbFBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbFRhcmdldCA9IF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHJlYWxUYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndhcm4oJ3BhcmVudCBjb3VsZCBub3QgcmVtb3ZlIGNoaWxkIGluIG11dGF0aW9uJywgcGFyZW50LCByZWFsUGFyZW50LCB0YXJnZXQsIHJlYWxUYXJnZXQsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGxlZ2FjeV9taXNzaW5nTm9kZU1hcCA9IF9fYXNzaWduKHt9LCB0aGlzLmxlZ2FjeV9taXNzaW5nTm9kZVJldHJ5TWFwKTtcclxuICAgICAgICB2YXIgcXVldWUgPSBbXTtcclxuICAgICAgICB2YXIgbmV4dE5vdEluRE9NID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLm5leHRJZCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IF90aGlzLm1pcnJvci5nZXROb2RlKG11dGF0aW9uLm5leHRJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLm5leHRJZCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgbXV0YXRpb24ubmV4dElkICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uLm5leHRJZCAhPT0gLTEgJiZcclxuICAgICAgICAgICAgICAgICFuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYXBwZW5kTm9kZSA9IGZ1bmN0aW9uIChtdXRhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgZV8xNCwgX2E7XHJcbiAgICAgICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignTG9va3MgbGlrZSB5b3VyIHJlcGxheWVyIGhhcyBiZWVuIGRlc3Ryb3llZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gX3RoaXMubWlycm9yLmdldE5vZGUobXV0YXRpb24ucGFyZW50SWQpO1xyXG4gICAgICAgICAgICBpZiAoIXBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLm5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubmV3RG9jdW1lbnRRdWV1ZS5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZS5wdXNoKG11dGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pZnJhbWUuY29udGVudERvY3VtZW50LmNvbnRhaW5zKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRJbkRvY3VtZW50ID0gX3RoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jb250YWlucyhwYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5jb250YWlucykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50SW5Eb2N1bWVudCA9IF90aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5jb250YWlucyhwYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoYXNJZnJhbWVDaGlsZCA9ICgoX2MgPSAoX2IgPSBwYXJlbnQpLmdldEVsZW1lbnRzQnlUYWdOYW1lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgJ2lmcmFtZScpLmxlbmd0aCkgPiAwO1xyXG4gICAgICAgICAgICBpZiAodXNlVmlydHVhbFBhcmVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGFyZW50SW5Eb2N1bWVudCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzSWZyYW1lSU5vZGUocGFyZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgIWhhc0lmcmFtZUNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlydHVhbFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5tYXBbbXV0YXRpb24ucGFyZW50SWRdID0gdmlydHVhbFBhcmVudDtcclxuICAgICAgICAgICAgICAgIF90aGlzLmZyYWdtZW50UGFyZW50TWFwLnNldCh2aXJ0dWFsUGFyZW50LCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RvcmVTdGF0ZShwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlydHVhbFBhcmVudC5hcHBlbmRDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB2aXJ0dWFsUGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5ub2RlLmlzU2hhZG93KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NoYWRvd1Jvb3QocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIG5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ucHJldmlvdXNJZCkge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBfdGhpcy5taXJyb3IuZ2V0Tm9kZShtdXRhdGlvbi5wcmV2aW91c0lkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ubmV4dElkKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gX3RoaXMubWlycm9yLmdldE5vZGUobXV0YXRpb24ubmV4dElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dE5vdEluRE9NKG11dGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLnB1c2gobXV0YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5ub2RlLnJvb3RJZCAmJiAhX3RoaXMubWlycm9yLmdldE5vZGUobXV0YXRpb24ubm9kZS5yb290SWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhcmdldERvYyA9IG11dGF0aW9uLm5vZGUucm9vdElkXHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLm1pcnJvci5nZXROb2RlKG11dGF0aW9uLm5vZGUucm9vdElkKVxyXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5pZnJhbWUuY29udGVudERvY3VtZW50O1xyXG4gICAgICAgICAgICBpZiAoaXNJZnJhbWVJTm9kZShwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRhY2hEb2N1bWVudFRvSWZyYW1lKG11dGF0aW9uLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBidWlsZE5vZGVXaXRoU04obXV0YXRpb24ubm9kZSwge1xyXG4gICAgICAgICAgICAgICAgZG9jOiB0YXJnZXREb2MsXHJcbiAgICAgICAgICAgICAgICBtYXA6IF90aGlzLm1pcnJvci5tYXAsXHJcbiAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoYWNrQ3NzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2FjaGU6IF90aGlzLmNhY2hlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnByZXZpb3VzSWQgPT09IC0xIHx8IG11dGF0aW9uLm5leHRJZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2FjeV9taXNzaW5nTm9kZU1hcFttdXRhdGlvbi5ub2RlLmlkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb246IG11dGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJ19fc24nIGluIHBhcmVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9fc24udHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9fc24udGFnTmFtZSA9PT0gJ3RleHRhcmVhJyAmJlxyXG4gICAgICAgICAgICAgICAgbXV0YXRpb24ubm9kZS50eXBlID09PSBOb2RlVHlwZS5UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gX192YWx1ZXMoQXJyYXkuZnJvbShwYXJlbnQuY2hpbGROb2RlcykpLCBfZSA9IF9kLm5leHQoKTsgIV9lLmRvbmU7IF9lID0gX2QubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gX2UudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLm5vZGVUeXBlID09PSBwYXJlbnQuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xNF8xKSB7IGVfMTQgPSB7IGVycm9yOiBlXzE0XzEgfTsgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lICYmICFfZS5kb25lICYmIChfYSA9IF9kLnJldHVybikpIF9hLmNhbGwoX2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTQpIHRocm93IGVfMTQuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgcHJldmlvdXMubmV4dFNpYmxpbmcgJiYgcHJldmlvdXMubmV4dFNpYmxpbmcucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIHByZXZpb3VzLm5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ICYmIG5leHQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbnRhaW5zKG5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgbmV4dClcclxuICAgICAgICAgICAgICAgICAgICA6IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHRhcmdldERvYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXREb2MuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREb2MucmVtb3ZlQ2hpbGQodGFyZ2V0RG9jLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0lmcmFtZUlOb2RlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbkluUXVldWVfMSA9IF90aGlzLm5ld0RvY3VtZW50UXVldWUuZmluZChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnRJZCA9PT0gdGFyZ2V0Ll9fc24uaWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uSW5RdWV1ZV8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0YWNoRG9jdW1lbnRUb0lmcmFtZShtdXRhdGlvbkluUXVldWVfMSwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uZXdEb2N1bWVudFF1ZXVlID0gX3RoaXMubmV3RG9jdW1lbnRRdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gIT09IG11dGF0aW9uSW5RdWV1ZV8xOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mID0gdGFyZ2V0LmNvbnRlbnREb2N1bWVudCwgZG9jdW1lbnRFbGVtZW50ID0gX2YuZG9jdW1lbnRFbGVtZW50LCBoZWFkID0gX2YuaGVhZDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRTdHlsZVJ1bGVzKGRvY3VtZW50RWxlbWVudCwgaGVhZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnByZXZpb3VzSWQgfHwgbXV0YXRpb24ubmV4dElkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sZWdhY3lfcmVzb2x2ZU1pc3NpbmdOb2RlKGxlZ2FjeV9taXNzaW5nTm9kZU1hcCwgcGFyZW50LCB0YXJnZXQsIG11dGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZC5hZGRzLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZE5vZGUobXV0YXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwYXNzZWQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5taXNzc2VkUXVldWVOb2RlVHJlZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmVlID0gdGhpcy5taXNzc2VkUXVldWVOb2RlVHJlZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50XzQgPSB0aGlzLm1pcnJvci5nZXROb2RlKHRyZWUudmFsdWUucGFyZW50SWQpO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50XzQpIHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGVSZXNvbHZlVHJlZSh0cmVlLCBmdW5jdGlvbiAobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBlbmROb2RlKG11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcGFzc2VkLnB1c2goaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhZGRzIHBhcmVudCBpbiBtaXNzZWQgcXVldWU6ICcsIHRyZWUudmFsdWUucGFyZW50SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwYXNzZWQubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlzc3NlZFF1ZXVlTm9kZVRyZWVzLnNwbGljZShwYXNzZWRbaW5kZXhdLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVRyZWVzID0gcXVldWVUb1Jlc29sdmVUcmVlcyhxdWV1ZSk7XHJcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID4gNTAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oJ1RpbWVvdXQgaW4gdGhlIGxvb3AsIHBsZWFzZSBjaGVjayB0aGUgcmVzb2x2ZSB0cmVlIGRhdGE6JywgcmVzb2x2ZVRyZWVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZXNvbHZlVHJlZXNfMSA9IChlXzEzID0gdm9pZCAwLCBfX3ZhbHVlcyhyZXNvbHZlVHJlZXMpKSwgcmVzb2x2ZVRyZWVzXzFfMSA9IHJlc29sdmVUcmVlc18xLm5leHQoKTsgIXJlc29sdmVUcmVlc18xXzEuZG9uZTsgcmVzb2x2ZVRyZWVzXzFfMSA9IHJlc29sdmVUcmVlc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmVlID0gcmVzb2x2ZVRyZWVzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzUgPSB0aGlzLm1pcnJvci5nZXROb2RlKHRyZWUudmFsdWUucGFyZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50XzUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXNzc2VkUXVldWVOb2RlVHJlZXMucHVzaCh0cmVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnRHJvcCByZXNvbHZlIHRyZWUgc2luY2UgdGhlcmUgaXMgbm8gcGFyZW50IGZvciB0aGUgcm9vdCBub2RlLicsIHRyZWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZVJlc29sdmVUcmVlKHRyZWUsIGZ1bmN0aW9uIChtdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kTm9kZShtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xM18xKSB7IGVfMTMgPSB7IGVycm9yOiBlXzEzXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVUcmVlc18xXzEgJiYgIXJlc29sdmVUcmVlc18xXzEuZG9uZSAmJiAoX2EgPSByZXNvbHZlVHJlZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHJlc29sdmVUcmVlc18xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMykgdGhyb3cgZV8xMy5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsZWdhY3lfbWlzc2luZ05vZGVNYXApLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMubGVnYWN5X21pc3NpbmdOb2RlUmV0cnlNYXAsIGxlZ2FjeV9taXNzaW5nTm9kZU1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGQudGV4dHMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF90aGlzLm1pcnJvci5nZXROb2RlKG11dGF0aW9uLmlkKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnJlbW92ZXMuZmluZChmdW5jdGlvbiAocikgeyByZXR1cm4gci5pZCA9PT0gbXV0YXRpb24uaWQ7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLndhcm5Ob2RlTm90Rm91bmQoZCwgbXV0YXRpb24uaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5mcmFnbWVudFBhcmVudE1hcC5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gX3RoaXMuZnJhZ21lbnRQYXJlbnRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0LnRleHRDb250ZW50ID0gbXV0YXRpb24udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZC5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5taXJyb3IuZ2V0Tm9kZShtdXRhdGlvbi5pZCk7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5yZW1vdmVzLmZpbmQoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuaWQgPT09IG11dGF0aW9uLmlkOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy53YXJuTm9kZU5vdEZvdW5kKGQsIG11dGF0aW9uLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuZnJhZ21lbnRQYXJlbnRNYXAuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IF90aGlzLmZyYWdtZW50UGFyZW50TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gbXV0YXRpb24uYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG11dGF0aW9uLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5zaG93V2FybmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgbWF5IGR1ZSB0byB0aGUgY2hlY2tvdXQgZmVhdHVyZS4nLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVWYWx1ZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIHN0eWxlVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZXNbc10gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuc3R5bGUucmVtb3ZlUHJvcGVydHkocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHlsZVZhbHVlc1tzXSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN2cCA9IHN0eWxlVmFsdWVzW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLnN0eWxlLnNldFByb3BlcnR5KHMsIHN2cFswXSwgc3ZwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdnMgPSBzdHlsZVZhbHVlc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5zdHlsZS5zZXRQcm9wZXJ0eShzLCBzdnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKGQsIGlzU3luYykge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLm1pcnJvci5nZXROb2RlKGQuaWQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYnVnTm9kZU5vdEZvdW5kKGQsIGQuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5pZnJhbWUuY29udGVudFdpbmRvdy5zY3JvbGxUbyh7XHJcbiAgICAgICAgICAgICAgICB0b3A6IGQueSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGQueCxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBpc1N5bmMgPyAnYXV0bycgOiAnc21vb3RoJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhcmdldC5fX3NuLnR5cGUgPT09IE5vZGVUeXBlLkRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5kZWZhdWx0Vmlldy5zY3JvbGxUbyh7XHJcbiAgICAgICAgICAgICAgICB0b3A6IGQueSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGQueCxcclxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBpc1N5bmMgPyAnYXV0bycgOiAnc21vb3RoJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IGQueTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zY3JvbGxMZWZ0ID0gZC54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5hcHBseUlucHV0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5taXJyb3IuZ2V0Tm9kZShkLmlkKTtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z05vZGVOb3RGb3VuZChkLCBkLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGFyZ2V0LmNoZWNrZWQgPSBkLmlzQ2hlY2tlZDtcclxuICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZC50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmxlZ2FjeV9yZXNvbHZlTWlzc2luZ05vZGUgPSBmdW5jdGlvbiAobWFwLCBwYXJlbnQsIHRhcmdldCwgdGFyZ2V0TXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNJZCA9IHRhcmdldE11dGF0aW9uLnByZXZpb3VzSWQsIG5leHRJZCA9IHRhcmdldE11dGF0aW9uLm5leHRJZDtcclxuICAgICAgICB2YXIgcHJldmlvdXNJbk1hcCA9IHByZXZpb3VzSWQgJiYgbWFwW3ByZXZpb3VzSWRdO1xyXG4gICAgICAgIHZhciBuZXh0SW5NYXAgPSBuZXh0SWQgJiYgbWFwW25leHRJZF07XHJcbiAgICAgICAgaWYgKHByZXZpb3VzSW5NYXApIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gcHJldmlvdXNJbk1hcCwgbm9kZSA9IF9hLm5vZGUsIG11dGF0aW9uID0gX2EubXV0YXRpb247XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgZGVsZXRlIG1hcFttdXRhdGlvbi5ub2RlLmlkXTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGVnYWN5X21pc3NpbmdOb2RlUmV0cnlNYXBbbXV0YXRpb24ubm9kZS5pZF07XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5wcmV2aW91c0lkIHx8IG11dGF0aW9uLm5leHRJZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWdhY3lfcmVzb2x2ZU1pc3NpbmdOb2RlKG1hcCwgcGFyZW50LCBub2RlLCBtdXRhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHRJbk1hcCkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBuZXh0SW5NYXAsIG5vZGUgPSBfYi5ub2RlLCBtdXRhdGlvbiA9IF9iLm11dGF0aW9uO1xyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5uZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBtYXBbbXV0YXRpb24ubm9kZS5pZF07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxlZ2FjeV9taXNzaW5nTm9kZVJldHJ5TWFwW211dGF0aW9uLm5vZGUuaWRdO1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ucHJldmlvdXNJZCB8fCBtdXRhdGlvbi5uZXh0SWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVnYWN5X3Jlc29sdmVNaXNzaW5nTm9kZShtYXAsIHBhcmVudCwgbm9kZSwgbXV0YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5tb3ZlQW5kSG92ZXIgPSBmdW5jdGlvbiAoeCwgeSwgaWQsIGlzU3luYywgZGVidWdEYXRhKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMubWlycm9yLmdldE5vZGUoaWQpO1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYnVnTm9kZU5vdEZvdW5kKGRlYnVnRGF0YSwgaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZSA9IGdldEJhc2VEaW1lbnNpb24odGFyZ2V0LCB0aGlzLmlmcmFtZSk7XHJcbiAgICAgICAgdmFyIF94ID0geCAqIGJhc2UuYWJzb2x1dGVTY2FsZSArIGJhc2UueDtcclxuICAgICAgICB2YXIgX3kgPSB5ICogYmFzZS5hYnNvbHV0ZVNjYWxlICsgYmFzZS55O1xyXG4gICAgICAgIHRoaXMubW91c2Uuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KF94LCBcInB4XCIpO1xyXG4gICAgICAgIHRoaXMubW91c2Uuc3R5bGUudG9wID0gXCJcIi5jb25jYXQoX3ksIFwicHhcIik7XHJcbiAgICAgICAgaWYgKCFpc1N5bmMpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3TW91c2VUYWlsKHsgeDogX3gsIHk6IF95IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhvdmVyRWxlbWVudHModGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuZHJhd01vdXNlVGFpbCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlVGFpbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29uZmlnLm1vdXNlVGFpbCA9PT0gdHJ1ZVxyXG4gICAgICAgICAgICA/IGRlZmF1bHRNb3VzZVRhaWxDb25maWdcclxuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TW91c2VUYWlsQ29uZmlnLCB0aGlzLmNvbmZpZy5tb3VzZVRhaWwpLCBsaW5lQ2FwID0gX2EubGluZUNhcCwgbGluZVdpZHRoID0gX2EubGluZVdpZHRoLCBzdHJva2VTdHlsZSA9IF9hLnN0cm9rZVN0eWxlLCBkdXJhdGlvbiA9IF9hLmR1cmF0aW9uO1xyXG4gICAgICAgIHZhciBkcmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIV90aGlzLm1vdXNlVGFpbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdHggPSBfdGhpcy5tb3VzZVRhaWwuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgaWYgKCFjdHggfHwgIV90aGlzLnRhaWxQb3NpdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBfdGhpcy5tb3VzZVRhaWwud2lkdGgsIF90aGlzLm1vdXNlVGFpbC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oX3RoaXMudGFpbFBvc2l0aW9uc1swXS54LCBfdGhpcy50YWlsUG9zaXRpb25zWzBdLnkpO1xyXG4gICAgICAgICAgICBfdGhpcy50YWlsUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIGN0eC5saW5lVG8ocC54LCBwLnkpOyB9KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50YWlsUG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xyXG4gICAgICAgIGRyYXcoKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudGFpbFBvc2l0aW9ucyA9IF90aGlzLnRhaWxQb3NpdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwICE9PSBwb3NpdGlvbjsgfSk7XHJcbiAgICAgICAgICAgIGRyYXcoKTtcclxuICAgICAgICB9LCBkdXJhdGlvbiAvIHRoaXMuc3BlZWRTZXJ2aWNlLnN0YXRlLmNvbnRleHQudGltZXIuc3BlZWQpO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5ob3ZlckVsZW1lbnRzID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoJy5cXFxcOmhvdmVyJykuZm9yRWFjaChmdW5jdGlvbiAoaG92ZXJlZEVsKSB7XHJcbiAgICAgICAgICAgIGhvdmVyZWRFbC5jbGFzc0xpc3QucmVtb3ZlKCc6aG92ZXInKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgY3VycmVudEVsID0gZWw7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsLmNsYXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5hZGQoJzpob3ZlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuaXNVc2VySW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gZXhwb3J0cy5FdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZXZlbnQuZGF0YS5zb3VyY2UgPiBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLk11dGF0aW9uICYmXHJcbiAgICAgICAgICAgIGV2ZW50LmRhdGEuc291cmNlIDw9IGV4cG9ydHMuSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQpO1xyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5iYWNrVG9Ob3JtYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0VXNlckludGVyYWN0aW9uRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnNwZWVkU2VydmljZS5zdGF0ZS5tYXRjaGVzKCdub3JtYWwnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3BlZWRTZXJ2aWNlLnNlbmQoeyB0eXBlOiAnQkFDS19UT19OT1JNQUwnIH0pO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV4cG9ydHMuUmVwbGF5ZXJFdmVudHMuU2tpcEVuZCwge1xyXG4gICAgICAgICAgICBzcGVlZDogdGhpcy5zcGVlZFNlcnZpY2Uuc3RhdGUuY29udGV4dC5ub3JtYWxTcGVlZCxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUucmVzdG9yZVJlYWxQYXJlbnQgPSBmdW5jdGlvbiAoZnJhZywgcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5taXJyb3IubWFwW3BhcmVudC5fX3NuLmlkXSA9IHBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50Ll9fc24udHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICBwYXJlbnQuX19zbi50YWdOYW1lID09PSAndGV4dGFyZWEnICYmXHJcbiAgICAgICAgICAgIGZyYWcudGV4dENvbnRlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID0gZnJhZy50ZXh0Q29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGZyYWcpO1xyXG4gICAgICAgIHRoaXMucmVzdG9yZVN0YXRlKHBhcmVudCk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLnN0b3JlU3RhdGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgdmFyIGVfMTUsIF9hO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gcGFyZW50LkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IHBhcmVudEVsZW1lbnQuc2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVNYXAuc2V0KHBhcmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IFtwYXJlbnRFbGVtZW50LnNjcm9sbExlZnQsIHBhcmVudEVsZW1lbnQuc2Nyb2xsVG9wXSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdTVFlMRScpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVDU1NSdWxlcyhwYXJlbnRFbGVtZW50LCB0aGlzLnZpcnR1YWxTdHlsZVJ1bGVzTWFwKTtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoQXJyYXkuZnJvbShjaGlsZHJlbikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlU3RhdGUoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzE1XzEpIHsgZV8xNSA9IHsgZXJyb3I6IGVfMTVfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xNSkgdGhyb3cgZV8xNS5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XHJcbiAgICAgICAgdmFyIGVfMTYsIF9hO1xyXG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IHBhcmVudC5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRTdGF0ZU1hcC5oYXMocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlZFN0YXRlID0gdGhpcy5lbGVtZW50U3RhdGVNYXAuZ2V0KHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkU3RhdGUuc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5zY3JvbGxMZWZ0ID0gc3RvcmVkU3RhdGUuc2Nyb2xsWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuc2Nyb2xsVG9wID0gc3RvcmVkU3RhdGUuc2Nyb2xsWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVNYXAuZGVsZXRlKHBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoQXJyYXkuZnJvbShjaGlsZHJlbikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGUoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzE2XzEpIHsgZV8xNiA9IHsgZXJyb3I6IGVfMTZfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTYpIHRocm93IGVfMTYuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUucmVzdG9yZU5vZGVTaGVldCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHN0b3JlZFJ1bGVzID0gdGhpcy52aXJ0dWFsU3R5bGVSdWxlc01hcC5nZXQobm9kZSk7XHJcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgIT09ICdTVFlMRScpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0b3JlZFJ1bGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0eWxlTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgYXBwbHlWaXJ0dWFsU3R5bGVSdWxlc1RvTm9kZShzdG9yZWRSdWxlcywgc3R5bGVOb2RlKTtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUud2Fybk5vZGVOb3RGb3VuZCA9IGZ1bmN0aW9uIChkLCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRyZWVJbmRleC5pZFJlbW92ZWQoaWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FybihcIk5vZGUgd2l0aCBpZCAnXCIuY29uY2F0KGlkLCBcIicgd2FzIHByZXZpb3VzbHkgcmVtb3ZlZC4gXCIpLCBkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FybihcIk5vZGUgd2l0aCBpZCAnXCIuY29uY2F0KGlkLCBcIicgbm90IGZvdW5kLiBcIiksIGQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUud2FybkNhbnZhc011dGF0aW9uRmFpbGVkID0gZnVuY3Rpb24gKGQsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy53YXJuKFwiSGFzIGVycm9yIG9uIGNhbnZhcyB1cGRhdGVcIiwgZXJyb3IsICdjYW52YXMgbXV0YXRpb246JywgZCk7XHJcbiAgICB9O1xyXG4gICAgUmVwbGF5ZXIucHJvdG90eXBlLmRlYnVnTm9kZU5vdEZvdW5kID0gZnVuY3Rpb24gKGQsIGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJlZUluZGV4LmlkUmVtb3ZlZChpZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhSRVBMQVlfQ09OU09MRV9QUkVGSVgsIFwiTm9kZSB3aXRoIGlkICdcIi5jb25jYXQoaWQsIFwiJyB3YXMgcHJldmlvdXNseSByZW1vdmVkLiBcIiksIGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhSRVBMQVlfQ09OU09MRV9QUkVGSVgsIFwiTm9kZSB3aXRoIGlkICdcIi5jb25jYXQoaWQsIFwiJyBub3QgZm91bmQuIFwiKSwgZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlcGxheWVyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLnNob3dXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW1JFUExBWV9DT05TT0xFX1BSRUZJWF0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcclxuICAgIH07XHJcbiAgICBSZXBsYXllci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgX19zcHJlYWRBcnJheShbUkVQTEFZX0NPTlNPTEVfUFJFRklYXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXBsYXllcjtcclxufSgpKTtcblxudmFyIGFkZEN1c3RvbUV2ZW50ID0gcmVjb3JkLmFkZEN1c3RvbUV2ZW50O1xyXG52YXIgZnJlZXplUGFnZSA9IHJlY29yZC5mcmVlemVQYWdlO1xuXG4vLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG5cbi8vIGFsaWFzZXMgZm9yIHNob3J0ZXIgY29tcHJlc3NlZCBjb2RlIChtb3N0IG1pbmlmZXJzIGRvbid0IGRvIHRoaXMpXG52YXIgdTggPSBVaW50OEFycmF5LCB1MTYgPSBVaW50MTZBcnJheSwgdTMyID0gVWludDMyQXJyYXk7XG4vLyBmaXhlZCBsZW5ndGggZXh0cmEgYml0c1xudmFyIGZsZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIC8qIHVudXNlZCAqLyAwLCAwLCAvKiBpbXBvc3NpYmxlICovIDBdKTtcbi8vIGZpeGVkIGRpc3RhbmNlIGV4dHJhIGJpdHNcbi8vIHNlZSBmbGViIG5vdGVcbnZhciBmZGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSwgMTIsIDEyLCAxMywgMTMsIC8qIHVudXNlZCAqLyAwLCAwXSk7XG4vLyBjb2RlIGxlbmd0aCBpbmRleCBtYXBcbnZhciBjbGltID0gbmV3IHU4KFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSk7XG4vLyBnZXQgYmFzZSwgcmV2ZXJzZSBpbmRleCBtYXAgZnJvbSBleHRyYSBiaXRzXG52YXIgZnJlYiA9IGZ1bmN0aW9uIChlYiwgc3RhcnQpIHtcbiAgICB2YXIgYiA9IG5ldyB1MTYoMzEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzE7ICsraSkge1xuICAgICAgICBiW2ldID0gc3RhcnQgKz0gMSA8PCBlYltpIC0gMV07XG4gICAgfVxuICAgIC8vIG51bWJlcnMgaGVyZSBhcmUgYXQgbWF4IDE4IGJpdHNcbiAgICB2YXIgciA9IG5ldyB1MzIoYlszMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzA7ICsraSkge1xuICAgICAgICBmb3IgKHZhciBqID0gYltpXTsgaiA8IGJbaSArIDFdOyArK2opIHtcbiAgICAgICAgICAgIHJbal0gPSAoKGogLSBiW2ldKSA8PCA1KSB8IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtiLCByXTtcbn07XG52YXIgX2EgPSBmcmViKGZsZWIsIDIpLCBmbCA9IF9hWzBdLCByZXZmbCA9IF9hWzFdO1xuLy8gd2UgY2FuIGlnbm9yZSB0aGUgZmFjdCB0aGF0IHRoZSBvdGhlciBudW1iZXJzIGFyZSB3cm9uZzsgdGhleSBuZXZlciBoYXBwZW4gYW55d2F5XG5mbFsyOF0gPSAyNTgsIHJldmZsWzI1OF0gPSAyODtcbnZhciBfYiA9IGZyZWIoZmRlYiwgMCksIGZkID0gX2JbMF0sIHJldmZkID0gX2JbMV07XG4vLyBtYXAgb2YgdmFsdWUgdG8gcmV2ZXJzZSAoYXNzdW1pbmcgMTYgYml0cylcbnZhciByZXYgPSBuZXcgdTE2KDMyNzY4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI3Njg7ICsraSkge1xuICAgIC8vIHJldmVyc2UgdGFibGUgYWxnb3JpdGhtIGZyb20gU09cbiAgICB2YXIgeCA9ICgoaSAmIDB4QUFBQSkgPj4+IDEpIHwgKChpICYgMHg1NTU1KSA8PCAxKTtcbiAgICB4ID0gKCh4ICYgMHhDQ0NDKSA+Pj4gMikgfCAoKHggJiAweDMzMzMpIDw8IDIpO1xuICAgIHggPSAoKHggJiAweEYwRjApID4+PiA0KSB8ICgoeCAmIDB4MEYwRikgPDwgNCk7XG4gICAgcmV2W2ldID0gKCgoeCAmIDB4RkYwMCkgPj4+IDgpIHwgKCh4ICYgMHgwMEZGKSA8PCA4KSkgPj4+IDE7XG59XG4vLyBjcmVhdGUgaHVmZm1hbiB0cmVlIGZyb20gdTggXCJtYXBcIjogaW5kZXggLT4gY29kZSBsZW5ndGggZm9yIGNvZGUgaW5kZXhcbi8vIG1iIChtYXggYml0cykgbXVzdCBiZSBhdCBtb3N0IDE1XG4vLyBUT0RPOiBvcHRpbWl6ZS9zcGxpdCB1cD9cbnZhciBoTWFwID0gKGZ1bmN0aW9uIChjZCwgbWIsIHIpIHtcbiAgICB2YXIgcyA9IGNkLmxlbmd0aDtcbiAgICAvLyBpbmRleFxuICAgIHZhciBpID0gMDtcbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gIyBvZiBjb2RlcyB3aXRoIGJpdCBsZW5ndGggPSBpbmRleFxuICAgIHZhciBsID0gbmV3IHUxNihtYik7XG4gICAgLy8gbGVuZ3RoIG9mIGNkIG11c3QgYmUgMjg4ICh0b3RhbCAjIG9mIGNvZGVzKVxuICAgIGZvciAoOyBpIDwgczsgKytpKVxuICAgICAgICArK2xbY2RbaV0gLSAxXTtcbiAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbWluaW11bSBjb2RlIGZvciBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbGUgPSBuZXcgdTE2KG1iKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWI7ICsraSkge1xuICAgICAgICBsZVtpXSA9IChsZVtpIC0gMV0gKyBsW2kgLSAxXSkgPDwgMTtcbiAgICB9XG4gICAgdmFyIGNvO1xuICAgIGlmIChyKSB7XG4gICAgICAgIC8vIHUxNiBcIm1hcFwiOiBpbmRleCAtPiBudW1iZXIgb2YgYWN0dWFsIGJpdHMsIHN5bWJvbCBmb3IgY29kZVxuICAgICAgICBjbyA9IG5ldyB1MTYoMSA8PCBtYik7XG4gICAgICAgIC8vIGJpdHMgdG8gcmVtb3ZlIGZvciByZXZlcnNlclxuICAgICAgICB2YXIgcnZiID0gMTUgLSBtYjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIDAgbGVuZ3Roc1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtIGVuY29kaW5nIGJvdGggc3ltYm9sIGFuZCBiaXRzIHJlYWRcbiAgICAgICAgICAgICAgICB2YXIgc3YgPSAoaSA8PCA0KSB8IGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIGZyZWUgYml0c1xuICAgICAgICAgICAgICAgIHZhciByXzEgPSBtYiAtIGNkW2ldO1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBsZVtjZFtpXSAtIDFdKysgPDwgcl8xO1xuICAgICAgICAgICAgICAgIC8vIG0gaXMgZW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IHYgfCAoKDEgPDwgcl8xKSAtIDEpOyB2IDw9IG07ICsrdikge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeSAxNiBiaXQgdmFsdWUgc3RhcnRpbmcgd2l0aCB0aGUgY29kZSB5aWVsZHMgdGhlIHNhbWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGNvW3Jldlt2XSA+Pj4gcnZiXSA9IHN2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY28gPSBuZXcgdTE2KHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKVxuICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgZmx0W2ldID0gOTtcbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICBmbHRbaV0gPSA3O1xuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICBmZHRbaV0gPSA1O1xuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZsbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDApLCBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAwKSwgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgbSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpID4+IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSkgPj4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSA+PiAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+Pj4gKHAgJiA3KSk7XG59O1xuLy8gZ2V0IGVuZCBvZiBieXRlXG52YXIgc2hmdCA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiAoKHAgLyA4KSA+PiAwKSArIChwICYgNyAmJiAxKTsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYgaW5zdGFuY2VvZiB1MTYgPyB1MTYgOiB2IGluc3RhbmNlb2YgdTMyID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICBzdCA9IHt9O1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIHN0LmYgPSBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIGlmICghbm9TdCAmJiBwb3MgKyB0bCAqIChjbGIgKyA3KSA+IHRidHMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cylcbiAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIG14YSA9IGxidCArIGRidCArIDE4O1xuICAgICAgICB3aGlsZSAobm9TdCB8fCBwb3MgKyBteGEgPCB0YnRzKSB7XG4gICAgICAgICAgICAvLyBiaXRzIHJlYWQsIGNvZGVcbiAgICAgICAgICAgIHZhciBjID0gbG1bYml0czE2KGRhdCwgcG9zKSAmIGxtc10sIHN5bSA9IGMgPj4+IDQ7XG4gICAgICAgICAgICBwb3MgKz0gYyAmIDE1O1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgIGlmICghYylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBsZW5ndGgvbGl0ZXJhbCc7XG4gICAgICAgICAgICBpZiAoc3ltIDwgMjU2KVxuICAgICAgICAgICAgICAgIGJ1ZltidCsrXSA9IHN5bTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN5bSA9PSAyNTYpIHtcbiAgICAgICAgICAgICAgICBsbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkID0gc3ltIC0gMjU0O1xuICAgICAgICAgICAgICAgIC8vIG5vIGV4dHJhIGJpdHMgbmVlZGVkIGlmIGxlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3ltID4gMjY0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gc3ltIC0gMjU3LCBiID0gZmxlYltpXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkID0gYml0cyhkYXQsIHBvcywgKDEgPDwgYikgLSAxKSArIGZsW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGlzdFxuICAgICAgICAgICAgICAgIHZhciBkID0gZG1bYml0czE2KGRhdCwgcG9zKSAmIGRtc10sIGRzeW0gPSBkID4+PiA0O1xuICAgICAgICAgICAgICAgIGlmICghZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgZGlzdGFuY2UnO1xuICAgICAgICAgICAgICAgIHBvcyArPSBkICYgMTU7XG4gICAgICAgICAgICAgICAgdmFyIGR0ID0gZmRbZHN5bV07XG4gICAgICAgICAgICAgICAgaWYgKGRzeW0gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gZmRlYltkc3ltXTtcbiAgICAgICAgICAgICAgICAgICAgZHQgKz0gYml0czE2KGRhdCwgcG9zKSAmICgoMSA8PCBiKSAtIDEpLCBwb3MgKz0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IHRidHMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgaWYgKG5vQnVmKVxuICAgICAgICAgICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYnQgKyBhZGQ7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJ0IDwgZW5kOyBidCArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidF0gPSBidWZbYnQgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDFdID0gYnVmW2J0ICsgMSAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgMl0gPSBidWZbYnQgKyAyIC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAzXSA9IGJ1ZltidCArIDMgLSBkdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0LmwgPSBsbSwgc3QucCA9IHBvcywgc3QuYiA9IGJ0O1xuICAgICAgICBpZiAobG0pXG4gICAgICAgICAgICBmaW5hbCA9IDEsIHN0Lm0gPSBsYnQsIHN0LmQgPSBkbSwgc3QubiA9IGRidDtcbiAgICB9IHdoaWxlICghZmluYWwpO1xuICAgIHJldHVybiBidCA9PSBidWYubGVuZ3RoID8gYnVmIDogc2xjKGJ1ZiwgMCwgYnQpO1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSA+PiAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+PiA4O1xufTtcbi8vIHN0YXJ0aW5nIGF0IHAsIHdyaXRlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBiaXRzICg+OCkgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0czE2ID0gZnVuY3Rpb24gKGQsIHAsIHYpIHtcbiAgICB2IDw8PSBwICYgNztcbiAgICB2YXIgbyA9IChwIC8gOCkgPj4gMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIFtuZXcgdTgoMCksIDBdO1xuICAgIGlmIChzID09IDEpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICAgIHZbdFswXS5zXSA9IDE7XG4gICAgICAgIHJldHVybiBbdiwgMV07XG4gICAgfVxuICAgIHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5mIC0gYi5mOyB9KTtcbiAgICAvLyBhZnRlciBpMiByZWFjaGVzIGxhc3QgaW5kLCB3aWxsIGJlIHN0b3BwZWRcbiAgICAvLyBmcmVxIG11c3QgYmUgZ3JlYXRlciB0aGFuIGxhcmdlc3QgcG9zc2libGUgbnVtYmVyIG9mIHN5bWJvbHNcbiAgICB0LnB1c2goeyBzOiAtMSwgZjogMjUwMDEgfSk7XG4gICAgdmFyIGwgPSB0WzBdLCByID0gdFsxXSwgaTAgPSAwLCBpMSA9IDEsIGkyID0gMjtcbiAgICB0WzBdID0geyBzOiAtMSwgZjogbC5mICsgci5mLCBsOiBsLCByOiByIH07XG4gICAgLy8gZWZmaWNpZW50IGFsZ29yaXRobSBmcm9tIFVaSVAuanNcbiAgICAvLyBpMCBpcyBsb29rYmVoaW5kLCBpMiBpcyBsb29rYWhlYWQgLSBhZnRlciBwcm9jZXNzaW5nIHR3byBsb3ctZnJlcVxuICAgIC8vIHN5bWJvbHMgdGhhdCBjb21iaW5lZCBoYXZlIGhpZ2ggZnJlcSwgd2lsbCBzdGFydCBwcm9jZXNzaW5nIGkyIChoaWdoLWZyZXEsXG4gICAgLy8gbm9uLWNvbXBvc2l0ZSkgc3ltYm9scyBpbnN0ZWFkXG4gICAgLy8gc2VlIGh0dHBzOi8vcmVkZGl0LmNvbS9yL3Bob3RvcGVhL2NvbW1lbnRzL2lrZWtodC91emlwanNfcXVlc3Rpb25zL1xuICAgIHdoaWxlIChpMSAhPSBzIC0gMSkge1xuICAgICAgICBsID0gdFt0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgciA9IHRbaTAgIT0gaTEgJiYgdFtpMF0uZiA8IHRbaTJdLmYgPyBpMCsrIDogaTIrK107XG4gICAgICAgIHRbaTErK10gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICB9XG4gICAgdmFyIG1heFN5bSA9IHQyWzBdLnM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgaWYgKHQyW2ldLnMgPiBtYXhTeW0pXG4gICAgICAgICAgICBtYXhTeW0gPSB0MltpXS5zO1xuICAgIH1cbiAgICAvLyBjb2RlIGxlbmd0aHNcbiAgICB2YXIgdHIgPSBuZXcgdTE2KG1heFN5bSArIDEpO1xuICAgIC8vIG1heCBiaXRzIGluIHRyZWVcbiAgICB2YXIgbWJ0ID0gbG4odFtpMSAtIDFdLCB0ciwgMCk7XG4gICAgaWYgKG1idCA+IG1iKSB7XG4gICAgICAgIC8vIG1vcmUgYWxnb3JpdGhtcyBmcm9tIFVaSVAuanNcbiAgICAgICAgLy8gVE9ETzogZmluZCBvdXQgaG93IHRoaXMgY29kZSB3b3JrcyAoZGVidClcbiAgICAgICAgLy8gIGluZCAgICBkZWJ0XG4gICAgICAgIHZhciBpID0gMCwgZHQgPSAwO1xuICAgICAgICAvLyAgICBsZWZ0ICAgICAgICAgICAgY29zdFxuICAgICAgICB2YXIgbGZ0ID0gbWJ0IC0gbWIsIGNzdCA9IDEgPDwgbGZ0O1xuICAgICAgICB0Mi5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiB0cltiLnNdIC0gdHJbYS5zXSB8fCBhLmYgLSBiLmY7IH0pO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGkyXzEgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzFdID4gbWIpIHtcbiAgICAgICAgICAgICAgICBkdCArPSBjc3QgLSAoMSA8PCAobWJ0IC0gdHJbaTJfMV0pKTtcbiAgICAgICAgICAgICAgICB0cltpMl8xXSA9IG1iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGR0ID4+Pj0gbGZ0O1xuICAgICAgICB3aGlsZSAoZHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgaTJfMiA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMl0gPCBtYilcbiAgICAgICAgICAgICAgICBkdCAtPSAxIDw8IChtYiAtIHRyW2kyXzJdKysgLSAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiBkdDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgaTJfMyA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfM10gPT0gbWIpIHtcbiAgICAgICAgICAgICAgICAtLXRyW2kyXzNdO1xuICAgICAgICAgICAgICAgICsrZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWJ0ID0gbWI7XG4gICAgfVxuICAgIHJldHVybiBbbmV3IHU4KHRyKSwgbWJ0XTtcbn07XG4vLyBnZXQgdGhlIG1heCBsZW5ndGggYW5kIGFzc2lnbiBsZW5ndGggY29kZXNcbnZhciBsbiA9IGZ1bmN0aW9uIChuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMVxuICAgICAgICA/IE1hdGgubWF4KGxuKG4ubCwgbCwgZCArIDEpLCBsbihuLnIsIGwsIGQgKyAxKSlcbiAgICAgICAgOiAobFtuLnNdID0gZCk7XG59O1xuLy8gbGVuZ3RoIGNvZGVzIGdlbmVyYXRpb25cbnZhciBsYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHMgPSBjLmxlbmd0aDtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbWljb2xvbiB3YXMgaW50ZW50aW9uYWxcbiAgICB3aGlsZSAocyAmJiAhY1stLXNdKVxuICAgICAgICA7XG4gICAgdmFyIGNsID0gbmV3IHUxNigrK3MpO1xuICAgIC8vICBpbmQgICAgICBudW0gICAgICAgICBzdHJlYWtcbiAgICB2YXIgY2xpID0gMCwgY2xuID0gY1swXSwgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGNsW2NsaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gczsgKytpKSB7XG4gICAgICAgIGlmIChjW2ldID09IGNsbiAmJiBpICE9IHMpXG4gICAgICAgICAgICArK2NscztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNsbiAmJiBjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDEzODsgY2xzIC09IDEzOClcbiAgICAgICAgICAgICAgICAgICAgdygzMjc1NCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyhjbHMgPiAxMCA/ICgoY2xzIC0gMTEpIDw8IDUpIHwgMjg2OTAgOiAoKGNscyAtIDMpIDw8IDUpIHwgMTIzMDUpO1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNilcbiAgICAgICAgICAgICAgICAgICAgdyg4MzA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMilcbiAgICAgICAgICAgICAgICAgICAgdygoKGNscyAtIDMpIDw8IDUpIHwgODIwOCksIGNscyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2xzLS0pXG4gICAgICAgICAgICAgICAgdyhjbG4pO1xuICAgICAgICAgICAgY2xzID0gMTtcbiAgICAgICAgICAgIGNsbiA9IGNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtjbC5zdWJhcnJheSgwLCBjbGkpLCBzXTtcbn07XG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBvdXRwdXQgZnJvbSB0cmVlLCBjb2RlIGxlbmd0aHNcbnZhciBjbGVuID0gZnVuY3Rpb24gKGNmLCBjbCkge1xuICAgIHZhciBsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsLmxlbmd0aDsgKytpKVxuICAgICAgICBsICs9IGNmW2ldICogY2xbaV07XG4gICAgcmV0dXJuIGw7XG59O1xuLy8gd3JpdGVzIGEgZml4ZWQgYmxvY2tcbi8vIHJldHVybnMgdGhlIG5ldyBiaXQgcG9zXG52YXIgd2ZibGsgPSBmdW5jdGlvbiAob3V0LCBwb3MsIGRhdCkge1xuICAgIC8vIG5vIG5lZWQgdG8gd3JpdGUgMDAgYXMgdHlwZTogVHlwZWRBcnJheSBkZWZhdWx0cyB0byAwXG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gc2hmdChwb3MgKyAyKTtcbiAgICBvdXRbb10gPSBzICYgMjU1O1xuICAgIG91dFtvICsgMV0gPSBzID4+PiA4O1xuICAgIG91dFtvICsgMl0gPSBvdXRbb10gXiAyNTU7XG4gICAgb3V0W28gKyAzXSA9IG91dFtvICsgMV0gXiAyNTU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyArK2kpXG4gICAgICAgIG91dFtvICsgaSArIDRdID0gZGF0W2ldO1xuICAgIHJldHVybiAobyArIDQgKyBzKSAqIDg7XG59O1xuLy8gd3JpdGVzIGEgYmxvY2tcbnZhciB3YmxrID0gZnVuY3Rpb24gKGRhdCwgb3V0LCBmaW5hbCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBibCwgcCkge1xuICAgIHdiaXRzKG91dCwgcCsrLCBmaW5hbCk7XG4gICAgKytsZlsyNTZdO1xuICAgIHZhciBfYSA9IGhUcmVlKGxmLCAxNSksIGRsdCA9IF9hWzBdLCBtbGIgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSBoVHJlZShkZiwgMTUpLCBkZHQgPSBfYlswXSwgbWRiID0gX2JbMV07XG4gICAgdmFyIF9jID0gbGMoZGx0KSwgbGNsdCA9IF9jWzBdLCBubGMgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSBsYyhkZHQpLCBsY2R0ID0gX2RbMF0sIG5kYyA9IF9kWzFdO1xuICAgIHZhciBsY2ZyZXEgPSBuZXcgdTE2KDE5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjbHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2x0W2ldICYgMzFdKys7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsY2R0Lmxlbmd0aDsgKytpKVxuICAgICAgICBsY2ZyZXFbbGNkdFtpXSAmIDMxXSsrO1xuICAgIHZhciBfZSA9IGhUcmVlKGxjZnJlcSwgNyksIGxjdCA9IF9lWzBdLCBtbGNiID0gX2VbMV07XG4gICAgdmFyIG5sY2MgPSAxOTtcbiAgICBmb3IgKDsgbmxjYyA+IDQgJiYgIWxjdFtjbGltW25sY2MgLSAxXV07IC0tbmxjYylcbiAgICAgICAgO1xuICAgIHZhciBmbGVuID0gKGJsICsgNSkgPDwgMztcbiAgICB2YXIgZnRsZW4gPSBjbGVuKGxmLCBmbHQpICsgY2xlbihkZiwgZmR0KSArIGViO1xuICAgIHZhciBkdGxlbiA9IGNsZW4obGYsIGRsdCkgKyBjbGVuKGRmLCBkZHQpICsgZWIgKyAxNCArIDMgKiBubGNjICsgY2xlbihsY2ZyZXEsIGxjdCkgKyAoMiAqIGxjZnJlcVsxNl0gKyAzICogbGNmcmVxWzE3XSArIDcgKiBsY2ZyZXFbMThdKTtcbiAgICBpZiAoZmxlbiA8PSBmdGxlbiAmJiBmbGVuIDw9IGR0bGVuKVxuICAgICAgICByZXR1cm4gd2ZibGsob3V0LCBwLCBkYXQuc3ViYXJyYXkoYnMsIGJzICsgYmwpKTtcbiAgICB2YXIgbG0sIGxsLCBkbSwgZGw7XG4gICAgd2JpdHMob3V0LCBwLCAxICsgKGR0bGVuIDwgZnRsZW4pKSwgcCArPSAyO1xuICAgIGlmIChkdGxlbiA8IGZ0bGVuKSB7XG4gICAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgICAgdmFyIGxsbSA9IGhNYXAobGN0LCBtbGNiLCAwKTtcbiAgICAgICAgd2JpdHMob3V0LCBwLCBubGMgLSAyNTcpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgMTAsIG5sY2MgLSA0KTtcbiAgICAgICAgcCArPSAxNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBubGNjOyArK2kpXG4gICAgICAgICAgICB3Yml0cyhvdXQsIHAgKyAzICogaSwgbGN0W2NsaW1baV1dKTtcbiAgICAgICAgcCArPSAzICogbmxjYztcbiAgICAgICAgdmFyIGxjdHMgPSBbbGNsdCwgbGNkdF07XG4gICAgICAgIGZvciAodmFyIGl0ID0gMDsgaXQgPCAyOyArK2l0KSB7XG4gICAgICAgICAgICB2YXIgY2xjdCA9IGxjdHNbaXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsY3RbaV0gJiAzMTtcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMTUpXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKGNsY3RbaV0gPj4+IDUpICYgMTI3KSwgcCArPSBjbGN0W2ldID4+PiAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG0gPSBmbG0sIGxsID0gZmx0LCBkbSA9IGZkbSwgZGwgPSBmZHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGk7ICsraSkge1xuICAgICAgICBpZiAoc3ltc1tpXSA+IDI1NSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IChzeW1zW2ldID4+PiAxOCkgJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtsZW4gKyAyNTddKSwgcCArPSBsbFtsZW4gKyAyNTddO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDcpXG4gICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoc3ltc1tpXSA+Pj4gMjMpICYgMzEpLCBwICs9IGZsZWJbbGVuXTtcbiAgICAgICAgICAgIHZhciBkc3QgPSBzeW1zW2ldICYgMzE7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgZG1bZHN0XSksIHAgKz0gZGxbZHN0XTtcbiAgICAgICAgICAgIGlmIChkc3QgPiAzKVxuICAgICAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCAoc3ltc1tpXSA+Pj4gNSkgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltc1tpXV0pLCBwICs9IGxsW3N5bXNbaV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdiaXRzMTYob3V0LCBwLCBsbVsyNTZdKTtcbiAgICByZXR1cm4gcCArIGxsWzI1Nl07XG59O1xuLy8gZGVmbGF0ZSBvcHRpb25zIChuaWNlIDw8IDEzKSB8IGNoYWluXG52YXIgZGVvID0gLyojX19QVVJFX18qLyBuZXcgdTMyKFs2NTU0MCwgMTMxMDgwLCAxMzEwODgsIDEzMTEwNCwgMjYyMTc2LCAxMDQ4NzA0LCAxMDQ4ODMyLCAyMTE0NTYwLCAyMTE3NjMyXSk7XG4vLyBlbXB0eVxudmFyIGV0ID0gLyojX19QVVJFX18qLyBuZXcgdTgoMCk7XG4vLyBjb21wcmVzc2VzIGRhdGEgaW50byBhIHJhdyBERUZMQVRFIGJ1ZmZlclxudmFyIGRmbHQgPSBmdW5jdGlvbiAoZGF0LCBsdmwsIHBsdmwsIHByZSwgcG9zdCwgbHN0KSB7XG4gICAgdmFyIHMgPSBkYXQubGVuZ3RoO1xuICAgIHZhciBvID0gbmV3IHU4KHByZSArIHMgKyA1ICogKDEgKyBNYXRoLmZsb29yKHMgLyA3MDAwKSkgKyBwb3N0KTtcbiAgICAvLyB3cml0aW5nIHRvIHRoaXMgd3JpdGVzIHRvIHRoZSBvdXRwdXQgYnVmZmVyXG4gICAgdmFyIHcgPSBvLnN1YmFycmF5KHByZSwgby5sZW5ndGggLSBwb3N0KTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICBpZiAoIWx2bCB8fCBzIDwgOCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzOyBpICs9IDY1NTM1KSB7XG4gICAgICAgICAgICAvLyBlbmRcbiAgICAgICAgICAgIHZhciBlID0gaSArIDY1NTM1O1xuICAgICAgICAgICAgaWYgKGUgPCBzKSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgZnVsbCBibG9ja1xuICAgICAgICAgICAgICAgIHBvcyA9IHdmYmxrKHcsIHBvcywgZGF0LnN1YmFycmF5KGksIGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZpbmFsIGJsb2NrXG4gICAgICAgICAgICAgICAgd1tpXSA9IGxzdDtcbiAgICAgICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGRhdC5zdWJhcnJheShpLCBzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBvcHQgPSBkZW9bbHZsIC0gMV07XG4gICAgICAgIHZhciBuID0gb3B0ID4+PiAxMywgYyA9IG9wdCAmIDgxOTE7XG4gICAgICAgIHZhciBtc2tfMSA9ICgxIDw8IHBsdmwpIC0gMTtcbiAgICAgICAgLy8gICAgcHJldiAyLWJ5dGUgdmFsIG1hcCAgICBjdXJyIDItYnl0ZSB2YWwgbWFwXG4gICAgICAgIHZhciBwcmV2ID0gbmV3IHUxNigzMjc2OCksIGhlYWQgPSBuZXcgdTE2KG1za18xICsgMSk7XG4gICAgICAgIHZhciBiczFfMSA9IE1hdGguY2VpbChwbHZsIC8gMyksIGJzMl8xID0gMiAqIGJzMV8xO1xuICAgICAgICB2YXIgaHNoID0gZnVuY3Rpb24gKGkpIHsgcmV0dXJuIChkYXRbaV0gXiAoZGF0W2kgKyAxXSA8PCBiczFfMSkgXiAoZGF0W2kgKyAyXSA8PCBiczJfMSkpICYgbXNrXzE7IH07XG4gICAgICAgIC8vIDI0NTc2IGlzIGFuIGFyYml0cmFyeSBudW1iZXIgb2YgbWF4aW11bSBzeW1ib2xzIHBlciBibG9ja1xuICAgICAgICAvLyA0MjQgYnVmZmVyIGZvciBsYXN0IGJsb2NrXG4gICAgICAgIHZhciBzeW1zID0gbmV3IHUzMigyNTAwMCk7XG4gICAgICAgIC8vIGxlbmd0aC9saXRlcmFsIGZyZXEgICBkaXN0YW5jZSBmcmVxXG4gICAgICAgIHZhciBsZiA9IG5ldyB1MTYoMjg4KSwgZGYgPSBuZXcgdTE2KDMyKTtcbiAgICAgICAgLy8gIGwvbGNudCAgZXhiaXRzICBpbmRleCAgbC9saW5kICB3YWl0ZHggIGJpdHBvc1xuICAgICAgICB2YXIgbGNfMSA9IDAsIGViID0gMCwgaSA9IDAsIGxpID0gMCwgd2kgPSAwLCBicyA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICAvLyBoYXNoIHZhbHVlXG4gICAgICAgICAgICB2YXIgaHYgPSBoc2goaSk7XG4gICAgICAgICAgICAvLyBpbmRleCBtb2QgMzI3NjhcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3O1xuICAgICAgICAgICAgLy8gcHJldmlvdXMgaW5kZXggd2l0aCB0aGlzIHZhbHVlXG4gICAgICAgICAgICB2YXIgcGltb2QgPSBoZWFkW2h2XTtcbiAgICAgICAgICAgIHByZXZbaW1vZF0gPSBwaW1vZDtcbiAgICAgICAgICAgIGhlYWRbaHZdID0gaW1vZDtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzaG91bGQgbW9kaWZ5IGhlYWQgYW5kIHByZXYsIGJ1dCBvbmx5IGFkZCBzeW1ib2xzIGlmXG4gICAgICAgICAgICAvLyB0aGlzIGRhdGEgaXMgbm90IHlldCBwcm9jZXNzZWQgKFwid2FpdFwiIGZvciB3YWl0IGluZGV4KVxuICAgICAgICAgICAgaWYgKHdpIDw9IGkpIHtcbiAgICAgICAgICAgICAgICAvLyBieXRlcyByZW1haW5pbmdcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gcyAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKChsY18xID4gNzAwMCB8fCBsaSA+IDI0NTc2KSAmJiByZW0gPiA0MjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIDAsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgaSAtIGJzLCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICBsaSA9IGxjXzEgPSBlYiA9IDAsIGJzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyODY7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGxmW2pdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzMDsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGZbal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgbGVuICAgIGRpc3QgICBjaGFpblxuICAgICAgICAgICAgICAgIHZhciBsID0gMiwgZCA9IDAsIGNoXzEgPSBjLCBkaWYgPSAoaW1vZCAtIHBpbW9kKSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgIGlmIChyZW0gPiAyICYmIGh2ID09IGhzaChpIC0gZGlmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4biA9IE1hdGgubWluKG4sIHJlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHBvc3NpYmxlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2FwcGVkIGF0IGRpZiBiZWNhdXNlIGRlY29tcHJlc3NvcnMgaW1wbGVtZW50IFwicm9sbGluZ1wiIGluZGV4IHBvcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlmIDw9IG1heGQgJiYgLS1jaF8xICYmIGltb2QgIT0gcGltb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRbaSArIGxdID09IGRhdFtpICsgbCAtIGRpZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBubCA8IG1sICYmIGRhdFtpICsgbmxdID09IGRhdFtpICsgbmwgLSBkaWZdOyArK25sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbmwsIGQgPSBkaWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIG91dCBlYXJseSB3aGVuIHdlIHJlYWNoIFwibmljZVwiICh3ZSBhcmUgc2F0aXNmaWVkIGVub3VnaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpdGVyYWxzIGFuZCBzZWFyY2ggZm9yIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1tZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGkgPSAoaSAtIGRpZiArIGogKyAzMjc2OCkgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdGkgPSBwcmV2W3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZCA9ICh0aSAtIHB0aSArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNkID4gbWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWQgPSBjZCwgcGltb2QgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBwcmV2aW91cyBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1vZCA9IHBpbW9kLCBwaW1vZCA9IHByZXZbaW1vZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWYgKz0gKGltb2QgLSBwaW1vZCArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGQgd2lsbCBiZSBub256ZXJvIG9ubHkgd2hlbiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIFVpbnQzMlxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyByZWNvZ25pemVkIGFzIGEgbGVuL2Rpc3Qgd2l0aCAyOHRoIGJpdCAoMl4yOClcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IDI2ODQzNTQ1NiB8IChyZXZmbFtsXSA8PCAxOCkgfCByZXZmZFtkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbiA9IHJldmZsW2xdICYgMzEsIGRpbiA9IHJldmZkW2RdICYgMzE7XG4gICAgICAgICAgICAgICAgICAgIGViICs9IGZsZWJbbGluXSArIGZkZWJbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZlsyNTcgKyBsaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2RmW2Rpbl07XG4gICAgICAgICAgICAgICAgICAgIHdpID0gaSArIGw7XG4gICAgICAgICAgICAgICAgICAgICsrbGNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICAgICAgICAgICsrbGZbZGF0W2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIGxzdCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGF2b2lkIG5lZWRpbmcgdG8gbWFpbnRhaW4gc3RhdGVcbiAgICAgICAgaWYgKCFsc3QpXG4gICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhvLCAwLCBwcmUgKyBzaGZ0KHBvcykgKyBwb3N0KTtcbn07XG4vLyBBbGRlcjMyXG52YXIgYWRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSAxLCBiID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIG4gPSBhLCBtID0gYjtcbiAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPSBsOykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oaSArIDU1NTIsIGwpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBuICs9IGRbaV0sIG0gKz0gbjtcbiAgICAgICAgICAgICAgICBuICU9IDY1NTIxLCBtICU9IDY1NTIxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IG4sIGIgPSBtO1xuICAgICAgICB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKGEgPj4+IDgpIDw8IDE2IHwgKGIgJiAyNTUpIDw8IDggfCAoYiA+Pj4gOCkpICsgKChhICYgMjU1KSA8PCAyMykgKiAyOyB9XG4gICAgfTtcbn07XG4vLyBkZWZsYXRlIHdpdGggb3B0c1xudmFyIGRvcHQgPSBmdW5jdGlvbiAoZGF0LCBvcHQsIHByZSwgcG9zdCwgc3QpIHtcbiAgICByZXR1cm4gZGZsdChkYXQsIG9wdC5sZXZlbCA9PSBudWxsID8gNiA6IG9wdC5sZXZlbCwgb3B0Lm1lbSA9PSBudWxsID8gTWF0aC5jZWlsKE1hdGgubWF4KDgsIE1hdGgubWluKDEzLCBNYXRoLmxvZyhkYXQubGVuZ3RoKSkpICogMS41KSA6ICgxMiArIG9wdC5tZW0pLCBwcmUsIHBvc3QsICFzdCk7XG59O1xuLy8gd3JpdGUgYnl0ZXNcbnZhciB3Ynl0ZXMgPSBmdW5jdGlvbiAoZCwgYiwgdikge1xuICAgIGZvciAoOyB2OyArK2IpXG4gICAgICAgIGRbYl0gPSB2LCB2ID4+Pj0gODtcbn07XG4vLyB6bGliIGhlYWRlclxudmFyIHpsaCA9IGZ1bmN0aW9uIChjLCBvKSB7XG4gICAgdmFyIGx2ID0gby5sZXZlbCwgZmwgPSBsdiA9PSAwID8gMCA6IGx2IDwgNiA/IDEgOiBsdiA9PSA5ID8gMyA6IDI7XG4gICAgY1swXSA9IDEyMCwgY1sxXSA9IChmbCA8PCA2KSB8IChmbCA/ICgzMiAtIDIgKiBmbCkgOiAxKTtcbn07XG4vLyB6bGliIHZhbGlkXG52YXIgemx2ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoKGRbMF0gJiAxNSkgIT0gOCB8fCAoZFswXSA+Pj4gNCkgPiA3IHx8ICgoZFswXSA8PCA4IHwgZFsxXSkgJSAzMSkpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YSc7XG4gICAgaWYgKGRbMV0gJiAzMilcbiAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBkYXRhOiBwcmVzZXQgZGljdGlvbmFyaWVzIG5vdCBzdXBwb3J0ZWQnO1xufTtcbi8qKlxuICogQ29tcHJlc3MgZGF0YSB3aXRoIFpsaWJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIHpsaWItY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHpsaWJTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbi8qKlxuICogRXhwYW5kcyBabGliIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiB1bnpsaWJTeW5jKGRhdGEsIG91dCkge1xuICAgIHJldHVybiBpbmZsdCgoemx2KGRhdGEpLCBkYXRhLnN1YmFycmF5KDIsIC00KSksIG91dCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5mdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuICAgIGlmICghbGF0aW4xICYmIHR5cGVvZiBUZXh0RW5jb2RlciAhPSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgIHZhciBhciA9IG5ldyB1OChzdHIubGVuZ3RoICsgKHN0ci5sZW5ndGggPj4+IDEpKTtcbiAgICB2YXIgYWkgPSAwO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgYXJbYWkrK10gPSB2OyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGlmIChhaSArIDUgPiBhci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KGFpICsgOCArICgobCAtIGkpIDw8IDEpKTtcbiAgICAgICAgICAgIG4uc2V0KGFyKTtcbiAgICAgICAgICAgIGFyID0gbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCB8fCBsYXRpbjEpXG4gICAgICAgICAgICB3KGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcbiAgICAgICAgICAgIHcoMTkyIHwgKGMgPj4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+PiAxOCkpLCB3KDEyOCB8ICgoYyA+Pj4gMTIpICYgNjMpKSwgdygxMjggfCAoKGMgPj4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4+IDEyKSksIHcoMTI4IHwgKChjID4+PiA2KSAmIDYzKSksIHcoMTI4IHwgKGMgJiA2MykpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKGFyLCAwLCBhaSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIHN0cmluZ1xuICogQHBhcmFtIGRhdCBUaGUgZGF0YSB0byBkZWNvZGUgdG8gc3RyaW5nXG4gKiBAcGFyYW0gbGF0aW4xIFdoZXRoZXIgb3Igbm90IHRvIGludGVycHJldCB0aGUgZGF0YSBhcyBMYXRpbi0xLiBUaGlzIHNob3VsZFxuICogICAgICAgICAgICAgICBub3QgbmVlZCB0byBiZSB0cnVlIHVubGVzcyBlbmNvZGluZyB0byBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIFVURi04L0xhdGluLTEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHN0ckZyb21VOChkYXQsIGxhdGluMSkge1xuICAgIHZhciByID0gJyc7XG4gICAgaWYgKCFsYXRpbjEgJiYgdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXQubGVuZ3RoOykge1xuICAgICAgICB2YXIgYyA9IGRhdFtpKytdO1xuICAgICAgICBpZiAoYyA8IDEyOCB8fCBsYXRpbjEpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMjQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IChkYXRbaSsrXSAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyNDApXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoZGF0W2krK10gJiA2MykgPDwgNiB8IChkYXRbaSsrXSAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZGF0W2krK10gJiA2MykgPDwgMTIgfCAoZGF0W2krK10gJiA2MykgPDwgNiB8IChkYXRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuXG52YXIgTUFSSyA9ICd2MSc7XG5cbnZhciBwYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB2YXIgX2UgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnQpLCB7IHY6IE1BUksgfSk7XHJcbiAgICByZXR1cm4gc3RyRnJvbVU4KHpsaWJTeW5jKHN0clRvVTgoSlNPTi5zdHJpbmdpZnkoX2UpKSksIHRydWUpO1xyXG59O1xuXG52YXIgdW5wYWNrID0gZnVuY3Rpb24gKHJhdykge1xyXG4gICAgaWYgKHR5cGVvZiByYXcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdztcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGUgPSBKU09OLnBhcnNlKHJhdyk7XHJcbiAgICAgICAgaWYgKGUudGltZXN0YW1wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgZSA9IEpTT04ucGFyc2Uoc3RyRnJvbVU4KHVuemxpYlN5bmMoc3RyVG9VOChyYXcsIHRydWUpKSkpO1xyXG4gICAgICAgIGlmIChlLnYgPT09IE1BUkspIHtcclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXNlIGV2ZW50cyB3ZXJlIHBhY2tlZCB3aXRoIHBhY2tlciBcIi5jb25jYXQoZS52LCBcIiB3aGljaCBpcyBpbmNvbXBhdGlibGUgd2l0aCBjdXJyZW50IHBhY2tlciBcIikuY29uY2F0KE1BUkssIFwiLlwiKSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YSBmb3JtYXQuJyk7XHJcbiAgICB9XHJcbn07XG5cbnZhciBTdGFja0ZyYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XHJcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IG9iai5maWxlTmFtZSB8fCAnJztcclxuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IG9iai5mdW5jdGlvbk5hbWUgfHwgJyc7XHJcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gb2JqLmxpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5OdW1iZXIgPSBvYmouY29sdW1uTnVtYmVyO1xyXG4gICAgfVxyXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmxpbmVOdW1iZXIgfHwgJyc7XHJcbiAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuY29sdW1uTnVtYmVyIHx8ICcnO1xyXG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZnVuY3Rpb25OYW1lICtcclxuICAgICAgICAgICAgICAgICcgKCcgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZSArXHJcbiAgICAgICAgICAgICAgICAnOicgK1xyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlciArXHJcbiAgICAgICAgICAgICAgICAnOicgK1xyXG4gICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyICtcclxuICAgICAgICAgICAgICAgICcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcclxufSgpKTtcclxudmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUys6XFxkKy87XHJcbnZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcclxudmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXSk/JC87XHJcbnZhciBFcnJvclN0YWNrUGFyc2VyID0ge1xyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiAodXJsTGlrZSkge1xyXG4gICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt1cmxMaWtlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlZ0V4cCA9IC8oLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xyXG4gICAgICAgIGlmICghcGFydHMpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBnaXZlbiB1cmw6IFwiLmNvbmNhdCh1cmxMaWtlKSk7XHJcbiAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xyXG4gICAgfSxcclxuICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHNhbml0aXplZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7XHJcbiAgICAgICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgPyBzYW5pdGl6ZWRMaW5lLnJlcGxhY2UobG9jYXRpb25bMF0sICcnKVxyXG4gICAgICAgICAgICAgICAgOiBzYW5pdGl6ZWRMaW5lO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gc2FuaXRpemVkTGluZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKGxvY2F0aW9uID8gbG9jYXRpb25bMV0gOiB0b2tlbnMucG9wKCkpO1xyXG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IFsnZXZhbCcsICc8YW5vbnltb3VzPiddLmluZGV4T2YobG9jYXRpb25QYXJ0c1swXSkgPiAtMVxyXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIDogbG9jYXRpb25QYXJ0c1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbDpcXGQrOlxcZCsvZywgJzokMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lLm1hdGNoKGZ1bmN0aW9uTmFtZVJlZ2V4KTtcclxuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxvY2F0aW9uUGFydHNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8XHJcbiAgICAgICAgICAgIChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJlxyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHBhcnNlRmxvYXQobWF0Y2hbMV0pLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBtYXRjaFszXSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHBhcnNlRmxvYXQobWF0Y2hbMV0pLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiZcclxuICAgICAgICAgICAgICAgICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcclxuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9IHRva2Vucy5zaGlmdCgpIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXHJcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcbn07XG5cbmZ1bmN0aW9uIHBhdGhUb1NlbGVjdG9yKG5vZGUpIHtcclxuICAgIGlmICghbm9kZSB8fCAhbm9kZS5vdXRlckhUTUwpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgcGF0aCA9ICcnO1xyXG4gICAgd2hpbGUgKG5vZGUucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgIHZhciBuYW1lXzEgPSBub2RlLmxvY2FsTmFtZTtcclxuICAgICAgICBpZiAoIW5hbWVfMSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbmFtZV8xID0gbmFtZV8xLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIHBhcmVudF8xID0gbm9kZS5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBkb21TaWJsaW5ncyA9IFtdO1xyXG4gICAgICAgIGlmIChwYXJlbnRfMS5jaGlsZHJlbiAmJiBwYXJlbnRfMS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50XzEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gcGFyZW50XzEuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2libGluZy5sb2NhbE5hbWUgJiYgc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZy5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZV8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVNpYmxpbmdzLnB1c2goc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb21TaWJsaW5ncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIG5hbWVfMSArPSAnOmVxKCcgKyBkb21TaWJsaW5ncy5pbmRleE9mKG5vZGUpICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoID0gbmFtZV8xICsgKHBhdGggPyAnPicgKyBwYXRoIDogJycpO1xyXG4gICAgICAgIG5vZGUgPSBwYXJlbnRfMTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcclxufVxyXG5mdW5jdGlvbiBpc09ialRvb0RlZXAob2JqLCBsaW1pdCkge1xyXG4gICAgdmFyIGVfMSwgX2E7XHJcbiAgICBpZiAobGltaXQgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5c18xID0gX192YWx1ZXMoa2V5cyksIGtleXNfMV8xID0ga2V5c18xLm5leHQoKTsgIWtleXNfMV8xLmRvbmU7IGtleXNfMV8xID0ga2V5c18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvYmpba2V5XSkgJiYgaXNPYmpUb29EZWVwKG9ialtrZXldLCBsaW1pdCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoa2V5c18xXzEgJiYgIWtleXNfMV8xLmRvbmUgJiYgKF9hID0ga2V5c18xLnJldHVybikpIF9hLmNhbGwoa2V5c18xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIHN0cmluZ2lmeU9wdGlvbnMpIHtcclxuICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgIG51bU9mS2V5c0xpbWl0OiA1MCxcclxuICAgICAgICBkZXB0aE9mTGltaXQ6IDQsXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzdHJpbmdpZnlPcHRpb25zKTtcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIGtleXMgPSBbXTtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdbQ2lyY3VsYXIgfl0nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnW0NpcmN1bGFyIH4uJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ10nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFdmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXZlbnRSZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnRLZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFZhbHVlID0gdmFsdWVbZXZlbnRLZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudFJlc3VsdFtldmVudEtleV0gPSBwYXRoVG9TZWxlY3RvcihldmVudFZhbHVlLmxlbmd0aCA/IGV2ZW50VmFsdWVbMF0gOiBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzdWx0W2V2ZW50S2V5XSA9IGV2ZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLm91dGVySFRNTCA6ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ub2RlTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RhY2tcclxuICAgICAgICAgICAgICAgID8gdmFsdWUuc3RhY2sgKyAnXFxuRW5kIG9mIHN0YWNrIGZvciBFcnJvciBvYmplY3QnXHJcbiAgICAgICAgICAgICAgICA6IHZhbHVlLm5hbWUgKyAnOiAnICsgdmFsdWUubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBzaG91bGRJZ25vcmUoX29iaikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChfb2JqKSAmJiBPYmplY3Qua2V5cyhfb2JqKS5sZW5ndGggPiBvcHRpb25zLm51bU9mS2V5c0xpbWl0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIF9vYmogPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc09iamVjdChfb2JqKSAmJiBpc09ialRvb0RlZXAoX29iaiwgb3B0aW9ucy5kZXB0aE9mTGltaXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhfb2JqKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IF9vYmoudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zdHJpbmdMZW5ndGhMaW1pdCAmJiBzdHIubGVuZ3RoID4gb3B0aW9ucy5zdHJpbmdMZW5ndGhMaW1pdCkge1xyXG4gICAgICAgICAgICBzdHIgPSBcIlwiLmNvbmNhdChzdHIuc2xpY2UoMCwgb3B0aW9ucy5zdHJpbmdMZW5ndGhMaW1pdCksIFwiLi4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG59XG5cbnZhciBkZWZhdWx0TG9nT3B0aW9ucyA9IHtcclxuICAgIGxldmVsOiBbXHJcbiAgICAgICAgJ2Fzc2VydCcsXHJcbiAgICAgICAgJ2NsZWFyJyxcclxuICAgICAgICAnY291bnQnLFxyXG4gICAgICAgICdjb3VudFJlc2V0JyxcclxuICAgICAgICAnZGVidWcnLFxyXG4gICAgICAgICdkaXInLFxyXG4gICAgICAgICdkaXJ4bWwnLFxyXG4gICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgJ2dyb3VwJyxcclxuICAgICAgICAnZ3JvdXBDb2xsYXBzZWQnLFxyXG4gICAgICAgICdncm91cEVuZCcsXHJcbiAgICAgICAgJ2luZm8nLFxyXG4gICAgICAgICdsb2cnLFxyXG4gICAgICAgICd0YWJsZScsXHJcbiAgICAgICAgJ3RpbWUnLFxyXG4gICAgICAgICd0aW1lRW5kJyxcclxuICAgICAgICAndGltZUxvZycsXHJcbiAgICAgICAgJ3RyYWNlJyxcclxuICAgICAgICAnd2FybicsXHJcbiAgICBdLFxyXG4gICAgbGVuZ3RoVGhyZXNob2xkOiAxMDAwLFxyXG4gICAgbG9nZ2VyOiAnY29uc29sZScsXHJcbn07XHJcbmZ1bmN0aW9uIGluaXRMb2dPYnNlcnZlcihjYiwgd2luLCBsb2dPcHRpb25zKSB7XHJcbiAgICB2YXIgZV8xLCBfYTtcclxuICAgIHZhciBsb2dnZXJUeXBlID0gbG9nT3B0aW9ucy5sb2dnZXI7XHJcbiAgICBpZiAoIWxvZ2dlclR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGxvZ2dlcjtcclxuICAgIGlmICh0eXBlb2YgbG9nZ2VyVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBsb2dnZXIgPSB3aW5bbG9nZ2VyVHlwZV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2dnZXIgPSBsb2dnZXJUeXBlO1xyXG4gICAgfVxyXG4gICAgdmFyIGxvZ0NvdW50ID0gMDtcclxuICAgIHZhciBjYW5jZWxIYW5kbGVycyA9IFtdO1xyXG4gICAgaWYgKGxvZ09wdGlvbnMubGV2ZWwuaW5jbHVkZXMoJ2Vycm9yJykpIHtcclxuICAgICAgICBpZiAod2luZG93KSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckhhbmRsZXJfMSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBldmVudC5tZXNzYWdlLCBlcnJvciA9IGV2ZW50LmVycm9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvcikubWFwKGZ1bmN0aW9uIChzdGFja0ZyYW1lKSB7IHJldHVybiBzdGFja0ZyYW1lLnRvU3RyaW5nKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBbc3RyaW5naWZ5KG1lc3NhZ2UsIGxvZ09wdGlvbnMuc3RyaW5naWZ5T3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgY2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlOiB0cmFjZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcl8xKTtcclxuICAgICAgICAgICAgY2FuY2VsSGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93KVxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcl8xKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGxvZ09wdGlvbnMubGV2ZWwpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBsZXZlbFR5cGUgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgY2FuY2VsSGFuZGxlcnMucHVzaChyZXBsYWNlKGxvZ2dlciwgbGV2ZWxUeXBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYW5jZWxIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHJlcGxhY2UoX2xvZ2dlciwgbGV2ZWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghX2xvZ2dlcltsZXZlbF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGNoKF9sb2dnZXIsIGxldmVsLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KF90aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gRXJyb3JTdGFja1BhcnNlci5wYXJzZShuZXcgRXJyb3IoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhY2tGcmFtZSkgeyByZXR1cm4gc3RhY2tGcmFtZS50b1N0cmluZygpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYXJncy5tYXAoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShzLCBsb2dPcHRpb25zLnN0cmluZ2lmeU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0NvdW50IDwgbG9nT3B0aW9ucy5sZW5ndGhUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2U6IHRyYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvZ0NvdW50ID09PSBsb2dPcHRpb25zLmxlbmd0aFRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2U6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgnVGhlIG51bWJlciBvZiBsb2cgcmVjb3JkcyByZWFjaGVkIHRoZSB0aHJlc2hvbGQuJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoWydycndlYiBsb2dnZXIgZXJyb3I6JywgZXJyb3JdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxudmFyIFBMVUdJTl9OQU1FID0gJ3Jyd2ViL2NvbnNvbGVAMSc7XHJcbnZhciBnZXRSZWNvcmRDb25zb2xlUGx1Z2luID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuICh7XHJcbiAgICBuYW1lOiBQTFVHSU5fTkFNRSxcclxuICAgIG9ic2VydmVyOiBpbml0TG9nT2JzZXJ2ZXIsXHJcbiAgICBvcHRpb25zOiBvcHRpb25zXHJcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TG9nT3B0aW9ucywgb3B0aW9ucylcclxuICAgICAgICA6IGRlZmF1bHRMb2dPcHRpb25zLFxyXG59KTsgfTtcblxudmFyIE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gJ19fcnJ3ZWJfb3JpZ2luYWxfXyc7XHJcbnZhciBkZWZhdWx0TG9nQ29uZmlnID0ge1xyXG4gICAgbGV2ZWw6IFtcclxuICAgICAgICAnYXNzZXJ0JyxcclxuICAgICAgICAnY2xlYXInLFxyXG4gICAgICAgICdjb3VudCcsXHJcbiAgICAgICAgJ2NvdW50UmVzZXQnLFxyXG4gICAgICAgICdkZWJ1ZycsXHJcbiAgICAgICAgJ2RpcicsXHJcbiAgICAgICAgJ2RpcnhtbCcsXHJcbiAgICAgICAgJ2Vycm9yJyxcclxuICAgICAgICAnZ3JvdXAnLFxyXG4gICAgICAgICdncm91cENvbGxhcHNlZCcsXHJcbiAgICAgICAgJ2dyb3VwRW5kJyxcclxuICAgICAgICAnaW5mbycsXHJcbiAgICAgICAgJ2xvZycsXHJcbiAgICAgICAgJ3RhYmxlJyxcclxuICAgICAgICAndGltZScsXHJcbiAgICAgICAgJ3RpbWVFbmQnLFxyXG4gICAgICAgICd0aW1lTG9nJyxcclxuICAgICAgICAndHJhY2UnLFxyXG4gICAgICAgICd3YXJuJyxcclxuICAgIF0sXHJcbiAgICByZXBsYXlMb2dnZXI6IHVuZGVmaW5lZCxcclxufTtcclxudmFyIExvZ1JlcGxheVBsdWdpbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMb2dSZXBsYXlQbHVnaW4oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRMb2dDb25maWcsIGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBMb2dSZXBsYXlQbHVnaW4ucHJvdG90eXBlLmdldENvbnNvbGVMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVwbGF5TG9nZ2VyID0ge307XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID09PSAndHJhY2UnKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYXlMb2dnZXJbbGV2ZWxdID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nZ2VyID0gY29uc29sZS5sb2dbT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5sb2dbT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS5sb2c7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZGF0YS5wYXlsb2FkLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gSlNPTi5wYXJzZShzKTsgfSkpLCBmYWxzZSksIFtfdGhpcy5mb3JtYXRNZXNzYWdlKGRhdGEpXSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYXlMb2dnZXJbbGV2ZWxdID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nZ2VyID0gY29uc29sZVtsZXZlbF1bT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZVtsZXZlbF1bT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZVtsZXZlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZGF0YS5wYXlsb2FkLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gSlNPTi5wYXJzZShzKTsgfSkpLCBmYWxzZSksIFtfdGhpcy5mb3JtYXRNZXNzYWdlKGRhdGEpXSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jb25maWcubGV2ZWwpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIF9sb29wXzEobGV2ZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVwbGF5TG9nZ2VyO1xyXG4gICAgfTtcclxuICAgIExvZ1JlcGxheVBsdWdpbi5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEudHJhY2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YWNrUHJlZml4ID0gJ1xcblxcdGF0ICc7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0YWNrUHJlZml4O1xyXG4gICAgICAgIHJlc3VsdCArPSBkYXRhLnRyYWNlLmpvaW4oc3RhY2tQcmVmaXgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExvZ1JlcGxheVBsdWdpbjtcclxufSgpKTtcclxudmFyIGdldFJlcGxheUNvbnNvbGVQbHVnaW4gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHJlcGxheUxvZ2dlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVwbGF5TG9nZ2VyKSB8fCBuZXcgTG9nUmVwbGF5UGx1Z2luKG9wdGlvbnMpLmdldENvbnNvbGVMb2dnZXIoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50LCBfaXNTeW5jLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2dEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IGV4cG9ydHMuRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuc291cmNlID09PSBleHBvcnRzLkluY3JlbWVudGFsU291cmNlLkxvZykge1xyXG4gICAgICAgICAgICAgICAgbG9nRGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gZXhwb3J0cy5FdmVudFR5cGUuUGx1Z2luICYmXHJcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLnBsdWdpbiA9PT0gUExVR0lOX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RhdGEgPSBldmVudC5kYXRhLnBheWxvYWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxvZ0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYXlMb2dnZXJbbG9nRGF0YS5sZXZlbF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGF5TG9nZ2VyW2xvZ0RhdGEubGV2ZWxdKGxvZ0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJlcGxheWVyLmNvbmZpZy5zaG93V2FybmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59O1xuXG5leHBvcnRzLlBMVUdJTl9OQU1FID0gUExVR0lOX05BTUU7XG5leHBvcnRzLlJlcGxheWVyID0gUmVwbGF5ZXI7XG5leHBvcnRzLmFkZEN1c3RvbUV2ZW50ID0gYWRkQ3VzdG9tRXZlbnQ7XG5leHBvcnRzLmZyZWV6ZVBhZ2UgPSBmcmVlemVQYWdlO1xuZXhwb3J0cy5nZXRSZWNvcmRDb25zb2xlUGx1Z2luID0gZ2V0UmVjb3JkQ29uc29sZVBsdWdpbjtcbmV4cG9ydHMuZ2V0UmVwbGF5Q29uc29sZVBsdWdpbiA9IGdldFJlcGxheUNvbnNvbGVQbHVnaW47XG5leHBvcnRzLnBhY2sgPSBwYWNrO1xuZXhwb3J0cy5yZWNvcmQgPSByZWNvcmQ7XG5leHBvcnRzLnVucGFjayA9IHVucGFjaztcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///126\n") }, 231: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ main)\n});\n\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, "prototype", {\n    writable: false\n  });\n  return Constructor;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, "prototype", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n  }, _typeof(obj);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError("Derived constructors may only return object or undefined");\n  }\n\n  return _assertThisInitialized(self);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n;// CONCATENATED MODULE: ./src/WhiteBoard/typing.ts\nvar ToolMode;\n\n(function (ToolMode) {\n  ToolMode["PEN"] = "pen";\n  ToolMode["LINE"] = "line";\n  ToolMode["RECTANGLE"] = "rectangle";\n  ToolMode["CRICLE"] = "circle";\n  ToolMode["TEXT"] = "text";\n  ToolMode["REMOVE"] = "remove";\n})(ToolMode || (ToolMode = {}));\n;// CONCATENATED MODULE: ./src/WhiteBoard/Component.ts\n\n\n\nvar Component = /*#__PURE__*/function () {\n  function Component() {\n    _classCallCheck(this, Component);\n  }\n\n  _createClass(Component, null, [{\n    key: "toolItemView",\n    value: function toolItemView(tool) {\n      var mode = tool.mode,\n          isActive = tool.isActive,\n          id = tool.id;\n      return "\\n            <li class=\\"tools-wrapper-item\\" data-id=\\"".concat(id, "\\">\\n                <i class=\\"tool-icon tool-").concat(mode, "\\" data-id=\\"").concat(id, "\\"></i>\\n            </li> \\n        ");\n    }\n  }, {\n    key: "toolListView",\n    value: function toolListView(data, sync) {\n      if (data.length <= 0 && !sync) return \'\';\n      return "\\n            <div class=\\"tools-list-wrapper\\" id=\\"tools-list-wrapper\\">\\n                <ul class=\\"tools-wrapper\\">\\n                    ".concat(data.map(function (tool) {\n        return Component.toolItemView(tool);\n      }), "\\n                </ul>\\n            </div>\\n        ").split(\',\').join(\'\');\n    }\n  }, {\n    key: "canvasWrapperView",\n    value: function canvasWrapperView(elementId, width, height) {\n      return "\\n            <canvas id=\\"".concat(elementId, "\\" width=\\"").concat(width, "\\" height=\\"").concat(height, "\\"></canvas>\\n        ");\n    }\n  }]);\n\n  return Component;\n}();\n\n/* harmony default export */ const WhiteBoard_Component = (Component);\n;// CONCATENATED MODULE: ./src/WhiteBoard/MarkTool.ts\n\n\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\nvar MarkTool = /*#__PURE__*/function (_Component) {\n  _inherits(MarkTool, _Component);\n\n  var _super = _createSuper(MarkTool);\n\n  function MarkTool(options) {\n    var _this;\n\n    _classCallCheck(this, MarkTool);\n\n    var wrapperEl = options.wrapperEl,\n        tools = options.tools,\n        setDrawMode = options.setDrawMode,\n        _options$sync = options.sync,\n        sync = _options$sync === void 0 ? false : _options$sync;\n    _this = _super.call(this);\n    _this.wrapperEl = wrapperEl;\n    MarkTool.tools = tools;\n    MarkTool.sync = sync;\n    _this.setDrawMode = setDrawMode;\n    return _this;\n  }\n\n  _createClass(MarkTool, [{\n    key: "render",\n    value: function render() {\n      this.wrapperEl.innerHTML += WhiteBoard_Component.toolListView(MarkTool.tools, MarkTool.sync);\n    }\n  }, {\n    key: "bindEvent",\n    value: function bindEvent() {\n      var toolContainer = document.querySelector(\'.tools-wrapper \');\n      toolContainer.addEventListener(\'click\', this.handleClick.bind(this), false);\n      var tools = document.getElementsByClassName(\'tools-wrapper-item \');\n      var ele = tools[0];\n\n      if (ele) {\n        ele.style.backgroundColor = \'#d3e9e1\';\n      }\n    }\n  }, {\n    key: "handleClick",\n    value: function handleClick(evt) {\n      var _this2 = this;\n\n      var target = evt.target;\n      var tools = document.getElementsByClassName(\'tools-wrapper-item \');\n\n      if (target.dataset.id) {\n        var _id = parseInt(target.dataset.id);\n\n        MarkTool.tools = MarkTool.tools.map(function (tool, index) {\n          var ele = tools[index];\n\n          if (tool.id === _id) {\n            tool.isActive = true;\n\n            _this2.setDrawMode(tool.mode);\n\n            ele.style.backgroundColor = \'#d3e9e1\';\n          } else {\n            tool.isActive = false;\n            ele.style.backgroundColor = \'\';\n          }\n\n          return tool;\n        });\n      }\n    }\n  }]);\n\n  return MarkTool;\n}(WhiteBoard_Component);\n\n_defineProperty(MarkTool, "sync", false);\n\n/* harmony default export */ const WhiteBoard_MarkTool = (MarkTool);\n;// CONCATENATED MODULE: ./src/WhiteBoard/userAgent.ts\n/**  UA  */\nvar UA = {\n  inMobile: false,\n  inAndroid: false,\n  iniPad: false,\n  inMac: false,\n  iniPhone: false,\n  inIOS: false,\n  inSamsung: false,\n  inWeichat: false,\n  inSafari: false,\n  inChrome: false,\n  inQQBrowser: false,\n  inUCBrowser: false,\n  inIE: false,\n  inOpera: false,\n  inWebKit: false,\n  inFireFox: false\n};\nvar userAgent = navigator.userAgent;\nUA.inMobile = !!userAgent.match(/applewebkit.*mobile.*/i); // \n\nUA.inAndroid = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) ? true : false; // android\n\nUA.iniPad = userAgent.match(/(iPad).*OS\\s([\\d_]+)/) ? true : false; // iPad\n\nUA.inMac = userAgent.match(/(Mac\\sOS)\\sX\\s([\\d_]+)/) ? true : false; // iMac\n\nUA.iniPhone = !UA.iniPad && userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) ? true : false; // iPhone\n\nUA.inIOS = UA.iniPad || UA.inMac || UA.iniPhone; // ios\n\nUA.inSamsung = userAgent.toUpperCase().indexOf(\'SAMSUNG-SM-N7508V\') != -1;\nUA.inWeichat = userAgent.match(/MicroMessenger/i) != null; // \n\nUA.inSafari = userAgent.indexOf(\'Safari\') != -1; // Safari\n\nUA.inChrome = userAgent.match(/Chrome/i) != null && userAgent.match(/Version\\/\\d+\\.\\d+(\\.\\d+)?\\sChrome\\//i) == null ? true : false;\nUA.inQQBrowser = userAgent.match(/MQQBrowser\\/([\\d\\.]+)/) ? true : false; // QQ\n\nUA.inUCBrowser = userAgent.match(/UCBrowser\\/([\\d\\.]+)/) ? true : false;\nUA.inIE = userAgent.match(/Trident/i) != null; // IE\n\nUA.inOpera = userAgent.match(/Presto/i) != null; // opera\n\nUA.inWebKit = userAgent.match(/Applewebkit/i) != null; // \n\nUA.inFireFox = userAgent.match(/Gecko/i) != null && userAgent.match(/khtml/i) != null; // \n\n/* harmony default export */ const WhiteBoard_userAgent = (UA);\n;// CONCATENATED MODULE: ./src/WhiteBoard/CanvasDraw.ts\n\n\n\n\n\n\n\n\nfunction CanvasDraw_createSuper(Derived) { var hasNativeReflectConstruct = CanvasDraw_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction CanvasDraw_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar fabric = (__webpack_require__(870).fabric);\n\n\n\n\nvar CanvasDraw = /*#__PURE__*/function (_Component) {\n  _inherits(CanvasDraw, _Component);\n\n  var _super = CanvasDraw_createSuper(CanvasDraw);\n\n  // \n  function CanvasDraw(props) {\n    var _this;\n\n    _classCallCheck(this, CanvasDraw);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), "canvasContext", null);\n\n    _defineProperty(_assertThisInitialized(_this), "zoom", 1);\n\n    _defineProperty(_assertThisInitialized(_this), "mouseFromTrack", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "mouseToTrack", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "mouseToPrev", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "isDrawing", false);\n\n    _defineProperty(_assertThisInitialized(_this), "moveCount", 1);\n\n    _defineProperty(_assertThisInitialized(_this), "drawingObject", null);\n\n    _defineProperty(_assertThisInitialized(_this), "keepDrawing", false);\n\n    _defineProperty(_assertThisInitialized(_this), "textbox", null);\n\n    _defineProperty(_assertThisInitialized(_this), "drawType", \'pen\');\n\n    _defineProperty(_assertThisInitialized(_this), "drawWidth", 1);\n\n    _defineProperty(_assertThisInitialized(_this), "color", \'#E34F51\');\n\n    _defineProperty(_assertThisInitialized(_this), "chacheCanvas", \'\');\n\n    _defineProperty(_assertThisInitialized(_this), "colorset", false);\n\n    _defineProperty(_assertThisInitialized(_this), "textSize", \'18px\');\n\n    if (!fabric) {\n      throw new Error(\'fabricjs is undefined, palease: npm install fabric\');\n    }\n\n    var wrapperEl = props.wrapperEl,\n        width = props.width,\n        height = props.height,\n        sync = props.sync,\n        getDrawMode = props.getDrawMode,\n        onScreenSyncMessage = props.onScreenSyncMessage;\n    _this.wrapperEl = wrapperEl;\n    _this.width = width;\n    _this.height = height;\n    CanvasDraw.sync = sync;\n    _this.getDrawMode = getDrawMode;\n    _this.onScreenSyncMessage = onScreenSyncMessage;\n    return _this;\n  }\n\n  _createClass(CanvasDraw, [{\n    key: "render",\n    value: function render() {\n      this.wrapperEl.innerHTML += WhiteBoard_Component.canvasWrapperView(\'white-board-canvas\', this.width, this.height);\n    }\n  }, {\n    key: "initCanvas",\n    value: function initCanvas() {\n      var canvas = document.getElementById(\'white-board-canvas\');\n      CanvasDraw.fabric = new fabric.Canvas(\'white-board-canvas\', {\n        containerClass: \'white-board-canvas-contaier\'\n      });\n      this.canvasContext = canvas.getContext(\'2d\');\n      this.canvasContext.globalAlpha = 1;\n      this.canvasContext.fillStyle = \'rgba(255, 255, 255, 0)\';\n      CanvasDraw.fabric.freeDrawingBrush.color = this.color;\n      CanvasDraw.fabric.isDrawingMode = true;\n      this.mouseDown();\n      this.mouseMove();\n      this.mouseUp();\n      this.selectionEvent();\n    }\n  }, {\n    key: "transformMouse",\n    value: function transformMouse(x, y) {\n      return {\n        x: x / this.zoom,\n        y: y / this.zoom\n      };\n    }\n  }, {\n    key: "fxremoveAll",\n    value: function fxremoveAll() {\n      var _this2 = this;\n\n      CanvasDraw.fabric.getObjects().map(function (obj) {\n        return _this2.fxremove(obj);\n      });\n    }\n  }, {\n    key: "fxremove",\n    value: function fxremove(object) {\n      var canvas = CanvasDraw.fabric;\n      fabric.util.animate({\n        startValue: object.opacity,\n        endValue: 0,\n        duration: 1000,\n        onChange: function onChange(value) {\n          object.set(\'opacity\', value);\n          canvas.requestRenderAll();\n        },\n        onComplete: function onComplete() {\n          canvas.remove(object);\n        }\n      });\n    }\n  }, {\n    key: "drawing",\n    value: function drawing() {\n      if (this.drawingObject) {\n        CanvasDraw.fabric.remove(this.drawingObject);\n      }\n\n      var canvasObject = null;\n      var left = 0;\n      var top = 0;\n      var radius = 0;\n      var path = \'\';\n\n      switch (this.drawType) {\n        case \'line\':\n          //\n          CanvasDraw.fabric.isDrawingMode = false;\n          canvasObject = new fabric.Line([this.mouseFromTrack.x, this.mouseFromTrack.y, this.mouseToTrack.x, this.mouseToTrack.y], {\n            stroke: this.color,\n            strokeWidth: this.drawWidth\n          });\n          break;\n\n        case \'circle\':\n          //\n          {\n            left = this.mouseFromTrack.x, top = this.mouseFromTrack.y;\n            radius = Math.sqrt((this.mouseToTrack.x - left) * (this.mouseToTrack.x - left) + (this.mouseToTrack.y - top) * (this.mouseToTrack.y - top)) / 2;\n            canvasObject = new fabric.Circle({\n              left: left,\n              top: top,\n              stroke: this.color,\n              fill: \'rgba(255, 255, 255, 0)\',\n              radius: radius,\n              strokeWidth: this.drawWidth\n            });\n          }\n          break;\n\n        case \'rectangle\':\n          //\n          {\n            left = this.mouseFromTrack.x, top = this.mouseFromTrack.y;\n            path = \'M \' + this.mouseFromTrack.x + \' \' + this.mouseFromTrack.y + \' L \' + this.mouseToTrack.x + \' \' + this.mouseFromTrack.y + \' L \' + this.mouseToTrack.x + \' \' + this.mouseToTrack.y + \' L \' + this.mouseFromTrack.x + \' \' + this.mouseToTrack.y + \' L \' + this.mouseFromTrack.x + \' \' + this.mouseFromTrack.y + \' z\';\n            canvasObject = new fabric.Path(path, {\n              left: left,\n              top: top,\n              stroke: this.color,\n              strokeWidth: this.drawWidth,\n              fill: \'rgba(255, 255, 255, 0)\'\n            });\n          } //fabric.Rect\n\n          break;\n\n        case \'text\':\n          {\n            var textbox = new fabric.Textbox(\'\', {\n              left: this.mouseFromTrack.x,\n              top: this.mouseFromTrack.y,\n              width: 150,\n              fontSize: 18,\n              borderColor: \'#2c2c2c\',\n              fill: this.color,\n              hasControls: false\n            });\n            this.textbox = textbox;\n\n            if (this.textbox) {\n              CanvasDraw.fabric.add(this.textbox);\n              this.textbox.enterEditing();\n              this.textbox.hiddenTextarea.focus();\n            }\n          }\n          break;\n\n        case \'remove\':\n          break;\n\n        default:\n          break;\n      }\n\n      if (canvasObject) {\n        CanvasDraw.fabric.add(canvasObject);\n        this.drawingObject = canvasObject;\n      }\n    }\n  }, {\n    key: "sendMessage",\n    value: function sendMessage() {\n      // \n      if (!CanvasDraw.sync) return;\n      var code = this.chacheCanvas;\n      this.onScreenSyncMessage({\n        action: \'draw\',\n        value: code,\n        type: \'whiteboard\'\n      }, \'whiteboard\');\n    }\n  }, {\n    key: "sendMessage4FreeDraw",\n    value: function sendMessage4FreeDraw(type, x, y) {\n      // \n      if (!CanvasDraw.sync) return;\n      var code = {\n        type: type,\n        x: x,\n        y: y\n      };\n      this.onScreenSyncMessage({\n        action: \'freeDraw\',\n        value: code,\n        type: \'whiteboard\'\n      }, \'whiteboard\');\n    }\n  }, {\n    key: "onFreeDraw",\n    value: function onFreeDraw(value) {\n      if (!value || !value.type) return;\n      var event = new MouseEvent(value.type, {\n        clientX: Number(value.x),\n        clientY: Number(value.y),\n        type: value.type,\n        view: window,\n        bubbles: true,\n        cancelable: true\n      });\n      var pointer = {\n        x: value.x,\n        y: value.y\n      }; // this.whiteboardCanvas.dispatchEvent(event);\n\n      if (value.type === \'mousedown\') {\n        CanvasDraw.fabric.freeDrawingBrush.onMouseDown(pointer, {\n          e: event,\n          pointer: pointer\n        });\n      } else if (value.type === \'mouseup\') {\n        event.isPrimary = true;\n        CanvasDraw.fabric.freeDrawingBrush.onMouseUp({\n          e: event,\n          pointer: pointer\n        });\n      } else if (value.type === \'mousemove\') {\n        CanvasDraw.fabric.freeDrawingBrush.onMouseMove(pointer, {\n          e: event,\n          pointer: pointer\n        });\n      }\n    }\n  }, {\n    key: "updateCanvas",\n    value: function updateCanvas() {\n      this.chacheCanvas = JSON.stringify(CanvasDraw.fabric);\n      this.sendMessage();\n    }\n  }, {\n    key: "showCache",\n    value: function showCache(data) {\n      var _this3 = this;\n\n      var jsonData = JSON.parse(data || this.chacheCanvas);\n      CanvasDraw.fabric.loadFromJSON(jsonData, function () {\n        CanvasDraw.fabric.renderAll();\n      });\n\n      if (!this.keepDrawing) {\n        setTimeout(function () {\n          _this3.fxremoveAll();\n        }, 100);\n      }\n    }\n  }, {\n    key: "clearCanvas",\n    value: function clearCanvas() {\n      CanvasDraw.fabric.clear();\n    }\n  }, {\n    key: "setDrawMode",\n    value: function setDrawMode(mode) {\n      this.drawType = mode;\n      CanvasDraw.fabric.isDrawingMode = false;\n\n      if (this.textbox) {\n        //\n        this.textbox.exitEditing();\n        this.textbox = null;\n        this.updateCanvas();\n      }\n\n      if (this.drawType == \'pen\') {\n        this.colorset = false;\n        CanvasDraw.fabric.isDrawingMode = true;\n      } else if (this.drawType == \'remove\') {\n        this.colorset = false;\n        CanvasDraw.fabric.selection = true;\n        CanvasDraw.fabric.skipTargetFind = false;\n        CanvasDraw.fabric.selectable = true;\n      } else if (this.drawType == \'text\') {\n        this.colorset = true;\n      } else {\n        this.colorset = false;\n        CanvasDraw.fabric.skipTargetFind = true; //\n\n        CanvasDraw.fabric.selection = false; //\n      }\n    }\n  }, {\n    key: "mouseUp",\n    value: function mouseUp() {\n      var _this4 = this;\n\n      CanvasDraw.fabric.on(\'mouse:up\', function (options) {\n        console.log(options);\n        var offsetX = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.x : options.e.offsetX;\n        var offsetY = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.y : options.e.offsetY;\n\n        if (_this4.drawType !== \'text\') {\n          _this4.mouseToTrack = _this4.transformMouse(offsetX, offsetY);\n          _this4.drawingObject = null;\n          _this4.moveCount = 1;\n          _this4.isDrawing = false;\n\n          _this4.updateCanvas();\n\n          if (!_this4.keepDrawing && !_this4.textbox) {\n            setTimeout(function () {\n              _this4.fxremoveAll();\n            }, 100);\n          }\n\n          if (CanvasDraw.fabric.isDrawingMode) {\n            // send free draw message\n            _this4.sendMessage4FreeDraw(\'mouseup\', _this4.mouseToTrack.x, _this4.mouseToTrack.y);\n          }\n        }\n      });\n    }\n  }, {\n    key: "mouseMove",\n    value: function mouseMove() {\n      var _this5 = this;\n\n      CanvasDraw.fabric.on(\'mouse:move\', function (options) {\n        if (_this5.moveCount % 2 && !_this5.isDrawing) {\n          //\n          return;\n        }\n\n        _this5.moveCount++;\n        var offsetX = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.x : options.e.offsetX;\n        var offsetY = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.y : options.e.offsetY;\n        _this5.mouseToTrack = _this5.transformMouse(offsetX, offsetY);\n        console.log(_this5.mouseToTrack, offsetX, offsetY); // \n\n        _this5.mouseToPrev = _this5.transformMouse(offsetX, offsetY);\n\n        if (CanvasDraw.fabric.isDrawingMode) {\n          _this5.sendMessage4FreeDraw(\'mousemove\', _this5.mouseToTrack.x, _this5.mouseToTrack.y);\n        } else {\n          _this5.drawing();\n\n          _this5.updateCanvas();\n        }\n      });\n    }\n  }, {\n    key: "mouseDown",\n    value: function mouseDown() {\n      var _this6 = this;\n\n      CanvasDraw.fabric.on(\'mouse:down\', function (options) {\n        var offsetX = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.x : options.e.offsetX;\n        var offsetY = WhiteBoard_userAgent.inIOS || WhiteBoard_userAgent.inAndroid || WhiteBoard_userAgent.inMobile || WhiteBoard_userAgent.iniPad ? options.pointer.y : options.e.offsetY; // texttext\n\n        if (_this6.drawType === \'text\') {\n          // \n          _this6.colorset = false;\n          _this6.mouseFromTrack = _this6.transformMouse(offsetX, offsetY); // self.drawing();\n\n          if (_this6.textbox && _this6.textbox.text && _this6.textbox.text.length > 0) {\n            console.warn(\'self.textbox : \', _this6.textbox.text, _this6.textbox); //\n\n            _this6.textbox.exitEditing(); // self.textbox = null;\n\n\n            _this6.updateCanvas();\n\n            setTimeout(function () {\n              _this6.fxremoveAll();\n\n              _this6.drawing();\n            }, 100);\n          } else {\n            _this6.drawing();\n          }\n        } else {\n          _this6.mouseFromTrack = _this6.transformMouse(offsetX, offsetY);\n          _this6.isDrawing = true;\n          _this6.mouseToPrev = _this6.transformMouse(offsetX, offsetY);\n\n          if (CanvasDraw.fabric.isDrawingMode) {\n            // send free draw message\n            _this6.sendMessage4FreeDraw(\'mousedown\', _this6.mouseToPrev.x, _this6.mouseToPrev.y);\n          }\n        }\n      });\n    }\n  }, {\n    key: "selectionEvent",\n    value: function selectionEvent() {\n      var _this7 = this;\n\n      CanvasDraw.fabric.on(\'selection:created\', function (e) {\n        if (_this7.textbox) {} else {\n          if (e.selected && e.selected.length > 0) {\n            //\n            var etCount = e.selected.length;\n\n            for (var etindex = 0; etindex < etCount; etindex++) {\n              CanvasDraw.fabric.remove(e.selected[etindex]);\n            }\n          } else {\n            //\n            CanvasDraw.fabric.remove(e.selected);\n          }\n        }\n\n        CanvasDraw.fabric.discardActiveObject(); // \n      });\n    }\n  }, {\n    key: "setMessageIn",\n    value: function setMessageIn(message) {\n      // \n      if (CanvasDraw.sync) return; // \n      // typewhiteboard\n\n      if (message.type !== \'whiteboard\') return;\n\n      if (message.action === \'draw\') {\n        this.showCache(message.value);\n      } else if (message.action === \'setColor\') {\n        this.color = message.value;\n        CanvasDraw.fabric.freeDrawingBrush.color = this.color;\n      } else if (message.action === \'setTextSize\') {\n        this.textSize = message.value;\n      } else if (message.action === \'freeDraw\') {\n        this.onFreeDraw(message.value);\n      } else {\n        console.error(\'unhandled whiteboard messgae in : \', message);\n      }\n    }\n  }]);\n\n  return CanvasDraw;\n}(WhiteBoard_Component);\n\n_defineProperty(CanvasDraw, "sync", false);\n\n/* harmony default export */ const WhiteBoard_CanvasDraw = (CanvasDraw);\n;// CONCATENATED MODULE: ./src/WhiteBoard/index.ts\n\n\n\n\n\n\n\n\nfunction WhiteBoard_createSuper(Derived) { var hasNativeReflectConstruct = WhiteBoard_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction WhiteBoard_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\nvar WhiteBoard = /*#__PURE__*/function (_Component) {\n  _inherits(WhiteBoard, _Component);\n\n  var _super = WhiteBoard_createSuper(WhiteBoard);\n\n  function WhiteBoard(el, tools, width, height, isCustomer, sync, isStartedSync, onScreenSyncMessage, sendCustomMessage) {\n    var _this;\n\n    _classCallCheck(this, WhiteBoard);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), "markTool", null);\n\n    _defineProperty(_assertThisInitialized(_this), "isCustomer", false);\n\n    _this.el = el;\n    _this.tools = tools;\n    _this.width = width;\n    _this.height = height;\n    _this.isCustomer = isCustomer;\n    WhiteBoard.onScreenSyncMessage = onScreenSyncMessage;\n    WhiteBoard.isStartedSync = isStartedSync;\n    WhiteBoard.sendCustomMessage = sendCustomMessage;\n    WhiteBoard.sync = sync;\n    _this.whiteBoardWrapper = document.createElement(\'div\');\n    _this.whiteBoardWrapper.className = \'white-board-box\';\n    return _this;\n  }\n  /**  */\n\n\n  _createClass(WhiteBoard, [{\n    key: "init",\n    value: function init() {\n      this.createComponets();\n      this.render();\n      this.bindEvent();\n    }\n    /**  */\n\n  }, {\n    key: "render",\n    value: function render() {\n      var _WhiteBoard$canvasDra, _this$markTool, _WhiteBoard$canvasDra2;\n\n      (_WhiteBoard$canvasDra = WhiteBoard.canvasDraw) === null || _WhiteBoard$canvasDra === void 0 ? void 0 : _WhiteBoard$canvasDra.render();\n      (_this$markTool = this.markTool) === null || _this$markTool === void 0 ? void 0 : _this$markTool.render();\n      this.el.appendChild(this.whiteBoardWrapper);\n      (_WhiteBoard$canvasDra2 = WhiteBoard.canvasDraw) === null || _WhiteBoard$canvasDra2 === void 0 ? void 0 : _WhiteBoard$canvasDra2.initCanvas();\n    }\n    /**  */\n\n  }, {\n    key: "bindEvent",\n    value: function bindEvent() {\n      var _this$markTool2;\n\n      (_this$markTool2 = this.markTool) === null || _this$markTool2 === void 0 ? void 0 : _this$markTool2.bindEvent();\n    }\n  }, {\n    key: "setDrawMode",\n    value: function setDrawMode(mode) {\n      var _WhiteBoard$canvasDra3;\n\n      WhiteBoard.drawMode = mode;\n      (_WhiteBoard$canvasDra3 = WhiteBoard.canvasDraw) === null || _WhiteBoard$canvasDra3 === void 0 ? void 0 : _WhiteBoard$canvasDra3.setDrawMode(mode);\n    }\n  }, {\n    key: "getDrawMode",\n    value: function getDrawMode() {\n      return WhiteBoard.drawMode;\n    } // \n\n  }, {\n    key: "onMessageOutInner",\n    value: function onMessageOutInner(message, type) {\n      var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'all\';\n\n      if (this.isCustomer && !WhiteBoard.isStartedSync && message && message.action !== \'size\' && message.action !== \'endScreenSync\') {\n        console.error(\'onMessageOutInner : \', WhiteBoard.isStartedSync, message);\n        return;\n      }\n\n      if (WhiteBoard.onScreenSyncMessage) {\n        WhiteBoard.onScreenSyncMessage(message);\n      } else if (WhiteBoard.sendCustomMessage) {\n        var data = Object.assign({}, {\n          type: type\n        }, message);\n        WhiteBoard.sendCustomMessage(data, role, function (success) {\n          console.log(\'\' + data, success);\n        }, function (error) {\n          console.log(\'\' + data, error);\n        });\n      }\n    }\n    /**  */\n\n  }, {\n    key: "createComponets",\n    value: function createComponets() {\n      this.markTool = new WhiteBoard_MarkTool({\n        wrapperEl: this.whiteBoardWrapper,\n        tools: this.tools,\n        width: 24,\n        height: 24,\n        sync: WhiteBoard.sync,\n        setDrawMode: this.setDrawMode\n      });\n      WhiteBoard.canvasDraw = new WhiteBoard_CanvasDraw({\n        wrapperEl: this.whiteBoardWrapper,\n        width: this.width,\n        height: this.height,\n        sync: WhiteBoard.sync,\n        getDrawMode: this.getDrawMode,\n        onScreenSyncMessage: WhiteBoard.onScreenSyncMessage\n      });\n    }\n  }, {\n    key: "setToolHide",\n    value: function setToolHide(status) {\n      var tool = document.getElementById(\'tools-list-wrapper\');\n\n      if (tool) {\n        tool.style.display = "".concat(status ? \'none\' : \'block\');\n      }\n    }\n  }]);\n\n  return WhiteBoard;\n}(WhiteBoard_Component);\n\n_defineProperty(WhiteBoard, "canvasDraw", null);\n\n_defineProperty(WhiteBoard, "drawMode", \'\');\n\n_defineProperty(WhiteBoard, "onScreenSyncMessage", undefined);\n\n_defineProperty(WhiteBoard, "sync", false);\n\n\n/* harmony default export */ const src_WhiteBoard = (WhiteBoard);\n;// CONCATENATED MODULE: ./src/ScreenPage/Component.ts\n\n\n\nvar Component_Component = /*#__PURE__*/function () {\n  function Component() {\n    _classCallCheck(this, Component);\n  }\n\n  _createClass(Component, null, [{\n    key: "iFrameRecorderView",\n    value: function iFrameRecorderView(url) {\n      return "\\n      <div class=\\"iframe_wraper_container rr-ignore\\" id=\\"iframe_wraper_container\\">\\n        <iframe id=\\"screen_sync_iframe\\" class=\\"screen_sync_iframe\\" title=\\"screen sync\\" width=\\"100%\\" height=\\"100%\\" frameBorder=\\"0\\" scrolling=\\"yes\\" marginHeight=\\"0\\" marginWidth=\\"0\\" src=\\"".concat(url, "\\" allow=\\"autoplay; microphone; camera\\"></iframe>\\n      </div>\\n    ");\n    }\n  }, {\n    key: "iFramePlayerView",\n    value: function iFramePlayerView(touchImage, styled) {\n      return "\\n      <div class=\\"iframe_wraper_container rr-ignore\\" id=\\"iframe_wraper_container\\">\\n                <img class=\\"touch_image\\" src=\\"".concat(touchImage, "\\" style=\\"").concat(styled, "\\" />\\n      </div>\\n        ");\n    }\n  }, {\n    key: "customerSyncView",\n    value: function customerSyncView(_ref) {\n      var _ref$sync = _ref.sync,\n          sync = _ref$sync === void 0 ? true : _ref$sync,\n          _ref$url = _ref.url,\n          url = _ref$url === void 0 ? \'\' : _ref$url;\n      return "\\n      <div class=\\"customer_wraper rr-ignore\\">\\n        <div\\n            class=\\"iframe_wraper\\"\\n            style=\\"pointer-events: auto;\\"\\n        >\\n        </div>\\n    ";\n    }\n  }, {\n    key: "agentSyncView",\n    value: function agentSyncView(options) {\n      var width = options.width,\n          height = options.height,\n          _options$sync = options.sync,\n          sync = _options$sync === void 0 ? false : _options$sync;\n      return "\\n      <div class=\\"agent_wraper rr-ignore\\">\\n        <div\\n            class=\\"iframe_wraper\\"\\n            id=\\"iframe_wraper\\"\\n            style=\\"pointer-events: none; width:".concat(width, "px; height:").concat(height, "px\\"\\n        >\\n        </div>\\n    ");\n    }\n  }]);\n\n  return Component;\n}();\n\n/* harmony default export */ const ScreenPage_Component = (Component_Component);\n// EXTERNAL MODULE: ./node_modules/@zco/rrweb/lib/rrweb-all.js\nvar rrweb_all = __webpack_require__(126);\n;// CONCATENATED MODULE: ./src/ScreenPage/iFramePlayer.ts\n\n\n\n\n\n\n\n\nfunction iFramePlayer_createSuper(Derived) { var hasNativeReflectConstruct = iFramePlayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction iFramePlayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\nvar iFramePlayer = /*#__PURE__*/function (_Component) {\n  _inherits(iFramePlayer, _Component);\n\n  var _super = iFramePlayer_createSuper(iFramePlayer);\n\n  function iFramePlayer(options) {\n    var _this;\n\n    _classCallCheck(this, iFramePlayer);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), "domData", null);\n\n    _defineProperty(_assertThisInitialized(_this), "touchPosX", 0);\n\n    _defineProperty(_assertThisInitialized(_this), "touchPosY", 0);\n\n    _defineProperty(_assertThisInitialized(_this), "hideCursor", true);\n\n    _defineProperty(_assertThisInitialized(_this), "syncId", 0);\n\n    _defineProperty(_assertThisInitialized(_this), "lastSyncId", -1);\n\n    _this.wrapperEl = document.createElement(\'div\');\n    _this.wrapperEl.className = \'iframe-player-main-container\';\n    _this.wrapperEl.id = \'iframe-player-main-container\';\n    iFramePlayer.touchImage = options.touchImage;\n    iFramePlayer.sync = options.sync || false;\n    return _this;\n  }\n\n  _createClass(iFramePlayer, [{\n    key: "initReplayer",\n    value: function initReplayer(root) {\n      iFramePlayer.replayer = new rrweb_all/* Replayer */.xB([], {\n        root: root,\n        loadTimeout: 100,\n        liveMode: true,\n        showWarning: true,\n        showDebug: true,\n        mouseTail: false,\n        UNSAFE_replayCanvas: true,\n        // true js, false \n        pauseAnimation: false,\n        insertStyleRules: ["\\n                *::-webkit-scrollbar {\\n                    width: 0;\\n                }\\n                ", ".rr-block {display: inline-block}", ".rr-mask {display: inline-block; white-space: nowrap;}", ".screen-sync_container { display: none !important }"],\n        unpackFn: rrweb_all/* unpack */.Vv\n      });\n    }\n  }, {\n    key: "createComponent",\n    value: function createComponent() {\n      this.wrapperEl.innerHTML += iFramePlayer.iFramePlayerView(iFramePlayer.touchImage, this.touchImageStyle());\n    }\n  }, {\n    key: "render",\n    value: function render(el) {\n      if (!el) {\n        throw new Error(\'render element is not defined\');\n      }\n\n      el.appendChild(this.wrapperEl);\n    }\n  }, {\n    key: "setHideCursor",\n    value: function setHideCursor(status) {\n      this.hideCursor = status;\n      this.createComponent();\n    }\n  }, {\n    key: "getCursorHide",\n    value: function getCursorHide() {\n      return this.hideCursor;\n    }\n  }, {\n    key: "touchImageStyle",\n    value: function touchImageStyle() {\n      return this.hideCursor ? "\\n\\t\\t\\t\\ttop: ".concat(this.touchPosY - 16, "px;\\n\\t\\t\\t\\tleft: ").concat(this.touchPosX - 16, "px;\\n\\t\\t\\t\\ttransition: opacity 0.5s ease-out;\\n\\t\\t\\t\\topacity: ", 0, ";\\n\\t\\t\\t") : "\\n\\t\\t\\ttop: ".concat(this.touchPosY - 16, "px;\\n\\t\\t\\tleft: ").concat(this.touchPosX - 16, "px;\\n\\t\\t\\topacity: ", 1, ";\\n\\t\\t");\n    }\n  }, {\n    key: "onRemoteTouchPos",\n    value: function onRemoteTouchPos(pos) {\n      var _this2 = this;\n\n      this.setHideCursor(false);\n      this.touchPosX = pos.pageX;\n      this.touchPosY = pos.pageY; // hide cursor\n\n      setTimeout(function () {\n        _this2.setHideCursor(true);\n      }, 500);\n    }\n    /**  */\n\n  }, {\n    key: "setMessageIn",\n    value: function setMessageIn(message) {\n      console.log(\'iFramePlayer:\', message);\n      if (iFramePlayer.sync) return; // screensync\n\n      if (message.type === \'screensync\') {\n        if (message.action === \'screenshot\') {\n          // render player\n          console.log(\'iFramePlayer.replayer:\', message.domData, this.domData);\n\n          if (iFramePlayer.replayer) {\n            if (!this.domData) {\n              // first sync data\n              this.syncId = message.syncId || 0;\n              this.domData = message.domData;\n              iFramePlayer.replayer.startLive(this.domData.timestamp - 500);\n            }\n\n            console.log(\'replayer.addEvent:\', iFramePlayer.replayer.addEvent); // syncId\n\n            if (this.lastSyncId !== message.syncId) {\n              this.lastSyncId = message.syncId || 0;\n              this.syncId++;\n              iFramePlayer.replayer.addEvent(message.domData);\n            }\n          }\n        } else if (message.action === \'touchPos\') {\n          this.onRemoteTouchPos(message.value);\n        } else {\n          console.error(\'unhandled screensync message : \', message);\n        }\n      } else {\n        console.error(\'unhandled screensync message : \', message);\n      }\n    } // H5\n\n  }, {\n    key: "onMessage",\n    value: function onMessage(event) {\n      if (!event.data || !event.data.key) return;\n      if (event.data.key !== \'SCREENSYNC\') return;\n\n      if (event.data.type === \'SYNC\') {\n        if (event.data.action === \'scroll\') {\n          // \n          var canvas = document.getElementById(\'white-board-canvas\');\n\n          if (canvas) {\n            var parent = canvas.parentNode;\n            parent.style.top = "-".concat(event.data.value, "px");\n          }\n        } else if (event.data.action === \'size\') {\n          // size\n          if (iFramePlayer.onLocalSize) {\n            iFramePlayer.onLocalSize(event.data.value);\n          }\n        }\n      }\n    }\n  }]);\n\n  return iFramePlayer;\n}(ScreenPage_Component);\n\n_defineProperty(iFramePlayer, "sync", false);\n\n/* harmony default export */ const ScreenPage_iFramePlayer = (iFramePlayer);\n;// CONCATENATED MODULE: ./src/ScreenPage/iFrameRecorder.ts\n\n\n\n\n\n\n\n\nfunction iFrameRecorder_createSuper(Derived) { var hasNativeReflectConstruct = iFrameRecorder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction iFrameRecorder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\nvar Ifame = /*#__PURE__*/function (_Component) {\n  _inherits(Ifame, _Component);\n\n  var _super = iFrameRecorder_createSuper(Ifame);\n\n  function Ifame(el, options) {\n    var _this;\n\n    _classCallCheck(this, Ifame);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), "messageIn", {});\n\n    var _options$width = options.width,\n        width = _options$width === void 0 ? 0 : _options$width,\n        _options$height = options.height,\n        height = _options$height === void 0 ? 0 : _options$height,\n        isCustomer = options.isCustomer,\n        onLocalSize = options.onLocalSize,\n        onScreenSyncEnd = options.onScreenSyncEnd,\n        onScreenSyncMessage = options.onScreenSyncMessage;\n    _this.wrapperEl = el;\n    Ifame.onScreenSyncMessage = onScreenSyncMessage;\n    Ifame.onLocalSize = onLocalSize;\n    Ifame.onScreenSyncEnd = onScreenSyncEnd;\n    return _this;\n  }\n\n  _createClass(Ifame, [{\n    key: "init",\n    value: function init() {\n      if (Ifame.sync) {\n        this.addEventListener();\n      }\n    }\n  }, {\n    key: "destory",\n    value: function destory() {\n      this.stopScreensync();\n      this.unregister();\n      this.removeEventListener();\n    }\n  }, {\n    key: "setRemoteSize",\n    value: function setRemoteSize(options) {\n      var width = options.width,\n          height = options.height,\n          scrollHeight = options.scrollHeight;\n    }\n  }, {\n    key: "setLocalSize",\n    value: function setLocalSize() {}\n  }, {\n    key: "initiFrameRecorder",\n    value: function initiFrameRecorder() {\n      this.createComponent();\n      Ifame.ifameContainer = document.getElementById(\'iframe_wraper_container\');\n    }\n  }, {\n    key: "createComponent",\n    value: function createComponent() {\n      this.wrapperEl.innerHTML += Ifame.iFrameRecorderView(Ifame.url);\n    }\n  }, {\n    key: "render",\n    value: function render() {}\n  }, {\n    key: "setMessageIn",\n    value: function setMessageIn(message) {\n      this.messageIn = message;\n      this.onMessageIn(message);\n    }\n  }, {\n    key: "addEventListener",\n    value: function addEventListener() {\n      window.addEventListener(\'message\', this.onMessageIn, false);\n    }\n  }, {\n    key: "removeEventListener",\n    value: function removeEventListener() {\n      window.removeEventListener(\'message\', this.onMessageIn, false);\n    }\n  }, {\n    key: "register",\n    value: function register() {\n      if (!Ifame.ifameContainer) return;\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'REGISTER\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "unregister",\n    value: function unregister() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'UNREGISTER\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "requestSize",\n    value: function requestSize() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'SYNC\',\n        action: \'requestSize\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "requestScreenshot",\n    value: function requestScreenshot() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'SYNC\',\n        action: \'requestScreenshot\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "startScreensync",\n    value: function startScreensync() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'SYNC\',\n        action: \'startScreensync\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "stopScreensync",\n    value: function stopScreensync() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'SYNC\',\n        action: \'stopScreensync\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "getScreenshot",\n    value: function getScreenshot() {\n      var message = {\n        key: \'SCREENSYNC\',\n        type: \'SYNC\',\n        action: \'getScreenshot\'\n      };\n\n      if (Ifame.ifameContainer.contentWindow) {\n        Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n      }\n    }\n  }, {\n    key: "onIframeLoad",\n    value: function onIframeLoad() {\n      var _this2 = this;\n\n      // register message\n      setTimeout(function () {\n        _this2.register();\n      }, 3000);\n    } // H5\n\n  }, {\n    key: "onMessageIn",\n    value: function onMessageIn(event) {\n      if (!event.data || !event.data.key) return;\n      if (event.data.key !== \'SCREENSYNC\') return;\n\n      if (event.data.type === \'REGISTER\') {\n        var message = {\n          key: \'SCREENSYNC\',\n          type: \'REGISTER\'\n        };\n\n        if (Ifame.ifameContainer.contentWindow) {\n          Ifame.ifameContainer.contentWindow.postMessage(message, \'*\');\n        }\n      }\n\n      if (event.data.type === \'iFrameContentLoaded\') {\n        this.onIframeLoad();\n      }\n\n      if (event.data.type === \'SYNC\') {\n        if (event.data.action === \'scroll\') {\n          // \n          var canvas = document.getElementById(\'screensyncWhiteboard\');\n\n          if (canvas) {\n            var parent = canvas.parentNode;\n            parent.style.top = "-".concat(event.data.value, "px");\n          } // \n\n\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'scroll\',\n              value: event.data.value\n            }, \'screensync\');\n          }\n        } else if (event.data.action === \'size\') {\n          // size\n          if (Ifame.onLocalSize) {\n            Ifame.onLocalSize(event.data.value);\n          }\n\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'size\',\n              value: event.data.value\n            }, \'screensync\');\n          }\n        } else if (event.data.action === \'screenshot\') {\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'screenshot\',\n              domData: event.data.domData,\n              syncId: event.data.syncId\n            }, \'screensync\');\n          }\n        } else if (event.data.action === \'ignoreElements\') {\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'ignoreElements\',\n              value: event.data.value\n            }, \'screensync\');\n          }\n        } else if (event.data.action === \'touchPos\') {\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'touchPos\',\n              value: event.data.value\n            }, \'screensync\');\n          }\n        } else if (event.data.action === \'endScreenSync\') {\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'endScreenSync\'\n            }, \'screensync\'); // \n\n            if (Ifame.onScreenSyncEnd) {\n              Ifame.onScreenSyncEnd();\n            }\n          }\n        } else if (event.data.action === \'gotScreenshot\') {\n          if (Ifame.sync) {\n            Ifame.onScreenSyncMessage({\n              action: \'gotScreenshot\',\n              value: event.data.value\n            }, \'screensync\');\n          }\n        }\n      }\n    }\n  }]);\n\n  return Ifame;\n}(ScreenPage_Component);\n\n_defineProperty(Ifame, "sync", false);\n\n_defineProperty(Ifame, "url", \'\');\n\n/* harmony default export */ const iFrameRecorder = (Ifame);\n;// CONCATENATED MODULE: ./src/ScreenPage/index.ts\n\n\n\n\n\n\n\n\nfunction ScreenPage_createSuper(Derived) { var hasNativeReflectConstruct = ScreenPage_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction ScreenPage_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\nvar ScreenPage = /*#__PURE__*/function (_Component) {\n  _inherits(ScreenPage, _Component);\n\n  var _super = ScreenPage_createSuper(ScreenPage);\n\n  function ScreenPage(rootEl, options) {\n    var _this;\n\n    _classCallCheck(this, ScreenPage);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), "width", 0);\n\n    _defineProperty(_assertThisInitialized(_this), "height", 0);\n\n    _defineProperty(_assertThisInitialized(_this), "iframePlayer", null);\n\n    _defineProperty(_assertThisInitialized(_this), "iframeRecorder", null);\n\n    var isCustomer = options.isCustomer,\n        _options$width = options.width,\n        width = _options$width === void 0 ? 0 : _options$width,\n        _options$height = options.height,\n        height = _options$height === void 0 ? 0 : _options$height,\n        _options$sync = options.sync,\n        sync = _options$sync === void 0 ? false : _options$sync,\n        _options$url = options.url,\n        url = _options$url === void 0 ? \'\' : _options$url,\n        touchImage = options.touchImage,\n        onLocalSize = options.onLocalSize,\n        onScreenSyncMessage = options.onScreenSyncMessage,\n        onScreenSyncEnd = options.onScreenSyncEnd;\n    _this.el = document.createElement(\'div\');\n    _this.el.className = \'screen_sync_container rr-ignore\';\n    _this.el.id = \'screen_sync_container\';\n    _this.rootEl = rootEl;\n    _this.width = width;\n    _this.height = height;\n    _this.sync = sync;\n    _this.url = url;\n    _this.isCustomer = isCustomer;\n    _this.touchImage = touchImage;\n    _this.onLocalSize = onLocalSize;\n    _this.onScreenSyncMessage = onScreenSyncMessage;\n    _this.onScreenSyncEnd = onScreenSyncEnd;\n\n    _this.createDom();\n\n    return _this;\n  }\n  /**  */\n\n\n  _createClass(ScreenPage, [{\n    key: "createDom",\n    value: function createDom() {\n      if (!this.isCustomer) {\n        this.iframePlayer = new ScreenPage_iFramePlayer({\n          touchImage: this.touchImage,\n          sync: this.sync\n        });\n        this.el.innerHTML += ScreenPage_Component.agentSyncView({\n          width: this.width,\n          height: this.height,\n          sync: this.sync\n        });\n      } else {\n        this.el.innerHTML += ScreenPage_Component.customerSyncView({\n          sync: this.sync,\n          url: this.url\n        });\n        this.iframeRecorder = new iFrameRecorder(this.el, {\n          width: this.width,\n          height: this.height,\n          isCustomer: this.isCustomer,\n          onLocalSize: this.onLocalSize,\n          onScreenSyncMessage: this.onScreenSyncMessage,\n          onScreenSyncEnd: this.onScreenSyncEnd\n        });\n        this.iframeRecorder.initiFrameRecorder();\n      }\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      this.createComponent();\n      this.render();\n    }\n    /**  */\n\n  }, {\n    key: "render",\n    value: function render() {\n      var _this$iframePlayer, _this$iframePlayer2;\n\n      console.log(\'render\', this.el);\n      this.rootEl.appendChild(this.el);\n      (_this$iframePlayer = this.iframePlayer) === null || _this$iframePlayer === void 0 ? void 0 : _this$iframePlayer.render(document.getElementById(\'iframe_wraper\'));\n      (_this$iframePlayer2 = this.iframePlayer) === null || _this$iframePlayer2 === void 0 ? void 0 : _this$iframePlayer2.initReplayer(document.getElementById(\'iframe_wraper_container\'));\n    }\n    /**  */\n\n  }, {\n    key: "bindEvent",\n    value: function bindEvent() {}\n  }, {\n    key: "createComponent",\n    value: function createComponent() {\n      var _this$iframePlayer3;\n\n      (_this$iframePlayer3 = this.iframePlayer) === null || _this$iframePlayer3 === void 0 ? void 0 : _this$iframePlayer3.createComponent();\n    }\n  }, {\n    key: "setMessageIn",\n    value: function setMessageIn(message) {\n      var _this$iframeRecorder, _this$iframePlayer4;\n\n      (_this$iframeRecorder = this.iframeRecorder) === null || _this$iframeRecorder === void 0 ? void 0 : _this$iframeRecorder.setMessageIn(message);\n      (_this$iframePlayer4 = this.iframePlayer) === null || _this$iframePlayer4 === void 0 ? void 0 : _this$iframePlayer4.setMessageIn(message);\n    }\n  }]);\n\n  return ScreenPage;\n}(ScreenPage_Component);\n\n/* harmony default export */ const src_ScreenPage = (ScreenPage);\n;// CONCATENATED MODULE: ./src/ZcoScreenSync/index.ts\n\n\n\n\n\n\n\nvar ZcoSyncScreen = /*#__PURE__*/function () {\n  //  or \n  // \n  function ZcoSyncScreen(rootEl, options) {\n    _classCallCheck(this, ZcoSyncScreen);\n\n    _defineProperty(this, "whiteBoard", null);\n\n    _defineProperty(this, "screenPage", null);\n\n    _defineProperty(this, "markTools", [{\n      id: 1,\n      mode: ToolMode.PEN,\n      isActive: true\n    }, {\n      id: 2,\n      mode: ToolMode.LINE,\n      isActive: false\n    }, {\n      id: 3,\n      mode: ToolMode.REMOVE,\n      isActive: false\n    }, {\n      id: 4,\n      mode: ToolMode.CRICLE,\n      isActive: false\n    }, {\n      id: 5,\n      mode: ToolMode.TEXT,\n      isActive: false\n    }, {\n      id: 6,\n      mode: ToolMode.RECTANGLE,\n      isActive: false\n    }]);\n\n    var isCustomer = options.isCustomer,\n        _options$url = options.url,\n        url = _options$url === void 0 ? \'\' : _options$url,\n        width = options.width,\n        height = options.height,\n        onScreenSyncEnd = options.onScreenSyncEnd,\n        sendCustomMessage = options.sendCustomMessage,\n        onScreenSyncMessage = options.onScreenSyncMessage;\n    var screenWidth = width ? width : isCustomer ? ZcoSyncScreen.localWidth : ZcoSyncScreen.remoteWidth;\n    var screenHeight = height ? height : isCustomer ? ZcoSyncScreen.localHeight : ZcoSyncScreen.remoteHeight;\n    ZcoSyncScreen.remoteWidth = screenWidth;\n    ZcoSyncScreen.remoteHeight = screenHeight;\n    ZcoSyncScreen.localWidth = screenWidth;\n    ZcoSyncScreen.localHeight = screenHeight;\n    this.rootContainer = document.getElementById(rootEl) || document.body;\n    var mainContianer = document.createElement(\'div\');\n    mainContianer.id = \'screen-sync-main-wrapper\';\n    mainContianer.className = \'screen-sync-main-wrapper\';\n    this.rootContainer.appendChild(mainContianer);\n    ZcoSyncScreen.isCustomer = isCustomer;\n    ZcoSyncScreen.onScreenSyncEnd = onScreenSyncEnd;\n    ZcoSyncScreen.onScreenSyncMessage = onScreenSyncMessage;\n    ZcoSyncScreen.sendCustomerMessage = sendCustomMessage;\n    this.screenPage = new src_ScreenPage(mainContianer, {\n      isCustomer: isCustomer,\n      width: screenWidth,\n      height: screenHeight,\n      sync: false,\n      url: \'\',\n      touchImage: ZcoSyncScreen.touchImage,\n      onLocalSize: this.onLocalSize,\n      onScreenSyncMessage: onScreenSyncMessage,\n      onScreenSyncEnd: onScreenSyncEnd\n    });\n    this.createDom();\n    this.initScreen();\n  }\n\n  _createClass(ZcoSyncScreen, [{\n    key: "createDom",\n    value: function createDom() {\n      var _this$screenPage, _document$getElementB;\n\n      (_this$screenPage = this.screenPage) === null || _this$screenPage === void 0 ? void 0 : _this$screenPage.init();\n      var whiateBoardContainer = document.createElement(\'div\');\n      whiateBoardContainer.id = \'whiteboard_wraper\';\n      whiateBoardContainer.className = \'whiteboard_wraper\';\n      whiateBoardContainer.style.pointerEvents = \'auto\';\n      whiateBoardContainer.style.top = \'0\';\n      (_document$getElementB = document.getElementById(\'screen_sync_container\')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.children[0].appendChild(whiateBoardContainer);\n\n      if (ZcoSyncScreen.isCustomer && ZcoSyncScreen.isLocalSizeGot) {\n        this.whiteBoard = new src_WhiteBoard(whiateBoardContainer, this.markTools, ZcoSyncScreen.localWidth, ZcoSyncScreen.localHeight, ZcoSyncScreen.isCustomer, ZcoSyncScreen.sync, ZcoSyncScreen.isStartedSync, ZcoSyncScreen.onScreenSyncMessage, ZcoSyncScreen.sendCustomerMessage);\n      } else if (!ZcoSyncScreen.isCustomer && ZcoSyncScreen.isRemoteSizeGot && !ZcoSyncScreen.isHideMarkTool) {\n        this.whiteBoard = new src_WhiteBoard(whiateBoardContainer, this.markTools, ZcoSyncScreen.remoteWidth, ZcoSyncScreen.remoteHeight, ZcoSyncScreen.isCustomer, true, ZcoSyncScreen.isStartedSync, ZcoSyncScreen.onScreenSyncMessage, ZcoSyncScreen.sendCustomerMessage);\n        this.whiteBoard.init();\n      }\n    }\n  }, {\n    key: "initScreen",\n    value: function initScreen() {\n      var _this = this;\n\n      if (!ZcoSyncScreen.isCustomer) {\n        this.startScreensync();\n        setTimeout(function () {\n          _this.getCustomerSize();\n\n          _this.requestScreenshot();\n        }, 100);\n      }\n    } // \n\n  }, {\n    key: "onRemoteSize",\n    value: function onRemoteSize(size) {\n      ZcoSyncScreen.remoteWidth = size.width;\n      ZcoSyncScreen.remoteHeight = size.height;\n      ZcoSyncScreen.remoteScrollHeight = size.scrollHeight;\n      ZcoSyncScreen.isRemoteSizeGot = true;\n    } // \n\n  }, {\n    key: "onLocalSize",\n    value: function onLocalSize(size) {\n      ZcoSyncScreen.localWidth = size.width;\n      ZcoSyncScreen.localHeight = size.height;\n      ZcoSyncScreen.localScrollHeight = size.scrollHeight;\n      ZcoSyncScreen.isLocalSizeGot = true;\n    }\n  }, {\n    key: "getScreenSize",\n    value: function getScreenSize() {\n      if (ZcoSyncScreen.isCustomer) {\n        return {\n          width: ZcoSyncScreen.remoteWidth,\n          height: ZcoSyncScreen.remoteHeight,\n          scrollHeight: ZcoSyncScreen.remoteScrollHeight\n        };\n      } else {\n        return {\n          width: ZcoSyncScreen.localWidth,\n          height: ZcoSyncScreen.localHeight,\n          scrollHeight: ZcoSyncScreen.localScrollHeight\n        };\n      }\n    }\n  }, {\n    key: "setScreenSize",\n    value: function setScreenSize() {\n      if (ZcoSyncScreen.isCustomer) {\n        return {\n          width: ZcoSyncScreen.remoteWidth,\n          height: ZcoSyncScreen.remoteHeight,\n          scrollHeight: ZcoSyncScreen.remoteScrollHeight\n        };\n      } else {\n        return {\n          width: ZcoSyncScreen.localWidth,\n          height: ZcoSyncScreen.localHeight,\n          scrollHeight: ZcoSyncScreen.localScrollHeight\n        };\n      }\n    }\n  }, {\n    key: "setToolHide",\n    value: function setToolHide(status) {\n      var _this$whiteBoard;\n\n      (_this$whiteBoard = this.whiteBoard) === null || _this$whiteBoard === void 0 ? void 0 : _this$whiteBoard.setToolHide(status);\n    } // \n\n  }, {\n    key: "startScreensync",\n    value: function startScreensync() {\n      if (!ZcoSyncScreen.isCustomer) {\n        this.onMessageOutInner({\n          action: \'startScreensync\'\n        }, \'screensync\');\n      }\n    } // \n\n  }, {\n    key: "stopScreensync",\n    value: function stopScreensync() {\n      if (!ZcoSyncScreen.isCustomer) {\n        this.onMessageOutInner({\n          action: \'stopScreensync\'\n        }, \'screensync\');\n      }\n    } // \n\n  }, {\n    key: "getCustomerSize",\n    value: function getCustomerSize() {\n      if (!ZcoSyncScreen.isCustomer) {\n        this.onMessageOutInner({\n          action: \'requestSize\'\n        }, \'screensync\');\n      }\n    } // \n\n  }, {\n    key: "requestScreenshot",\n    value: function requestScreenshot() {\n      if (!ZcoSyncScreen.isCustomer) {\n        this.onMessageOutInner({\n          action: \'requestScreenshot\'\n        }, \'screensync\');\n      }\n    } // \n\n  }, {\n    key: "onMessageOutInner",\n    value: function onMessageOutInner(message, type) {\n      var role = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'all\';\n\n      if (ZcoSyncScreen.isCustomer && !ZcoSyncScreen.isStartedSync && message && message.action !== \'size\' && message.action !== \'endScreenSync\' && message.action !== \'gotScreenshot\') {\n        console.error(\'onMessageOutInner : \', ZcoSyncScreen.isStartedSync, message);\n        return;\n      }\n\n      if (ZcoSyncScreen.onScreenSyncMessage) {\n        ZcoSyncScreen.onScreenSyncMessage(Object.assign({}, {\n          type: type\n        }, message));\n      } else {\n        console.error(\'no message sender provided!\');\n      }\n    }\n    /**  */\n\n  }, {\n    key: "onIncomingMessage",\n    value: function onIncomingMessage(message) {\n      if (!message) return;\n\n      if (message.type === \'screensync\') {\n        if (message.action === \'scroll\' || message.action === \'screenshot\' || message.action === \'ignoreElements\' || message.action === \'touchPos\') {\n          if (!ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else if (message.action === \'size\') {\n          if (!ZcoSyncScreen.isCustomer) {\n            this.onRemoteSize(message.value);\n          }\n        } else if (message.action === \'startScreensync\') {\n          if (ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.isStartedSync = true;\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else if (message.action === \'stopScreensync\') {\n          if (ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.isStartedSync = false;\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else if (message.action === \'requestSize\') {\n          if (ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else if (message.action === \'requestScreenshot\') {\n          if (ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else if (message.action === \'getScreenshot\') {\n          if (ZcoSyncScreen.isCustomer) {\n            ZcoSyncScreen.h5MessageIn = message;\n          }\n        } else {\n          console.error(\'unhandled screensync messgae in : \', message);\n        }\n      } else if (message.type === \'whiteboard\') {\n        ZcoSyncScreen.markerMessageIn = message;\n      } else {\n        console.error(\'unhandled messgae in : \', message);\n      }\n    }\n  }, {\n    key: "syncUrl",\n    value: function syncUrl() {\n      // url //  /\n      // https://ivcs-dev-k8s.zealcomm.cn//customer//#/link\n      // https://ivcs-dev-k8s.zealcomm.cn/customer/#/link\n      var index = ZcoSyncScreen.url.indexOf(\'://\') + 3;\n      var protocol = ZcoSyncScreen.url.substring(0, index);\n      var path = ZcoSyncScreen.url.substring(index).replaceAll(\'///\', \'/\');\n      path = path.replaceAll(\'//\', \'/\');\n      return protocol + path;\n    }\n  }, {\n    key: "setMessageIn",\n    value: function setMessageIn(message) {\n      var _this$screenPage2;\n\n      if (message.action === \'size\') {\n        this.onRemoteSize(message.value);\n      }\n\n      this.onIncomingMessage(message);\n      (_this$screenPage2 = this.screenPage) === null || _this$screenPage2 === void 0 ? void 0 : _this$screenPage2.setMessageIn(message);\n    }\n  }, {\n    key: "destory",\n    value: function destory() {\n      var container = document.getElementById(\'screen-sync-main-wrapper\');\n      console.log(\'destory:\', this.rootContainer);\n\n      if (container && this.rootContainer) {\n        this.rootContainer.removeChild(container);\n      }\n    }\n  }]);\n\n  return ZcoSyncScreen;\n}();\n\n_defineProperty(ZcoSyncScreen, "isCustomer", false);\n\n_defineProperty(ZcoSyncScreen, "url", \'\');\n\n_defineProperty(ZcoSyncScreen, "isHideMarkTool", false);\n\n_defineProperty(ZcoSyncScreen, "remoteWidth", 375);\n\n_defineProperty(ZcoSyncScreen, "remoteHeight", 667);\n\n_defineProperty(ZcoSyncScreen, "remoteScrollHeight", 667);\n\n_defineProperty(ZcoSyncScreen, "localWidth", 375);\n\n_defineProperty(ZcoSyncScreen, "localHeight", 667);\n\n_defineProperty(ZcoSyncScreen, "localScrollHeight", 667);\n\n_defineProperty(ZcoSyncScreen, "isLocalSizeGot", false);\n\n_defineProperty(ZcoSyncScreen, "isRemoteSizeGot", true);\n\n_defineProperty(ZcoSyncScreen, "isStartedSync", false);\n\n_defineProperty(ZcoSyncScreen, "sync", false);\n\n_defineProperty(ZcoSyncScreen, "touchImage", \'data:image/svg+xml;base64,PHN2ZyB0PSIxNjI2NzYwOTUzODA2IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE4MjAiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNNTEyIDUxMm0tNTEyIDBhNTEyIDUxMiAwIDEgMCAxMDI0IDAgNTEyIDUxMiAwIDEgMC0xMDI0IDBaIiBmaWxsPSIjMTNDRjMxIiBmaWxsLW9wYWNpdHk9Ii40MDEiIHAtaWQ9IjE4MjEiPjwvcGF0aD48cGF0aCBkPSJNNTEyIDUxMm0tMzQxLjMzMzMzMyAwYTM0MS4zMzMzMzMgMzQxLjMzMzMzMyAwIDEgMCA2ODIuNjY2NjY2IDAgMzQxLjMzMzMzMyAzNDEuMzMzMzMzIDAgMSAwLTY4Mi42NjY2NjYgMFoiIGZpbGw9IiMxNERGMjUiIHAtaWQ9IjE4MjIiPjwvcGF0aD48L3N2Zz4=\');\n\n\n;// CONCATENATED MODULE: ./src/main.ts\n // (() => {\n// \tconst sendCustomMessage = () => {};\n// \tconst onScreenSyncMessage = () => {};\n// \tconst onScreenSyncEnd = () => {};\n// \tconst messageIn = {};\n// \tconst init = () => {\n// \t\tconst zcoSyncScreen = new ZcoSyncScreen(\'root\', { isCustomer: false, url: \'\', width: 390, height: 844, messageIn, onScreenSyncEnd, sendCustomMessage, onScreenSyncMessage });\n// \t};\n// \tinit();\n// })();\n\n/* harmony default export */ const main = (ZcoSyncScreen);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1lBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7O0FDZkE7Ozs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7OztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFNQTs7O0FBRUE7QUFDQTtBQUdBOzs7Ozs7QUFHQTs7Ozs7Ozs7Ozs7OztBQy9CQTs7QUFHQTs7Ozs7QUFLQTtBQUFBOztBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFPQTs7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE5Q0E7O0FBQUE7O0FBaURBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUVBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7O0FBQ0E7QUFFQTs7QUFFQTs7Ozs7QUFTQTtBQWVBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBREE7O0FBQUE7O0FBQUE7QUFqQkE7QUFBQTtBQUFBOztBQWlCQTtBQWhCQTtBQUFBO0FBQUE7O0FBZ0JBO0FBZkE7QUFBQTtBQUFBOztBQWVBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQVlBOzs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUEvRUE7O0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBM1lBOztBQUFBOztBQThZQTs7Ozs7Ozs7Ozs7Ozs7QUNyWkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7Ozs7QUFjQTtBQVVBOztBQUFBOztBQUNBOztBQURBOztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWFBO0FBRUE7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7OztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFwSEE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7O0FBdUhBO0FBSUE7Ozs7O0FDaElBOzs7Ozs7O0FBQ0E7QUFDQTtBQUtBOzs7QUFFQTtBQUNBO0FBS0E7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVFBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFTQTs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTs7QUFFQTs7Ozs7QUFhQTtBQUFBOztBQUFBOztBQUNBOztBQURBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBVUE7QUFuQkE7QUFxQkE7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQVlBOzs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFsSkE7O0FBQUE7O0FBcUpBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTs7QUFHQTs7Ozs7QUFVQTtBQUFBOztBQUFBOztBQUNBOztBQURBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBT0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7O0FBaFBBOztBQUFBOztBQUFBOztBQW1QQTs7Ozs7Ozs7Ozs7Ozs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBY0E7QUFBQTs7QUFBQTs7QUFDQTs7QUFEQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQWhCQTtBQWlCQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUExRUE7O0FBNkVBOzs7OztBQ2xGQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBOEJBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQUE7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBV0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBOVFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOzs7O0FDTEE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcz9kNGVjIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzP2JlZTIiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/YWRlMyIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjU3ZSIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcz9iMzgwIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzPzI2MmUiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzPzUzY2EiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz85OWRlIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzPzdlODQiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9zcmMvV2hpdGVCb2FyZC90eXBpbmcudHM/NmM2NyIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL3NyYy9XaGl0ZUJvYXJkL0NvbXBvbmVudC50cz8yNGNlIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vc3JjL1doaXRlQm9hcmQvTWFya1Rvb2wudHM/MzUyZiIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL3NyYy9XaGl0ZUJvYXJkL3VzZXJBZ2VudC50cz9hMmRiIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vc3JjL1doaXRlQm9hcmQvQ2FudmFzRHJhdy50cz81MzE1Iiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vc3JjL1doaXRlQm9hcmQvaW5kZXgudHM/ZjA5MSIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL3NyYy9TY3JlZW5QYWdlL0NvbXBvbmVudC50cz9jMWI5Iiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vc3JjL1NjcmVlblBhZ2UvaUZyYW1lUGxheWVyLnRzP2U2Y2MiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9zcmMvU2NyZWVuUGFnZS9pRnJhbWVSZWNvcmRlci50cz84Y2QyIiwid2VicGFjazovL3N5bmMtc2NyZWVuLy4vc3JjL1NjcmVlblBhZ2UvaW5kZXgudHM/ODMwZSIsIndlYnBhY2s6Ly9zeW5jLXNjcmVlbi8uL3NyYy9aY29TY3JlZW5TeW5jL2luZGV4LnRzPzg0NDUiLCJ3ZWJwYWNrOi8vc3luYy1zY3JlZW4vLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59IiwiZXhwb3J0IHR5cGUgSU9uTWVzc2FnZU91dCA9IChkYXRhOiBJT25NZXNzYWdlLCB0eXBlOiBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElPbk1lc3NhZ2Uge1xyXG5cdGFjdGlvbj86IHN0cmluZztcclxuXHR2YWx1ZT86IHN0cmluZztcclxuXHRpbWFnZURhdGE/OiBJSW1hZ2VEYXRhO1xyXG5cdGlnbm9yZUVsZW1lbnRzPzogc3RyaW5nW107XHJcblx0a2V5Pzogc3RyaW5nO1xyXG5cdHR5cGU/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUltYWdlRGF0YSB7XHJcblx0d2lkdGg/OiBudW1iZXI7XHJcblx0aGVpZ2h0PzogbnVtYmVyO1xyXG5cdHVybD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGVudW0gVG9vbE1vZGUge1xyXG5cdFBFTiA9ICdwZW4nLFxyXG5cdExJTkUgPSAnbGluZScsXHJcblx0UkVDVEFOR0xFID0gJ3JlY3RhbmdsZScsXHJcblx0Q1JJQ0xFID0gJ2NpcmNsZScsXHJcblx0VEVYVCA9ICd0ZXh0JyxcclxuXHRSRU1PVkUgPSAncmVtb3ZlJ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xzUHJvcHMge1xyXG5cdGlkOiBudW1iZXI7XHJcblx0bW9kZTogVG9vbE1vZGU7XHJcblx0aXNBY3RpdmU6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FudmFzUHJvcHMge1xyXG5cdGVsZW1lbnRJZDogc3RyaW5nO1xyXG5cdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XHJcblx0d2lkdGg6IG51bWJlcjtcclxuXHRoZWlnaHQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUb29sT3B0aW9uc1Byb3BzIHtcclxuXHR3aWR0aD86IG51bWJlcjtcclxuXHRoZWlnaHQ/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFya1Rvb2xPcHRpb25zIHtcclxuXHR3cmFwcGVyRWw6IEhUTUxFbGVtZW50O1xyXG5cdHRvb2xzOiBUb29sc1Byb3BzW107XHJcblx0d2lkdGg6IG51bWJlcjtcclxuXHRoZWlnaHQ6IG51bWJlcjtcclxuXHRzeW5jOiBib29sZWFuO1xyXG5cdHNldERyYXdNb2RlOiAobW9kZTogc3RyaW5nKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhbnZhc0RyYXdPcHRpb25zIHtcclxuXHR3cmFwcGVyRWw6IEhUTUxFbGVtZW50O1xyXG5cdHdpZHRoOiBudW1iZXI7XHJcblx0aGVpZ2h0OiBudW1iZXI7XHJcblx0c3luYzogYm9vbGVhbjtcclxuXHRnZXREcmF3TW9kZTogKCkgPT4gc3RyaW5nO1xyXG5cdG9uU2NyZWVuU3luY01lc3NhZ2U6IElPbk1lc3NhZ2VPdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNpemUge1xyXG5cdHdpZHRoOiBudW1iZXI7XHJcblx0aGVpZ2h0OiBudW1iZXI7XHJcblx0c2Nyb2xsSGVpZ2h0OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUltYWdlRGF0YSB7XHJcblx0d2lkdGg/OiBudW1iZXI7XHJcblx0aGVpZ2h0PzogbnVtYmVyO1xyXG5cdHVybD86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJT25NZXNzYWdlIHtcclxuXHRhY3Rpb24/OiBzdHJpbmc7XHJcblx0dmFsdWU/OiBzdHJpbmc7XHJcblx0aW1hZ2VEYXRhPzogSUltYWdlRGF0YTtcclxuXHRpZ25vcmVFbGVtZW50cz86IHN0cmluZ1tdO1xyXG5cdGtleT86IHN0cmluZztcclxuXHR0eXBlPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElXaGl0ZUJvYXJkT3B0aW9ucyB7XHJcblx0aXNDdXN0b21lcj86IGJvb2xlYW47XHJcblx0dG9vbHM6IFRvb2xzUHJvcHNbXTtcclxuXHR3aWR0aDogbnVtYmVyO1xyXG5cdGhlaWdodDogbnVtYmVyO1xyXG5cdG9uTWVzc2FnZU91dD86IElPbk1lc3NhZ2VPdXQ7XHJcblx0c2VuZEN1c3RvbU1lc3NhZ2U6IElTZW5kQ3VzdG9tZXJNZXNhZ2dlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBJU2VuZEN1c3RvbWVyTWVzYWdnZSA9IChtZXNzYWdlOiBJT25NZXNzYWdlLCByb2xlOiBzdHJpbmcsIHN1Y2Nlc3M6IChzdWNjZXNzOiBzdHJpbmcpID0+IHZvaWQsIGVycm9yOiAoZXJyb3I6IHN0cmluZykgPT4gdm9pZCkgPT4gdm9pZDtcclxuIiwiaW1wb3J0IHsgVG9vbHNQcm9wcyB9IGZyb20gJy4vdHlwaW5nJztcclxuXHJcbmFic3RyYWN0IGNsYXNzIENvbXBvbmVudCB7XHJcblx0cHJvdGVjdGVkIHN0YXRpYyB0b29sSXRlbVZpZXcodG9vbDogVG9vbHNQcm9wcyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCB7IG1vZGUsIGlzQWN0aXZlLCBpZCB9ID0gdG9vbDtcclxuXHRcdHJldHVybiBgXHJcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cInRvb2xzLXdyYXBwZXItaXRlbVwiIGRhdGEtaWQ9XCIke2lkfVwiPlxyXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJ0b29sLWljb24gdG9vbC0ke21vZGV9XCIgZGF0YS1pZD1cIiR7aWR9XCI+PC9pPlxyXG4gICAgICAgICAgICA8L2xpPiBcclxuICAgICAgICBgO1xyXG5cdH1cclxuXHRwcm90ZWN0ZWQgc3RhdGljIHRvb2xMaXN0VmlldyhkYXRhOiBUb29sc1Byb3BzW10sIHN5bmM6IGJvb2xlYW4pOiBzdHJpbmcge1xyXG5cdFx0aWYgKGRhdGEubGVuZ3RoIDw9IDAgJiYgIXN5bmMpIHJldHVybiAnJztcclxuXHRcdHJldHVybiBgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29scy1saXN0LXdyYXBwZXJcIiBpZD1cInRvb2xzLWxpc3Qtd3JhcHBlclwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwidG9vbHMtd3JhcHBlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICR7ZGF0YS5tYXAodG9vbCA9PiBDb21wb25lbnQudG9vbEl0ZW1WaWV3KHRvb2wpKX1cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIGBcclxuXHRcdFx0LnNwbGl0KCcsJylcclxuXHRcdFx0LmpvaW4oJycpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBjYW52YXNXcmFwcGVyVmlldyhlbGVtZW50SWQ6IHN0cmluZywgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBcclxuICAgICAgICAgICAgPGNhbnZhcyBpZD1cIiR7ZWxlbWVudElkfVwiIHdpZHRoPVwiJHt3aWR0aH1cIiBoZWlnaHQ9XCIke2hlaWdodH1cIj48L2NhbnZhcz5cclxuICAgICAgICBgO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xyXG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50JztcclxuaW1wb3J0IHsgTWFya1Rvb2xPcHRpb25zLCBUb29sc1Byb3BzIH0gZnJvbSAnLi90eXBpbmcnO1xyXG5cclxuY2xhc3MgTWFya1Rvb2wgZXh0ZW5kcyBDb21wb25lbnQge1xyXG5cdHByaXZhdGUgd3JhcHBlckVsOiBIVE1MRWxlbWVudDtcclxuXHRwcml2YXRlIHN0YXRpYyB0b29sczogVG9vbHNQcm9wc1tdO1xyXG5cdHByaXZhdGUgc2V0RHJhd01vZGU6IChtb2RlOiBzdHJpbmcpID0+IHZvaWQ7XHJcblx0cHJpdmF0ZSBzdGF0aWMgc3luYzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM6IE1hcmtUb29sT3B0aW9ucykge1xyXG5cdFx0Y29uc3QgeyB3cmFwcGVyRWwsIHRvb2xzLCBzZXREcmF3TW9kZSwgc3luYyA9IGZhbHNlIH0gPSBvcHRpb25zO1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMud3JhcHBlckVsID0gd3JhcHBlckVsO1xyXG5cdFx0TWFya1Rvb2wudG9vbHMgPSB0b29scztcclxuXHRcdE1hcmtUb29sLnN5bmMgPSBzeW5jO1xyXG5cdFx0dGhpcy5zZXREcmF3TW9kZSA9IHNldERyYXdNb2RlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHJlbmRlcigpIHtcclxuXHRcdHRoaXMud3JhcHBlckVsLmlubmVySFRNTCArPSBDb21wb25lbnQudG9vbExpc3RWaWV3KE1hcmtUb29sLnRvb2xzLCBNYXJrVG9vbC5zeW5jKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBiaW5kRXZlbnQoKSB7XHJcblx0XHRjb25zdCB0b29sQ29udGFpbmVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50b29scy13cmFwcGVyICcpITtcclxuXHRcdHRvb2xDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcyksIGZhbHNlKTtcclxuXHRcdGNvbnN0IHRvb2xzOiBIVE1MQ29sbGVjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Rvb2xzLXdyYXBwZXItaXRlbSAnKTtcclxuXHRcdGNvbnN0IGVsZSA9IHRvb2xzWzBdIGFzIEhUTUxFbGVtZW50O1xyXG5cdFx0aWYgKGVsZSkge1xyXG5cdFx0XHRlbGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNkM2U5ZTEnO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBoYW5kbGVDbGljayhldnQ6IE1vdXNlRXZlbnQpIHtcclxuXHRcdGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcblx0XHRjb25zdCB0b29sczogSFRNTENvbGxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0b29scy13cmFwcGVyLWl0ZW0gJyk7XHJcblx0XHRpZiAodGFyZ2V0LmRhdGFzZXQuaWQpIHtcclxuXHRcdFx0Y29uc3QgX2lkID0gcGFyc2VJbnQodGFyZ2V0LmRhdGFzZXQuaWQpO1xyXG5cdFx0XHRNYXJrVG9vbC50b29scyA9IE1hcmtUb29sLnRvb2xzLm1hcCgodG9vbCwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRsZXQgZWxlID0gdG9vbHNbaW5kZXhdIGFzIEhUTUxFbGVtZW50O1xyXG5cdFx0XHRcdGlmICh0b29sLmlkID09PSBfaWQpIHtcclxuXHRcdFx0XHRcdHRvb2wuaXNBY3RpdmUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dGhpcy5zZXREcmF3TW9kZSh0b29sLm1vZGUpO1xyXG5cdFx0XHRcdFx0ZWxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZDNlOWUxJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9vbC5pc0FjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0ZWxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcnO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdG9vbDtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXJrVG9vbDtcclxuIiwiLyoqIOiuvuWkhyBVQSDkv6Hmga8gKi9cclxuY29uc3QgVUEgPSB7XHJcblx0aW5Nb2JpbGU6IGZhbHNlLFxyXG5cdGluQW5kcm9pZDogZmFsc2UsXHJcblx0aW5pUGFkOiBmYWxzZSxcclxuXHRpbk1hYzogZmFsc2UsXHJcblx0aW5pUGhvbmU6IGZhbHNlLFxyXG5cdGluSU9TOiBmYWxzZSxcclxuXHRpblNhbXN1bmc6IGZhbHNlLFxyXG5cdGluV2VpY2hhdDogZmFsc2UsXHJcblx0aW5TYWZhcmk6IGZhbHNlLFxyXG5cdGluQ2hyb21lOiBmYWxzZSxcclxuXHRpblFRQnJvd3NlcjogZmFsc2UsXHJcblx0aW5VQ0Jyb3dzZXI6IGZhbHNlLFxyXG5cdGluSUU6IGZhbHNlLFxyXG5cdGluT3BlcmE6IGZhbHNlLFxyXG5cdGluV2ViS2l0OiBmYWxzZSxcclxuXHRpbkZpcmVGb3g6IGZhbHNlXHJcbn07XHJcbmNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcblVBLmluTW9iaWxlID0gISF1c2VyQWdlbnQubWF0Y2goL2FwcGxld2Via2l0Liptb2JpbGUuKi9pKTsgLy8g56e75Yqo57uI56uvXHJcblVBLmluQW5kcm9pZCA9IHVzZXJBZ2VudC5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/LykgPyB0cnVlIDogZmFsc2U7IC8vIGFuZHJvaWTnu4jnq69cclxuVUEuaW5pUGFkID0gdXNlckFnZW50Lm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLykgPyB0cnVlIDogZmFsc2U7IC8vIGlQYWTnu4jnq69cclxuVUEuaW5NYWMgPSB1c2VyQWdlbnQubWF0Y2goLyhNYWNcXHNPUylcXHNYXFxzKFtcXGRfXSspLykgPyB0cnVlIDogZmFsc2U7IC8vIGlNYWPnu4jnq69cclxuVUEuaW5pUGhvbmUgPSAhVUEuaW5pUGFkICYmIHVzZXJBZ2VudC5tYXRjaCgvKGlQaG9uZVxcc09TKVxccyhbXFxkX10rKS8pID8gdHJ1ZSA6IGZhbHNlOyAvLyBpUGhvbmXnu4jnq69cclxuVUEuaW5JT1MgPSBVQS5pbmlQYWQgfHwgVUEuaW5NYWMgfHwgVUEuaW5pUGhvbmU7IC8vIGlvc+e7iOerr1xyXG5VQS5pblNhbXN1bmcgPSB1c2VyQWdlbnQudG9VcHBlckNhc2UoKS5pbmRleE9mKCdTQU1TVU5HLVNNLU43NTA4VicpICE9IC0xO1xyXG5cclxuVUEuaW5XZWljaGF0ID0gdXNlckFnZW50Lm1hdGNoKC9NaWNyb01lc3Nlbmdlci9pKSAhPSBudWxsOyAvLyDlvq7kv6HlhoXpg6jmtY/op4jlmahcclxuVUEuaW5TYWZhcmkgPSB1c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgIT0gLTE7IC8vIFNhZmFyaVxyXG5VQS5pbkNocm9tZSA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lL2kpICE9IG51bGwgJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvXFxkK1xcLlxcZCsoXFwuXFxkKyk/XFxzQ2hyb21lXFwvL2kpID09IG51bGwgPyB0cnVlIDogZmFsc2U7XHJcblVBLmluUVFCcm93c2VyID0gdXNlckFnZW50Lm1hdGNoKC9NUVFCcm93c2VyXFwvKFtcXGRcXC5dKykvKSA/IHRydWUgOiBmYWxzZTsgLy8gUVHmtY/op4jlmahcclxuVUEuaW5VQ0Jyb3dzZXIgPSB1c2VyQWdlbnQubWF0Y2goL1VDQnJvd3NlclxcLyhbXFxkXFwuXSspLykgPyB0cnVlIDogZmFsc2U7XHJcblVBLmluSUUgPSB1c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvaSkgIT0gbnVsbDsgLy8gSUXlhoXmoLhcclxuVUEuaW5PcGVyYSA9IHVzZXJBZ2VudC5tYXRjaCgvUHJlc3RvL2kpICE9IG51bGw7IC8vIG9wZXJh5YaF5qC4XHJcblVBLmluV2ViS2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZXdlYmtpdC9pKSAhPSBudWxsOyAvLyDoi7nmnpzjgIHosLfmrYzlhoXmoLhcclxuVUEuaW5GaXJlRm94ID0gdXNlckFnZW50Lm1hdGNoKC9HZWNrby9pKSAhPSBudWxsICYmIHVzZXJBZ2VudC5tYXRjaCgva2h0bWwvaSkgIT0gbnVsbDsgLy8g54Gr54uQ5YaF5qC4XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVQTtcclxuIiwiaW1wb3J0IHsgQ2FudmFzRHJhd09wdGlvbnMsIElPbk1lc3NhZ2UsIElPbk1lc3NhZ2VPdXQgfSBmcm9tICcuL3R5cGluZyc7XHJcblxyXG5jb25zdCBmYWJyaWMgPSByZXF1aXJlKCdmYWJyaWMnKS5mYWJyaWM7XHJcbmltcG9ydCBVQSBmcm9tICcuL3VzZXJBZ2VudCc7XHJcblxyXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50JztcclxuXHJcbmNsYXNzIENhbnZhc0RyYXcgZXh0ZW5kcyBDb21wb25lbnQge1xyXG5cdHByaXZhdGUgd3JhcHBlckVsOiBIVE1MRWxlbWVudDtcclxuXHRwcml2YXRlIHdpZHRoOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBoZWlnaHQ6IG51bWJlcjtcclxuXHRwcml2YXRlIHN0YXRpYyBmYWJyaWM6IGZhYnJpYy5DYW52YXM7XHJcblx0cHJpdmF0ZSBjYW52YXNDb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIHpvb206IG51bWJlciA9IDE7XHJcblx0cHJpdmF0ZSBtb3VzZUZyb21UcmFjazogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9ID0geyB4OiAwLCB5OiAwIH07XHJcblx0cHJpdmF0ZSBtb3VzZVRvVHJhY2s6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSA9IHsgeDogMCwgeTogMCB9O1xyXG5cdHByaXZhdGUgbW91c2VUb1ByZXY6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSA9IHsgeDogMCwgeTogMCB9OyAvLyDlj5HpgIHml7bnmoTlnZDmoIdcclxuXHRwcml2YXRlIGlzRHJhd2luZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgbW92ZUNvdW50OiBudW1iZXIgPSAxO1xyXG5cdHByaXZhdGUgZHJhd2luZ09iamVjdDogZmFicmljLk9iamVjdCB8IG51bGwgPSBudWxsO1xyXG5cdHByaXZhdGUga2VlcERyYXdpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHRleHRib3g6IGZhYnJpYy5UZXh0Ym94IHwgbnVsbCA9IG51bGw7XHJcblx0cHJpdmF0ZSBkcmF3VHlwZTogc3RyaW5nID0gJ3Blbic7XHJcblx0cHJpdmF0ZSBkcmF3V2lkdGg6IG51bWJlciA9IDE7XHJcblx0cHJpdmF0ZSBjb2xvcjogc3RyaW5nID0gJyNFMzRGNTEnO1xyXG5cdHByaXZhdGUgY2hhY2hlQ2FudmFzOiBzdHJpbmcgPSAnJztcclxuXHRwcml2YXRlIGNvbG9yc2V0OiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSB0ZXh0U2l6ZTogc3RyaW5nID0gJzE4cHgnO1xyXG5cdHByaXZhdGUgZ2V0RHJhd01vZGU6ICgpID0+IHN0cmluZztcclxuXHRwcml2YXRlIG9uU2NyZWVuU3luY01lc3NhZ2U6IElPbk1lc3NhZ2VPdXQ7XHJcblx0cHJpdmF0ZSBzdGF0aWMgc3luYzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGNvbnN0cnVjdG9yKHByb3BzOiBDYW52YXNEcmF3T3B0aW9ucykge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdGlmICghZmFicmljKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignZmFicmljanMgaXMgdW5kZWZpbmVkLCBwYWxlYXNlOiBucG0gaW5zdGFsbCBmYWJyaWMnKTtcclxuXHRcdH1cclxuXHRcdGNvbnN0IHsgd3JhcHBlckVsLCB3aWR0aCwgaGVpZ2h0LCBzeW5jLCBnZXREcmF3TW9kZSwgb25TY3JlZW5TeW5jTWVzc2FnZSB9ID0gcHJvcHM7XHJcblx0XHR0aGlzLndyYXBwZXJFbCA9IHdyYXBwZXJFbDtcclxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0Q2FudmFzRHJhdy5zeW5jID0gc3luYztcclxuXHRcdHRoaXMuZ2V0RHJhd01vZGUgPSBnZXREcmF3TW9kZTtcclxuXHRcdHRoaXMub25TY3JlZW5TeW5jTWVzc2FnZSA9IG9uU2NyZWVuU3luY01lc3NhZ2U7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVuZGVyKCkge1xyXG5cdFx0dGhpcy53cmFwcGVyRWwuaW5uZXJIVE1MICs9IENvbXBvbmVudC5jYW52YXNXcmFwcGVyVmlldygnd2hpdGUtYm9hcmQtY2FudmFzJywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGluaXRDYW52YXMoKSB7XHJcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2hpdGUtYm9hcmQtY2FudmFzJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0XHRDYW52YXNEcmF3LmZhYnJpYyA9IG5ldyBmYWJyaWMuQ2FudmFzKCd3aGl0ZS1ib2FyZC1jYW52YXMnLCB7IGNvbnRhaW5lckNsYXNzOiAnd2hpdGUtYm9hcmQtY2FudmFzLWNvbnRhaWVyJyB9KTtcclxuXHRcdHRoaXMuY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpITtcclxuXHRcdHRoaXMuY2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XHJcblx0XHR0aGlzLmNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknO1xyXG5cdFx0Q2FudmFzRHJhdy5mYWJyaWMuZnJlZURyYXdpbmdCcnVzaC5jb2xvciA9IHRoaXMuY29sb3I7XHJcblx0XHRDYW52YXNEcmF3LmZhYnJpYy5pc0RyYXdpbmdNb2RlID0gdHJ1ZTtcclxuXHRcdHRoaXMubW91c2VEb3duKCk7XHJcblx0XHR0aGlzLm1vdXNlTW92ZSgpO1xyXG5cdFx0dGhpcy5tb3VzZVVwKCk7XHJcblx0XHR0aGlzLnNlbGVjdGlvbkV2ZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHRyYW5zZm9ybU1vdXNlKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiB4IC8gdGhpcy56b29tLFxyXG5cdFx0XHR5OiB5IC8gdGhpcy56b29tXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBmeHJlbW92ZUFsbCgpIHtcclxuXHRcdENhbnZhc0RyYXcuZmFicmljLmdldE9iamVjdHMoKS5tYXAob2JqID0+IHRoaXMuZnhyZW1vdmUob2JqKSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGZ4cmVtb3ZlKG9iamVjdDogZmFicmljLk9iamVjdCkge1xyXG5cdFx0Y29uc3QgY2FudmFzID0gQ2FudmFzRHJhdy5mYWJyaWM7XHJcblx0XHRmYWJyaWMudXRpbC5hbmltYXRlKHtcclxuXHRcdFx0c3RhcnRWYWx1ZTogb2JqZWN0Lm9wYWNpdHksXHJcblx0XHRcdGVuZFZhbHVlOiAwLFxyXG5cdFx0XHRkdXJhdGlvbjogMTAwMCxcclxuXHRcdFx0b25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZTogYW55KSB7XHJcblx0XHRcdFx0b2JqZWN0LnNldCgnb3BhY2l0eScsIHZhbHVlKTtcclxuXHRcdFx0XHRjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0Y2FudmFzLnJlbW92ZShvYmplY3QpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZHJhd2luZygpIHtcclxuXHRcdGlmICh0aGlzLmRyYXdpbmdPYmplY3QpIHtcclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMucmVtb3ZlKHRoaXMuZHJhd2luZ09iamVjdCk7XHJcblx0XHR9XHJcblx0XHRsZXQgY2FudmFzT2JqZWN0ID0gbnVsbDtcclxuXHRcdGxldCBsZWZ0ID0gMDtcclxuXHRcdGxldCB0b3AgPSAwO1xyXG5cdFx0bGV0IHJhZGl1cyA9IDA7XHJcblx0XHRsZXQgcGF0aCA9ICcnO1xyXG5cclxuXHRcdHN3aXRjaCAodGhpcy5kcmF3VHlwZSkge1xyXG5cdFx0XHRjYXNlICdsaW5lJzogLy/nm7Tnur9cclxuXHRcdFx0XHRDYW52YXNEcmF3LmZhYnJpYy5pc0RyYXdpbmdNb2RlID0gZmFsc2U7XHJcblx0XHRcdFx0Y2FudmFzT2JqZWN0ID0gbmV3IGZhYnJpYy5MaW5lKFt0aGlzLm1vdXNlRnJvbVRyYWNrLngsIHRoaXMubW91c2VGcm9tVHJhY2sueSwgdGhpcy5tb3VzZVRvVHJhY2sueCwgdGhpcy5tb3VzZVRvVHJhY2sueV0sIHtcclxuXHRcdFx0XHRcdHN0cm9rZTogdGhpcy5jb2xvcixcclxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoOiB0aGlzLmRyYXdXaWR0aFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdjaXJjbGUnOiAvL+ato+WchlxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdChsZWZ0ID0gdGhpcy5tb3VzZUZyb21UcmFjay54KSwgKHRvcCA9IHRoaXMubW91c2VGcm9tVHJhY2sueSk7XHJcblx0XHRcdFx0XHRyYWRpdXMgPSBNYXRoLnNxcnQoKHRoaXMubW91c2VUb1RyYWNrLnggLSBsZWZ0KSAqICh0aGlzLm1vdXNlVG9UcmFjay54IC0gbGVmdCkgKyAodGhpcy5tb3VzZVRvVHJhY2sueSAtIHRvcCkgKiAodGhpcy5tb3VzZVRvVHJhY2sueSAtIHRvcCkpIC8gMjtcclxuXHRcdFx0XHRcdGNhbnZhc09iamVjdCA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcclxuXHRcdFx0XHRcdFx0bGVmdDogbGVmdCxcclxuXHRcdFx0XHRcdFx0dG9wOiB0b3AsXHJcblx0XHRcdFx0XHRcdHN0cm9rZTogdGhpcy5jb2xvcixcclxuXHRcdFx0XHRcdFx0ZmlsbDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknLFxyXG5cdFx0XHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0XHRcdFx0c3Ryb2tlV2lkdGg6IHRoaXMuZHJhd1dpZHRoXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3JlY3RhbmdsZSc6IC8v6ZW/5pa55b2iXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0KGxlZnQgPSB0aGlzLm1vdXNlRnJvbVRyYWNrLngpLCAodG9wID0gdGhpcy5tb3VzZUZyb21UcmFjay55KTtcclxuXHRcdFx0XHRcdHBhdGggPVxyXG5cdFx0XHRcdFx0XHQnTSAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay54ICtcclxuXHRcdFx0XHRcdFx0JyAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay55ICtcclxuXHRcdFx0XHRcdFx0JyBMICcgK1xyXG5cdFx0XHRcdFx0XHR0aGlzLm1vdXNlVG9UcmFjay54ICtcclxuXHRcdFx0XHRcdFx0JyAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay55ICtcclxuXHRcdFx0XHRcdFx0JyBMICcgK1xyXG5cdFx0XHRcdFx0XHR0aGlzLm1vdXNlVG9UcmFjay54ICtcclxuXHRcdFx0XHRcdFx0JyAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZVRvVHJhY2sueSArXHJcblx0XHRcdFx0XHRcdCcgTCAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay54ICtcclxuXHRcdFx0XHRcdFx0JyAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZVRvVHJhY2sueSArXHJcblx0XHRcdFx0XHRcdCcgTCAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay54ICtcclxuXHRcdFx0XHRcdFx0JyAnICtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjay55ICtcclxuXHRcdFx0XHRcdFx0JyB6JztcclxuXHRcdFx0XHRcdGNhbnZhc09iamVjdCA9IG5ldyBmYWJyaWMuUGF0aChwYXRoLCB7XHJcblx0XHRcdFx0XHRcdGxlZnQ6IGxlZnQsXHJcblx0XHRcdFx0XHRcdHRvcDogdG9wLFxyXG5cdFx0XHRcdFx0XHRzdHJva2U6IHRoaXMuY29sb3IsXHJcblx0XHRcdFx0XHRcdHN0cm9rZVdpZHRoOiB0aGlzLmRyYXdXaWR0aCxcclxuXHRcdFx0XHRcdFx0ZmlsbDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMCknXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly/kuZ/lj6/ku6Xkvb/nlKhmYWJyaWMuUmVjdFxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICd0ZXh0JzpcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0Ym94ID0gbmV3IGZhYnJpYy5UZXh0Ym94KCcnLCB7XHJcblx0XHRcdFx0XHRcdGxlZnQ6IHRoaXMubW91c2VGcm9tVHJhY2sueCxcclxuXHRcdFx0XHRcdFx0dG9wOiB0aGlzLm1vdXNlRnJvbVRyYWNrLnksXHJcblx0XHRcdFx0XHRcdHdpZHRoOiAxNTAsXHJcblx0XHRcdFx0XHRcdGZvbnRTaXplOiAxOCxcclxuXHRcdFx0XHRcdFx0Ym9yZGVyQ29sb3I6ICcjMmMyYzJjJyxcclxuXHRcdFx0XHRcdFx0ZmlsbDogdGhpcy5jb2xvcixcclxuXHRcdFx0XHRcdFx0aGFzQ29udHJvbHM6IGZhbHNlXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdHRoaXMudGV4dGJveCA9IHRleHRib3g7XHJcblx0XHRcdFx0XHRpZiAodGhpcy50ZXh0Ym94KSB7XHJcblx0XHRcdFx0XHRcdENhbnZhc0RyYXcuZmFicmljLmFkZCh0aGlzLnRleHRib3gpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRleHRib3guZW50ZXJFZGl0aW5nKCk7XHJcblx0XHRcdFx0XHRcdHRoaXMudGV4dGJveC5oaWRkZW5UZXh0YXJlYSEuZm9jdXMoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ3JlbW92ZSc6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRpZiAoY2FudmFzT2JqZWN0KSB7XHJcblx0XHRcdENhbnZhc0RyYXcuZmFicmljLmFkZChjYW52YXNPYmplY3QpO1xyXG5cdFx0XHR0aGlzLmRyYXdpbmdPYmplY3QgPSBjYW52YXNPYmplY3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2VuZE1lc3NhZ2UoKSB7XHJcblx0XHQvLyDlj6rmnInlnZDluK3nq6/miY3og73lj5HpgIHmlbDmja5cclxuXHRcdGlmICghQ2FudmFzRHJhdy5zeW5jKSByZXR1cm47XHJcblx0XHRjb25zdCBjb2RlID0gdGhpcy5jaGFjaGVDYW52YXM7XHJcblx0XHR0aGlzLm9uU2NyZWVuU3luY01lc3NhZ2UoeyBhY3Rpb246ICdkcmF3JywgdmFsdWU6IGNvZGUsIHR5cGU6ICd3aGl0ZWJvYXJkJyB9LCAnd2hpdGVib2FyZCcpO1xyXG5cdH1cclxuXHRwdWJsaWMgc2VuZE1lc3NhZ2U0RnJlZURyYXcodHlwZTogJ21vdXNlZG93bicgfCAnbW91c2V1cCcgfCAnbW91c2Vtb3ZlJywgeDogbnVtYmVyIHwgc3RyaW5nLCB5OiBudW1iZXIgfCBzdHJpbmcpIHtcclxuXHRcdC8vIOWPquacieWdkOW4reerr+aJjeiDveWPkemAgeaVsOaNrlxyXG5cdFx0aWYgKCFDYW52YXNEcmF3LnN5bmMpIHJldHVybjtcclxuXHRcdGNvbnN0IGNvZGUgPSB7IHR5cGU6IHR5cGUsIHg6IHgsIHk6IHkgfTtcclxuXHRcdHRoaXMub25TY3JlZW5TeW5jTWVzc2FnZSh7IGFjdGlvbjogJ2ZyZWVEcmF3JywgdmFsdWU6IGNvZGUsIHR5cGU6ICd3aGl0ZWJvYXJkJyB9LCAnd2hpdGVib2FyZCcpO1xyXG5cdH1cclxuXHRwdWJsaWMgb25GcmVlRHJhdyh2YWx1ZTogeyB0eXBlOiAnbW91c2Vkb3duJyB8ICdtb3VzZXVwJyB8ICdtb3VzZW1vdmUnOyB4OiBudW1iZXIgfCBzdHJpbmc7IHk6IG51bWJlciB8IHN0cmluZyB9KSB7XHJcblx0XHRpZiAoIXZhbHVlIHx8ICF2YWx1ZS50eXBlKSByZXR1cm47XHJcblx0XHRjb25zdCBldmVudCA9IG5ldyBNb3VzZUV2ZW50KHZhbHVlLnR5cGUsIHtcclxuXHRcdFx0Y2xpZW50WDogTnVtYmVyKHZhbHVlLngpLFxyXG5cdFx0XHRjbGllbnRZOiBOdW1iZXIodmFsdWUueSksXHJcblx0XHRcdHR5cGU6IHZhbHVlLnR5cGUsXHJcblx0XHRcdHZpZXc6IHdpbmRvdyxcclxuXHRcdFx0YnViYmxlczogdHJ1ZSxcclxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgcG9pbnRlciA9IHsgeDogdmFsdWUueCwgeTogdmFsdWUueSB9O1xyXG5cdFx0Ly8gdGhpcy53aGl0ZWJvYXJkQ2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdFx0aWYgKHZhbHVlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdENhbnZhc0RyYXcuZmFicmljLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlciwge1xyXG5cdFx0XHRcdGU6IGV2ZW50LFxyXG5cdFx0XHRcdHBvaW50ZXI6IHBvaW50ZXJcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdtb3VzZXVwJykge1xyXG5cdFx0XHRldmVudC5pc1ByaW1hcnkgPSB0cnVlO1xyXG5cdFx0XHRDYW52YXNEcmF3LmZhYnJpYy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VVcCh7XHJcblx0XHRcdFx0ZTogZXZlbnQsXHJcblx0XHRcdFx0cG9pbnRlcjogcG9pbnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyLCB7XHJcblx0XHRcdFx0ZTogZXZlbnQsXHJcblx0XHRcdFx0cG9pbnRlcjogcG9pbnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1cGRhdGVDYW52YXMoKSB7XHJcblx0XHR0aGlzLmNoYWNoZUNhbnZhcyA9IEpTT04uc3RyaW5naWZ5KENhbnZhc0RyYXcuZmFicmljKTtcclxuXHRcdHRoaXMuc2VuZE1lc3NhZ2UoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzaG93Q2FjaGUoZGF0YTogc3RyaW5nKSB7XHJcblx0XHRjb25zdCBqc29uRGF0YTogZmFicmljLk9iamVjdCA9IEpTT04ucGFyc2UoZGF0YSB8fCB0aGlzLmNoYWNoZUNhbnZhcyk7XHJcblx0XHRDYW52YXNEcmF3LmZhYnJpYy5sb2FkRnJvbUpTT04oanNvbkRhdGEsICgpID0+IHtcclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMucmVuZGVyQWxsKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRoaXMua2VlcERyYXdpbmcpIHtcclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5meHJlbW92ZUFsbCgpO1xyXG5cdFx0XHR9LCAxMDApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGNsZWFyQ2FudmFzKCkge1xyXG5cdFx0Q2FudmFzRHJhdy5mYWJyaWMuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXREcmF3TW9kZShtb2RlOiBzdHJpbmcpIHtcclxuXHRcdHRoaXMuZHJhd1R5cGUgPSBtb2RlO1xyXG5cdFx0Q2FudmFzRHJhdy5mYWJyaWMuaXNEcmF3aW5nTW9kZSA9IGZhbHNlO1xyXG5cdFx0aWYgKHRoaXMudGV4dGJveCkge1xyXG5cdFx0XHQvL+mAgOWHuuaWh+acrOe8lui+keeKtuaAgVxyXG5cdFx0XHR0aGlzLnRleHRib3guZXhpdEVkaXRpbmcoKTtcclxuXHRcdFx0dGhpcy50ZXh0Ym94ID0gbnVsbDtcclxuXHRcdFx0dGhpcy51cGRhdGVDYW52YXMoKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmRyYXdUeXBlID09ICdwZW4nKSB7XHJcblx0XHRcdHRoaXMuY29sb3JzZXQgPSBmYWxzZTtcclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMuaXNEcmF3aW5nTW9kZSA9IHRydWU7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuZHJhd1R5cGUgPT0gJ3JlbW92ZScpIHtcclxuXHRcdFx0dGhpcy5jb2xvcnNldCA9IGZhbHNlO1xyXG5cdFx0XHRDYW52YXNEcmF3LmZhYnJpYy5zZWxlY3Rpb24gPSB0cnVlO1xyXG5cdFx0XHRDYW52YXNEcmF3LmZhYnJpYy5za2lwVGFyZ2V0RmluZCA9IGZhbHNlO1xyXG5cdFx0XHRDYW52YXNEcmF3LmZhYnJpYy5zZWxlY3RhYmxlID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5kcmF3VHlwZSA9PSAndGV4dCcpIHtcclxuXHRcdFx0dGhpcy5jb2xvcnNldCA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbG9yc2V0ID0gZmFsc2U7XHJcblx0XHRcdENhbnZhc0RyYXcuZmFicmljLnNraXBUYXJnZXRGaW5kID0gdHJ1ZTsgLy/nlLvmnb/lhYPntKDkuI3og73ooqvpgInkuK1cclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMuc2VsZWN0aW9uID0gZmFsc2U7IC8v55S75p2/5LiN5pi+56S66YCJ5LitXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG1vdXNlVXAoKSB7XHJcblx0XHRDYW52YXNEcmF3LmZhYnJpYy5vbignbW91c2U6dXAnLCBvcHRpb25zID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2cob3B0aW9ucyk7XHJcblxyXG5cdFx0XHRjb25zdCBvZmZzZXRYID0gVUEuaW5JT1MgfHwgVUEuaW5BbmRyb2lkIHx8IFVBLmluTW9iaWxlIHx8IFVBLmluaVBhZCA/IG9wdGlvbnMucG9pbnRlciEueCA6IG9wdGlvbnMuZS5vZmZzZXRYO1xyXG5cdFx0XHRjb25zdCBvZmZzZXRZID0gVUEuaW5JT1MgfHwgVUEuaW5BbmRyb2lkIHx8IFVBLmluTW9iaWxlIHx8IFVBLmluaVBhZCA/IG9wdGlvbnMucG9pbnRlciEueSA6IG9wdGlvbnMuZS5vZmZzZXRZO1xyXG5cdFx0XHRpZiAodGhpcy5kcmF3VHlwZSAhPT0gJ3RleHQnKSB7XHJcblx0XHRcdFx0dGhpcy5tb3VzZVRvVHJhY2sgPSB0aGlzLnRyYW5zZm9ybU1vdXNlKG9mZnNldFgsIG9mZnNldFkpO1xyXG5cdFx0XHRcdHRoaXMuZHJhd2luZ09iamVjdCA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5tb3ZlQ291bnQgPSAxO1xyXG5cdFx0XHRcdHRoaXMuaXNEcmF3aW5nID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVDYW52YXMoKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLmtlZXBEcmF3aW5nICYmICF0aGlzLnRleHRib3gpIHtcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmZ4cmVtb3ZlQWxsKCk7XHJcblx0XHRcdFx0XHR9LCAxMDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoQ2FudmFzRHJhdy5mYWJyaWMuaXNEcmF3aW5nTW9kZSkge1xyXG5cdFx0XHRcdFx0Ly8gc2VuZCBmcmVlIGRyYXcgbWVzc2FnZVxyXG5cdFx0XHRcdFx0dGhpcy5zZW5kTWVzc2FnZTRGcmVlRHJhdygnbW91c2V1cCcsIHRoaXMubW91c2VUb1RyYWNrLngsIHRoaXMubW91c2VUb1RyYWNrLnkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG1vdXNlTW92ZSgpIHtcclxuXHRcdENhbnZhc0RyYXcuZmFicmljLm9uKCdtb3VzZTptb3ZlJywgb3B0aW9ucyA9PiB7XHJcblx0XHRcdGlmICh0aGlzLm1vdmVDb3VudCAlIDIgJiYgIXRoaXMuaXNEcmF3aW5nKSB7XHJcblx0XHRcdFx0Ly/lh4/lsJHnu5jliLbpopHnjodcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5tb3ZlQ291bnQrKztcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0WCA9IFVBLmluSU9TIHx8IFVBLmluQW5kcm9pZCB8fCBVQS5pbk1vYmlsZSB8fCBVQS5pbmlQYWQgPyBvcHRpb25zLnBvaW50ZXIhLnggOiBvcHRpb25zLmUub2Zmc2V0WDtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0WSA9IFVBLmluSU9TIHx8IFVBLmluQW5kcm9pZCB8fCBVQS5pbk1vYmlsZSB8fCBVQS5pbmlQYWQgPyBvcHRpb25zLnBvaW50ZXIhLnkgOiBvcHRpb25zLmUub2Zmc2V0WTtcclxuXHRcdFx0dGhpcy5tb3VzZVRvVHJhY2sgPSB0aGlzLnRyYW5zZm9ybU1vdXNlKG9mZnNldFgsIG9mZnNldFkpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyh0aGlzLm1vdXNlVG9UcmFjaywgb2Zmc2V0WCwgb2Zmc2V0WSk7XHJcblxyXG5cdFx0XHQvLyDlrp7ml7blj5HpgIHmlbDmja5cclxuXHRcdFx0dGhpcy5tb3VzZVRvUHJldiA9IHRoaXMudHJhbnNmb3JtTW91c2Uob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcblx0XHRcdGlmIChDYW52YXNEcmF3LmZhYnJpYy5pc0RyYXdpbmdNb2RlKSB7XHJcblx0XHRcdFx0dGhpcy5zZW5kTWVzc2FnZTRGcmVlRHJhdygnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZVRvVHJhY2sueCwgdGhpcy5tb3VzZVRvVHJhY2sueSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kcmF3aW5nKCk7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVDYW52YXMoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG1vdXNlRG93bigpIHtcclxuXHRcdENhbnZhc0RyYXcuZmFicmljLm9uKCdtb3VzZTpkb3duJywgb3B0aW9ucyA9PiB7XHJcblx0XHRcdGNvbnN0IG9mZnNldFggPSBVQS5pbklPUyB8fCBVQS5pbkFuZHJvaWQgfHwgVUEuaW5Nb2JpbGUgfHwgVUEuaW5pUGFkID8gb3B0aW9ucy5wb2ludGVyIS54IDogb3B0aW9ucy5lLm9mZnNldFg7XHJcblx0XHRcdGNvbnN0IG9mZnNldFkgPSBVQS5pbklPUyB8fCBVQS5pbkFuZHJvaWQgfHwgVUEuaW5Nb2JpbGUgfHwgVUEuaW5pUGFkID8gb3B0aW9ucy5wb2ludGVyIS55IDogb3B0aW9ucy5lLm9mZnNldFk7XHJcblx0XHRcdC8vIHRleHTnirbmgIHkuIvvvIzlj5HpgIF0ZXh05raI5oGvXHJcblx0XHRcdGlmICh0aGlzLmRyYXdUeXBlID09PSAndGV4dCcpIHtcclxuXHRcdFx0XHQvLyDpvKDmoIfmjInkuIvml7bvvIzlhYjlj5HpgIHlt7LmnInnmoTmlofmnKzvvIzlho3mt7vliqDmlrDnmoTovpPlhaXmoYZcclxuXHRcdFx0XHR0aGlzLmNvbG9yc2V0ID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5tb3VzZUZyb21UcmFjayA9IHRoaXMudHJhbnNmb3JtTW91c2Uob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcblx0XHRcdFx0Ly8gc2VsZi5kcmF3aW5nKCk7XHJcblx0XHRcdFx0aWYgKHRoaXMudGV4dGJveCAmJiB0aGlzLnRleHRib3gudGV4dCAmJiB0aGlzLnRleHRib3gudGV4dC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ3NlbGYudGV4dGJveCA6ICcsIHRoaXMudGV4dGJveC50ZXh0LCB0aGlzLnRleHRib3gpO1xyXG5cdFx0XHRcdFx0Ly/pgIDlh7rmlofmnKznvJbovpHnirbmgIFcclxuXHRcdFx0XHRcdHRoaXMudGV4dGJveC5leGl0RWRpdGluZygpO1xyXG5cdFx0XHRcdFx0Ly8gc2VsZi50ZXh0Ym94ID0gbnVsbDtcclxuXHRcdFx0XHRcdHRoaXMudXBkYXRlQ2FudmFzKCk7XHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0dGhpcy5meHJlbW92ZUFsbCgpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRyYXdpbmcoKTtcclxuXHRcdFx0XHRcdH0sIDEwMCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuZHJhd2luZygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm1vdXNlRnJvbVRyYWNrID0gdGhpcy50cmFuc2Zvcm1Nb3VzZShvZmZzZXRYLCBvZmZzZXRZKTtcclxuXHRcdFx0XHR0aGlzLmlzRHJhd2luZyA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5tb3VzZVRvUHJldiA9IHRoaXMudHJhbnNmb3JtTW91c2Uob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcblx0XHRcdFx0aWYgKENhbnZhc0RyYXcuZmFicmljLmlzRHJhd2luZ01vZGUpIHtcclxuXHRcdFx0XHRcdC8vIHNlbmQgZnJlZSBkcmF3IG1lc3NhZ2VcclxuXHRcdFx0XHRcdHRoaXMuc2VuZE1lc3NhZ2U0RnJlZURyYXcoJ21vdXNlZG93bicsIHRoaXMubW91c2VUb1ByZXYueCwgdGhpcy5tb3VzZVRvUHJldi55KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzZWxlY3Rpb25FdmVudCgpIHtcclxuXHRcdENhbnZhc0RyYXcuZmFicmljLm9uKCdzZWxlY3Rpb246Y3JlYXRlZCcsIChlOiBmYWJyaWMuSUV2ZW50PEV2ZW50PikgPT4ge1xyXG5cdFx0XHRpZiAodGhpcy50ZXh0Ym94KSB7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGUuc2VsZWN0ZWQgJiYgZS5zZWxlY3RlZC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHQvL+WkmumAieWIoOmZpFxyXG5cdFx0XHRcdFx0Y29uc3QgZXRDb3VudCA9IGUuc2VsZWN0ZWQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgZXRpbmRleCA9IDA7IGV0aW5kZXggPCBldENvdW50OyBldGluZGV4KyspIHtcclxuXHRcdFx0XHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMucmVtb3ZlKGUuc2VsZWN0ZWRbZXRpbmRleF0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvL+WNlemAieWIoOmZpFxyXG5cdFx0XHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMucmVtb3ZlKGUuc2VsZWN0ZWQgYXMgYW55KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdENhbnZhc0RyYXcuZmFicmljLmRpc2NhcmRBY3RpdmVPYmplY3QoKTsgLy8g5riF6Zmk6YCJ5LitXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRNZXNzYWdlSW4obWVzc2FnZTogYW55KSB7XHJcblx0XHQvLyDlj6rmnInorr/lrqLnq6/miY3og73mjqXmlLbmlbDmja5cclxuXHRcdGlmIChDYW52YXNEcmF3LnN5bmMpIHJldHVybjtcclxuXHRcdC8vIOebuOWQjOa2iOaBr+S4jeWkhOeQhlxyXG5cdFx0Ly8g5raI5oGvdHlwZeS4jeetieS6jndoaXRlYm9hcmTvvIzkuI3lpITnkIZcclxuXHRcdGlmIChtZXNzYWdlLnR5cGUgIT09ICd3aGl0ZWJvYXJkJykgcmV0dXJuO1xyXG5cclxuXHRcdGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ2RyYXcnKSB7XHJcblx0XHRcdHRoaXMuc2hvd0NhY2hlKG1lc3NhZ2UudmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3NldENvbG9yJykge1xyXG5cdFx0XHR0aGlzLmNvbG9yID0gbWVzc2FnZS52YWx1ZTtcclxuXHRcdFx0Q2FudmFzRHJhdy5mYWJyaWMuZnJlZURyYXdpbmdCcnVzaC5jb2xvciA9IHRoaXMuY29sb3I7XHJcblx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSAnc2V0VGV4dFNpemUnKSB7XHJcblx0XHRcdHRoaXMudGV4dFNpemUgPSBtZXNzYWdlLnZhbHVlO1xyXG5cdFx0fSBlbHNlIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ2ZyZWVEcmF3Jykge1xyXG5cdFx0XHR0aGlzLm9uRnJlZURyYXcobWVzc2FnZS52YWx1ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCd1bmhhbmRsZWQgd2hpdGVib2FyZCBtZXNzZ2FlIGluIDogJywgbWVzc2FnZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYW52YXNEcmF3O1xyXG4iLCJpbXBvcnQgeyBUb29sTW9kZSwgVG9vbHNQcm9wcywgTWFya1Rvb2xPcHRpb25zLCBDYW52YXNEcmF3T3B0aW9ucyB9IGZyb20gJy4vdHlwaW5nJztcclxuaW1wb3J0ICcuL3N0eWxlcy9pbmRleC5zY3NzJztcclxuaW1wb3J0IE1hcmtUb29sIGZyb20gJy4vTWFya1Rvb2wnO1xyXG5pbXBvcnQgQ2FudmFzRHJhdyBmcm9tICcuL0NhbnZhc0RyYXcnO1xyXG5pbXBvcnQgeyBJT25NZXNzYWdlLCBJT25NZXNzYWdlT3V0LCBJU2VuZEN1c3RvbWVyTWVzYWdnZSB9IGZyb20gJ3NyYy9aY29TY3JlZW5TeW5jL3R5cGluZyc7XHJcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnQnO1xyXG5cclxuY2xhc3MgV2hpdGVCb2FyZCBleHRlbmRzIENvbXBvbmVudCB7XHJcblx0cHJpdmF0ZSBlbDogSFRNTEVsZW1lbnQ7XHJcblx0cHJpdmF0ZSB0b29sczogVG9vbHNQcm9wc1tdO1xyXG5cdHByaXZhdGUgbWFya1Rvb2w6IE1hcmtUb29sIHwgbnVsbCA9IG51bGw7XHJcblx0cHJpdmF0ZSBzdGF0aWMgY2FudmFzRHJhdzogQ2FudmFzRHJhdyB8IG51bGwgPSBudWxsO1xyXG5cdHByaXZhdGUgd2hpdGVCb2FyZFdyYXBwZXI6IEhUTUxFbGVtZW50O1xyXG5cdHByaXZhdGUgc3RhdGljIGRyYXdNb2RlOiBzdHJpbmcgPSAnJztcclxuXHRwcml2YXRlIHN0YXRpYyBvblNjcmVlblN5bmNNZXNzYWdlOiBJT25NZXNzYWdlT3V0IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG5cdHByaXZhdGUgc3RhdGljIHNlbmRDdXN0b21NZXNzYWdlOiBJU2VuZEN1c3RvbWVyTWVzYWdnZSB8IHVuZGVmaW5lZDtcclxuXHRwcml2YXRlIHdpZHRoOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBoZWlnaHQ6IG51bWJlcjtcclxuXHRwcml2YXRlIGlzQ3VzdG9tZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHN0YXRpYyBzeW5jOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNTdGFydGVkU3luYzogYm9vbGVhbjtcclxuXHRjb25zdHJ1Y3RvcihcclxuXHRcdGVsOiBIVE1MRWxlbWVudCxcclxuXHRcdHRvb2xzOiBUb29sc1Byb3BzW10sXHJcblx0XHR3aWR0aDogbnVtYmVyLFxyXG5cdFx0aGVpZ2h0OiBudW1iZXIsXHJcblx0XHRpc0N1c3RvbWVyOiBib29sZWFuLFxyXG5cdFx0c3luYzogYm9vbGVhbixcclxuXHRcdGlzU3RhcnRlZFN5bmM6IGJvb2xlYW4sXHJcblx0XHRvblNjcmVlblN5bmNNZXNzYWdlOiBJT25NZXNzYWdlT3V0LFxyXG5cdFx0c2VuZEN1c3RvbU1lc3NhZ2U6IElTZW5kQ3VzdG9tZXJNZXNhZ2dlXHJcblx0KSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5lbCA9IGVsO1xyXG5cdFx0dGhpcy50b29scyA9IHRvb2xzO1xyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0aGlzLmlzQ3VzdG9tZXIgPSBpc0N1c3RvbWVyO1xyXG5cdFx0V2hpdGVCb2FyZC5vblNjcmVlblN5bmNNZXNzYWdlID0gb25TY3JlZW5TeW5jTWVzc2FnZTtcclxuXHRcdFdoaXRlQm9hcmQuaXNTdGFydGVkU3luYyA9IGlzU3RhcnRlZFN5bmM7XHJcblx0XHRXaGl0ZUJvYXJkLnNlbmRDdXN0b21NZXNzYWdlID0gc2VuZEN1c3RvbU1lc3NhZ2U7XHJcblx0XHRXaGl0ZUJvYXJkLnN5bmMgPSBzeW5jO1xyXG5cdFx0dGhpcy53aGl0ZUJvYXJkV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0dGhpcy53aGl0ZUJvYXJkV3JhcHBlci5jbGFzc05hbWUgPSAnd2hpdGUtYm9hcmQtYm94JztcclxuXHR9XHJcblxyXG5cdC8qKiDliJ3lp4vljJYgKi9cclxuXHRwdWJsaWMgaW5pdCgpIHtcclxuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZXRzKCk7XHJcblx0XHR0aGlzLnJlbmRlcigpO1xyXG5cdFx0dGhpcy5iaW5kRXZlbnQoKTtcclxuXHR9XHJcblxyXG5cdC8qKiDmuLLmn5PpobXpnaIgKi9cclxuXHRwcml2YXRlIHJlbmRlcigpIHtcclxuXHRcdFdoaXRlQm9hcmQuY2FudmFzRHJhdz8ucmVuZGVyKCk7XHJcblx0XHR0aGlzLm1hcmtUb29sPy5yZW5kZXIoKTtcclxuXHRcdHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy53aGl0ZUJvYXJkV3JhcHBlcik7XHJcblx0XHRXaGl0ZUJvYXJkLmNhbnZhc0RyYXc/LmluaXRDYW52YXMoKTtcclxuXHR9XHJcblxyXG5cdC8qKiDnu5Hlrprkuovku7YgKi9cclxuXHRwcml2YXRlIGJpbmRFdmVudCgpIHtcclxuXHRcdHRoaXMubWFya1Rvb2w/LmJpbmRFdmVudCgpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldERyYXdNb2RlKG1vZGU6IHN0cmluZykge1xyXG5cdFx0V2hpdGVCb2FyZC5kcmF3TW9kZSA9IG1vZGU7XHJcblx0XHRXaGl0ZUJvYXJkLmNhbnZhc0RyYXc/LnNldERyYXdNb2RlKG1vZGUpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldERyYXdNb2RlKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gV2hpdGVCb2FyZC5kcmF3TW9kZTtcclxuXHR9XHJcblxyXG5cdC8vIOW6p+W4reerr+WSjOiuv+Wuouerr+W9vOatpOWPkemAgea2iOaBr1xyXG5cdHB1YmxpYyBvbk1lc3NhZ2VPdXRJbm5lcihtZXNzYWdlOiBJT25NZXNzYWdlLCB0eXBlOiBzdHJpbmcsIHJvbGUgPSAnYWxsJykge1xyXG5cdFx0aWYgKHRoaXMuaXNDdXN0b21lciAmJiAhV2hpdGVCb2FyZC5pc1N0YXJ0ZWRTeW5jICYmIG1lc3NhZ2UgJiYgbWVzc2FnZS5hY3Rpb24gIT09ICdzaXplJyAmJiBtZXNzYWdlLmFjdGlvbiAhPT0gJ2VuZFNjcmVlblN5bmMnKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ29uTWVzc2FnZU91dElubmVyIDogJywgV2hpdGVCb2FyZC5pc1N0YXJ0ZWRTeW5jLCBtZXNzYWdlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKFdoaXRlQm9hcmQub25TY3JlZW5TeW5jTWVzc2FnZSkge1xyXG5cdFx0XHRXaGl0ZUJvYXJkLm9uU2NyZWVuU3luY01lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR9IGVsc2UgaWYgKFdoaXRlQm9hcmQuc2VuZEN1c3RvbU1lc3NhZ2UpIHtcclxuXHRcdFx0Y29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHsgdHlwZTogdHlwZSB9LCBtZXNzYWdlKTtcclxuXHRcdFx0V2hpdGVCb2FyZC5zZW5kQ3VzdG9tTWVzc2FnZShcclxuXHRcdFx0XHRkYXRhLFxyXG5cdFx0XHRcdHJvbGUsXHJcblx0XHRcdFx0c3VjY2VzcyA9PiB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygn5Y+R6YCB5raI5oGv5oiQ5Yqf77yBJyArIGRhdGEsIHN1Y2Nlc3MpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0ZXJyb3IgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ+WPkemAgea2iOaBr+Wksei0pe+8gScgKyBkYXRhLCBlcnJvcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIOWIm+W7uue7hOS7tiAqL1xyXG5cdHByaXZhdGUgY3JlYXRlQ29tcG9uZXRzKCkge1xyXG5cdFx0dGhpcy5tYXJrVG9vbCA9IG5ldyBNYXJrVG9vbCg8TWFya1Rvb2xPcHRpb25zPntcclxuXHRcdFx0d3JhcHBlckVsOiB0aGlzLndoaXRlQm9hcmRXcmFwcGVyLFxyXG5cdFx0XHR0b29sczogdGhpcy50b29scyxcclxuXHRcdFx0d2lkdGg6IDI0LFxyXG5cdFx0XHRoZWlnaHQ6IDI0LFxyXG5cdFx0XHRzeW5jOiBXaGl0ZUJvYXJkLnN5bmMsXHJcblx0XHRcdHNldERyYXdNb2RlOiB0aGlzLnNldERyYXdNb2RlXHJcblx0XHR9KTtcclxuXHRcdFdoaXRlQm9hcmQuY2FudmFzRHJhdyA9IG5ldyBDYW52YXNEcmF3KDxDYW52YXNEcmF3T3B0aW9ucz57XHJcblx0XHRcdHdyYXBwZXJFbDogdGhpcy53aGl0ZUJvYXJkV3JhcHBlcixcclxuXHRcdFx0d2lkdGg6IHRoaXMud2lkdGgsXHJcblx0XHRcdGhlaWdodDogdGhpcy5oZWlnaHQsXHJcblx0XHRcdHN5bmM6IFdoaXRlQm9hcmQuc3luYyxcclxuXHRcdFx0Z2V0RHJhd01vZGU6IHRoaXMuZ2V0RHJhd01vZGUsXHJcblx0XHRcdG9uU2NyZWVuU3luY01lc3NhZ2U6IFdoaXRlQm9hcmQub25TY3JlZW5TeW5jTWVzc2FnZVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0VG9vbEhpZGUoc3RhdHVzOiBib29sZWFuKSB7XHJcblx0XHRjb25zdCB0b29sID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rvb2xzLWxpc3Qtd3JhcHBlcicpO1xyXG5cdFx0aWYgKHRvb2wpIHtcclxuXHRcdFx0dG9vbC5zdHlsZS5kaXNwbGF5ID0gYCR7c3RhdHVzID8gJ25vbmUnIDogJ2Jsb2NrJ31gO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IHsgVG9vbE1vZGUgfTtcclxuXHJcbmV4cG9ydCB0eXBlIHsgVG9vbHNQcm9wcyB9O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2hpdGVCb2FyZDtcclxuIiwiaW1wb3J0IHsgc2NyZWVuU3luY1ZpZXdPcHRpb25zIH0gZnJvbSAnLi90eXBpbmcnO1xyXG5cclxuYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcclxuXHRwcm90ZWN0ZWQgc3RhdGljIGlGcmFtZVJlY29yZGVyVmlldyh1cmw6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIGBcclxuICAgICAgPGRpdiBjbGFzcz1cImlmcmFtZV93cmFwZXJfY29udGFpbmVyIHJyLWlnbm9yZVwiIGlkPVwiaWZyYW1lX3dyYXBlcl9jb250YWluZXJcIj5cclxuICAgICAgICA8aWZyYW1lIGlkPVwic2NyZWVuX3N5bmNfaWZyYW1lXCIgY2xhc3M9XCJzY3JlZW5fc3luY19pZnJhbWVcIiB0aXRsZT1cInNjcmVlbiBzeW5jXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIGZyYW1lQm9yZGVyPVwiMFwiIHNjcm9sbGluZz1cInllc1wiIG1hcmdpbkhlaWdodD1cIjBcIiBtYXJnaW5XaWR0aD1cIjBcIiBzcmM9XCIke3VybH1cIiBhbGxvdz1cImF1dG9wbGF5OyBtaWNyb3Bob25lOyBjYW1lcmFcIj48L2lmcmFtZT5cclxuICAgICAgPC9kaXY+XHJcbiAgICBgO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBpRnJhbWVQbGF5ZXJWaWV3KHRvdWNoSW1hZ2U6IHN0cmluZywgc3R5bGVkOiBhbnkpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGBcclxuICAgICAgPGRpdiBjbGFzcz1cImlmcmFtZV93cmFwZXJfY29udGFpbmVyIHJyLWlnbm9yZVwiIGlkPVwiaWZyYW1lX3dyYXBlcl9jb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJ0b3VjaF9pbWFnZVwiIHNyYz1cIiR7dG91Y2hJbWFnZX1cIiBzdHlsZT1cIiR7c3R5bGVkfVwiIC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICAgIGA7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc3RhdGljIGN1c3RvbWVyU3luY1ZpZXcoeyBzeW5jID0gdHJ1ZSwgdXJsID0gJycgfTogeyBzeW5jOiBib29sZWFuOyB1cmw/OiBzdHJpbmcgfSkge1xyXG5cdFx0cmV0dXJuIGBcclxuICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbWVyX3dyYXBlciByci1pZ25vcmVcIj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIGNsYXNzPVwiaWZyYW1lX3dyYXBlclwiXHJcbiAgICAgICAgICAgIHN0eWxlPVwicG9pbnRlci1ldmVudHM6IGF1dG87XCJcclxuICAgICAgICA+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHN0YXRpYyBhZ2VudFN5bmNWaWV3KG9wdGlvbnM6IHNjcmVlblN5bmNWaWV3T3B0aW9ucykge1xyXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBzeW5jID0gZmFsc2UgfSA9IG9wdGlvbnM7XHJcblx0XHRyZXR1cm4gYFxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYWdlbnRfd3JhcGVyIHJyLWlnbm9yZVwiPlxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgICAgY2xhc3M9XCJpZnJhbWVfd3JhcGVyXCJcclxuICAgICAgICAgICAgaWQ9XCJpZnJhbWVfd3JhcGVyXCJcclxuICAgICAgICAgICAgc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTsgd2lkdGg6JHt3aWR0aH1weDsgaGVpZ2h0OiR7aGVpZ2h0fXB4XCJcclxuICAgICAgICA+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50O1xyXG4iLCJpbXBvcnQgKiBhcyBycndlYiBmcm9tICdAemNvL3Jyd2ViJztcclxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudCc7XHJcbmltcG9ydCB7IGlGcmFtZVBsYXllck9wdGlvbnMsIElPbk1lc3NhZ2UsIElTaXplIH0gZnJvbSAnLi90eXBpbmcnO1xyXG5jbGFzcyBpRnJhbWVQbGF5ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG5cdHByaXZhdGUgZG9tRGF0YTogYW55ID0gbnVsbDtcclxuXHRwcml2YXRlIHdyYXBwZXJFbDogSFRNTEVsZW1lbnQ7XHJcblx0cHJpdmF0ZSB0b3VjaFBvc1g6IG51bWJlciA9IDA7XHJcblx0cHJpdmF0ZSB0b3VjaFBvc1k6IG51bWJlciA9IDA7XHJcblx0cHJpdmF0ZSBoaWRlQ3Vyc29yOiBib29sZWFuID0gdHJ1ZTtcclxuXHRwcml2YXRlIHN5bmNJZDogbnVtYmVyID0gMDtcclxuXHRwcml2YXRlIGxhc3RTeW5jSWQ6IG51bWJlciA9IC0xO1xyXG5cdHByaXZhdGUgc3RhdGljIHJlcGxheWVyOiBhbnk7XHJcblx0cHJpdmF0ZSBzdGF0aWMgb25Mb2NhbFNpemU6IChzaXplOiBJU2l6ZSkgPT4gdm9pZDtcclxuXHRwcml2YXRlIHN0YXRpYyBzeW5jOiBib29sZWFuID0gZmFsc2U7XHJcblx0cHJpdmF0ZSBzdGF0aWMgdG91Y2hJbWFnZTogc3RyaW5nO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zOiBpRnJhbWVQbGF5ZXJPcHRpb25zKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy53cmFwcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHRoaXMud3JhcHBlckVsLmNsYXNzTmFtZSA9ICdpZnJhbWUtcGxheWVyLW1haW4tY29udGFpbmVyJztcclxuXHRcdHRoaXMud3JhcHBlckVsLmlkID0gJ2lmcmFtZS1wbGF5ZXItbWFpbi1jb250YWluZXInO1xyXG5cdFx0aUZyYW1lUGxheWVyLnRvdWNoSW1hZ2UgPSBvcHRpb25zLnRvdWNoSW1hZ2U7XHJcblx0XHRpRnJhbWVQbGF5ZXIuc3luYyA9IG9wdGlvbnMuc3luYyB8fCBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpbml0UmVwbGF5ZXIocm9vdDogSFRNTEVsZW1lbnQpIHtcclxuXHRcdGlGcmFtZVBsYXllci5yZXBsYXllciA9IG5ldyBycndlYi5SZXBsYXllcihbXSwge1xyXG5cdFx0XHRyb290OiByb290LFxyXG5cdFx0XHRsb2FkVGltZW91dDogMTAwLFxyXG5cdFx0XHRsaXZlTW9kZTogdHJ1ZSxcclxuXHRcdFx0c2hvd1dhcm5pbmc6IHRydWUsXHJcblx0XHRcdHNob3dEZWJ1ZzogdHJ1ZSxcclxuXHRcdFx0bW91c2VUYWlsOiBmYWxzZSxcclxuXHRcdFx0VU5TQUZFX3JlcGxheUNhbnZhczogdHJ1ZSwgLy8gdHJ1ZSDkvJrpgKDmiJBqc+aJp+ihjCwgZmFsc2Ug5Lya5Yqg6L295LiN5LqG6aG16Z2iXHJcblx0XHRcdHBhdXNlQW5pbWF0aW9uOiBmYWxzZSxcclxuXHRcdFx0aW5zZXJ0U3R5bGVSdWxlczogW1xyXG5cdFx0XHRcdGBcclxuICAgICAgICAgICAgICAgICo6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGAsXHJcblx0XHRcdFx0YC5yci1ibG9jayB7ZGlzcGxheTogaW5saW5lLWJsb2NrfWAsXHJcblx0XHRcdFx0YC5yci1tYXNrIHtkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdoaXRlLXNwYWNlOiBub3dyYXA7fWAsXHJcblx0XHRcdFx0YC5zY3JlZW4tc3luY19jb250YWluZXIgeyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQgfWBcclxuXHRcdFx0XSxcclxuXHRcdFx0dW5wYWNrRm46IHJyd2ViLnVucGFja1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY3JlYXRlQ29tcG9uZW50KCkge1xyXG5cdFx0dGhpcy53cmFwcGVyRWwuaW5uZXJIVE1MICs9IGlGcmFtZVBsYXllci5pRnJhbWVQbGF5ZXJWaWV3KGlGcmFtZVBsYXllci50b3VjaEltYWdlLCB0aGlzLnRvdWNoSW1hZ2VTdHlsZSgpKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW5kZXIoZWw6IEhUTUxFbGVtZW50KSB7XHJcblx0XHRpZiAoIWVsKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigncmVuZGVyIGVsZW1lbnQgaXMgbm90IGRlZmluZWQnKTtcclxuXHRcdH1cclxuXHRcdGVsLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlckVsKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc2V0SGlkZUN1cnNvcihzdGF0dXM6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMuaGlkZUN1cnNvciA9IHN0YXR1cztcclxuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldEN1cnNvckhpZGUoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oaWRlQ3Vyc29yO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSB0b3VjaEltYWdlU3R5bGUoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oaWRlQ3Vyc29yXHJcblx0XHRcdD8gYFxyXG5cdFx0XHRcdHRvcDogJHt0aGlzLnRvdWNoUG9zWSAtIDE2fXB4O1xyXG5cdFx0XHRcdGxlZnQ6ICR7dGhpcy50b3VjaFBvc1ggLSAxNn1weDtcclxuXHRcdFx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgZWFzZS1vdXQ7XHJcblx0XHRcdFx0b3BhY2l0eTogJHswfTtcclxuXHRcdFx0YFxyXG5cdFx0XHQ6IGBcclxuXHRcdFx0dG9wOiAke3RoaXMudG91Y2hQb3NZIC0gMTZ9cHg7XHJcblx0XHRcdGxlZnQ6ICR7dGhpcy50b3VjaFBvc1ggLSAxNn1weDtcclxuXHRcdFx0b3BhY2l0eTogJHsxfTtcclxuXHRcdGA7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIG9uUmVtb3RlVG91Y2hQb3MocG9zOiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfSkge1xyXG5cdFx0dGhpcy5zZXRIaWRlQ3Vyc29yKGZhbHNlKTtcclxuXHRcdHRoaXMudG91Y2hQb3NYID0gcG9zLnBhZ2VYO1xyXG5cdFx0dGhpcy50b3VjaFBvc1kgPSBwb3MucGFnZVk7XHJcblx0XHQvLyBoaWRlIGN1cnNvclxyXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdHRoaXMuc2V0SGlkZUN1cnNvcih0cnVlKTtcclxuXHRcdH0sIDUwMCk7XHJcblx0fVxyXG5cclxuXHQvKiog5o6l5pS25ZCM5bGP5pWw5o2uICovXHJcblx0cHVibGljIHNldE1lc3NhZ2VJbihtZXNzYWdlOiBJT25NZXNzYWdlKSB7XHJcblx0XHRjb25zb2xlLmxvZygnaUZyYW1lUGxheWVyOicsIG1lc3NhZ2UpO1xyXG5cclxuXHRcdGlmIChpRnJhbWVQbGF5ZXIuc3luYykgcmV0dXJuO1xyXG5cdFx0Ly8g5Y+q5aSE55CGc2NyZWVuc3luY+exu+Wei+eahOa2iOaBr1xyXG5cdFx0aWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3NjcmVlbnN5bmMnKSB7XHJcblx0XHRcdGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3NjcmVlbnNob3QnKSB7XHJcblx0XHRcdFx0Ly8gcmVuZGVyIHBsYXllclxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdpRnJhbWVQbGF5ZXIucmVwbGF5ZXI6JywgbWVzc2FnZS5kb21EYXRhLCB0aGlzLmRvbURhdGEpO1xyXG5cdFx0XHRcdGlmIChpRnJhbWVQbGF5ZXIucmVwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5kb21EYXRhKSB7XHJcblx0XHRcdFx0XHRcdC8vIGZpcnN0IHN5bmMgZGF0YVxyXG5cdFx0XHRcdFx0XHR0aGlzLnN5bmNJZCA9IG1lc3NhZ2Uuc3luY0lkIHx8IDA7XHJcblx0XHRcdFx0XHRcdHRoaXMuZG9tRGF0YSA9IG1lc3NhZ2UuZG9tRGF0YTtcclxuXHRcdFx0XHRcdFx0aUZyYW1lUGxheWVyLnJlcGxheWVyLnN0YXJ0TGl2ZSh0aGlzLmRvbURhdGEudGltZXN0YW1wIC0gNTAwKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdyZXBsYXllci5hZGRFdmVudDonLCBpRnJhbWVQbGF5ZXIucmVwbGF5ZXIuYWRkRXZlbnQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIOi/h+a7pOmHjeWkjeeahHN5bmNJZFxyXG5cdFx0XHRcdFx0aWYgKHRoaXMubGFzdFN5bmNJZCAhPT0gbWVzc2FnZS5zeW5jSWQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5sYXN0U3luY0lkID0gbWVzc2FnZS5zeW5jSWQgfHwgMDtcclxuXHRcdFx0XHRcdFx0dGhpcy5zeW5jSWQrKztcclxuXHRcdFx0XHRcdFx0aUZyYW1lUGxheWVyLnJlcGxheWVyLmFkZEV2ZW50KG1lc3NhZ2UuZG9tRGF0YSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSAndG91Y2hQb3MnKSB7XHJcblx0XHRcdFx0dGhpcy5vblJlbW90ZVRvdWNoUG9zKG1lc3NhZ2UudmFsdWUgYXMgYW55KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmhhbmRsZWQgc2NyZWVuc3luYyBtZXNzYWdlIDogJywgbWVzc2FnZSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ3VuaGFuZGxlZCBzY3JlZW5zeW5jIG1lc3NhZ2UgOiAnLCBtZXNzYWdlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIOiuv+Wuouerr+aOpeaUtkg16aG16Z2i55qE5raI5oGvXHJcblx0cHJpdmF0ZSBvbk1lc3NhZ2UoZXZlbnQ6IHsgZGF0YTogSU9uTWVzc2FnZSB9KSB7XHJcblx0XHRpZiAoIWV2ZW50LmRhdGEgfHwgIWV2ZW50LmRhdGEua2V5KSByZXR1cm47XHJcblx0XHRpZiAoZXZlbnQuZGF0YS5rZXkgIT09ICdTQ1JFRU5TWU5DJykgcmV0dXJuO1xyXG5cdFx0aWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ1NZTkMnKSB7XHJcblx0XHRcdGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ3Njcm9sbCcpIHtcclxuXHRcdFx0XHQvLyDmu5rliqjnlLvluINcclxuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2hpdGUtYm9hcmQtY2FudmFzJyk7XHJcblx0XHRcdFx0aWYgKGNhbnZhcykge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQ7XHJcblx0XHRcdFx0XHRwYXJlbnQuc3R5bGUudG9wID0gYC0ke2V2ZW50LmRhdGEudmFsdWV9cHhgO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ3NpemUnKSB7XHJcblx0XHRcdFx0Ly8g5bCG5pys5Zywc2l6Zei/lOWbnue7meS4iuWxglxyXG5cdFx0XHRcdGlmIChpRnJhbWVQbGF5ZXIub25Mb2NhbFNpemUpIHtcclxuXHRcdFx0XHRcdGlGcmFtZVBsYXllci5vbkxvY2FsU2l6ZShldmVudC5kYXRhLnZhbHVlIGFzIGFueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpRnJhbWVQbGF5ZXI7XHJcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnQnO1xyXG5pbXBvcnQgeyBJSWZhcm1lT3B0aW9ucywgSUltYWdlRGF0YSwgSU1lc3NhZ2VJbiwgSU9uTWVzc2FnZSwgSVNpemUgfSBmcm9tICcuL3R5cGluZyc7XHJcblxyXG5jbGFzcyBJZmFtZSBleHRlbmRzIENvbXBvbmVudCB7XHJcblx0cHJpdmF0ZSB3cmFwcGVyRWw6IEhUTUxFbGVtZW50O1xyXG5cdHByaXZhdGUgc3RhdGljIHN5bmM6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHN0YXRpYyB1cmw6IHN0cmluZyA9ICcnO1xyXG5cdHByaXZhdGUgbWVzc2FnZUluOiBhbnkgPSB7fTtcclxuXHRwcml2YXRlIHN0YXRpYyBpZmFtZUNvbnRhaW5lcjogSFRNTElGcmFtZUVsZW1lbnQ7XHJcblx0cHJpdmF0ZSBzdGF0aWMgb25TY3JlZW5TeW5jTWVzc2FnZTogKGRhdGE6IElPbk1lc3NhZ2UsIHR5cGU6IHN0cmluZykgPT4gdm9pZDtcclxuXHRwcml2YXRlIHN0YXRpYyBvbkxvY2FsU2l6ZTogKHNpemU6IElTaXplKSA9PiB2b2lkO1xyXG5cdHByaXZhdGUgc3RhdGljIG9uU2NyZWVuU3luY0VuZDogKCkgPT4gdm9pZDtcclxuXHJcblx0Y29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zOiBJSWZhcm1lT3B0aW9ucykge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdGNvbnN0IHsgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCBpc0N1c3RvbWVyLCBvbkxvY2FsU2l6ZSwgb25TY3JlZW5TeW5jRW5kLCBvblNjcmVlblN5bmNNZXNzYWdlIH0gPSBvcHRpb25zO1xyXG5cdFx0dGhpcy53cmFwcGVyRWwgPSBlbDtcclxuXHRcdElmYW1lLm9uU2NyZWVuU3luY01lc3NhZ2UgPSBvblNjcmVlblN5bmNNZXNzYWdlO1xyXG5cdFx0SWZhbWUub25Mb2NhbFNpemUgPSBvbkxvY2FsU2l6ZTtcclxuXHRcdElmYW1lLm9uU2NyZWVuU3luY0VuZCA9IG9uU2NyZWVuU3luY0VuZDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpbml0KCkge1xyXG5cdFx0aWYgKElmYW1lLnN5bmMpIHtcclxuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGVzdG9yeSgpIHtcclxuXHRcdHRoaXMuc3RvcFNjcmVlbnN5bmMoKTtcclxuXHRcdHRoaXMudW5yZWdpc3RlcigpO1xyXG5cdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0UmVtb3RlU2l6ZShvcHRpb25zOiBJU2l6ZSkge1xyXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBzY3JvbGxIZWlnaHQgfSA9IG9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0TG9jYWxTaXplKCkge31cclxuXHJcblx0cHVibGljIGluaXRpRnJhbWVSZWNvcmRlcigpIHtcclxuXHRcdHRoaXMuY3JlYXRlQ29tcG9uZW50KCk7XHJcblx0XHRJZmFtZS5pZmFtZUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpZnJhbWVfd3JhcGVyX2NvbnRhaW5lcicpIGFzIEhUTUxJRnJhbWVFbGVtZW50O1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBjcmVhdGVDb21wb25lbnQoKSB7XHJcblx0XHR0aGlzLndyYXBwZXJFbC5pbm5lckhUTUwgKz0gSWZhbWUuaUZyYW1lUmVjb3JkZXJWaWV3KElmYW1lLnVybCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVuZGVyKCkge31cclxuXHJcblx0cHVibGljIHNldE1lc3NhZ2VJbihtZXNzYWdlOiBhbnkpIHtcclxuXHRcdHRoaXMubWVzc2FnZUluID0gbWVzc2FnZTtcclxuXHRcdHRoaXMub25NZXNzYWdlSW4obWVzc2FnZSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFkZEV2ZW50TGlzdGVuZXIoKSB7XHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub25NZXNzYWdlSW4sIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2VJbiwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZWdpc3RlcigpIHtcclxuXHRcdGlmICghSWZhbWUuaWZhbWVDb250YWluZXIpIHJldHVybjtcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB7XHJcblx0XHRcdGtleTogJ1NDUkVFTlNZTkMnLFxyXG5cdFx0XHR0eXBlOiAnUkVHSVNURVInXHJcblx0XHR9O1xyXG5cdFx0aWYgKElmYW1lLmlmYW1lQ29udGFpbmVyLmNvbnRlbnRXaW5kb3cpIHtcclxuXHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIHVucmVnaXN0ZXIoKSB7XHJcblx0XHRjb25zdCBtZXNzYWdlID0ge1xyXG5cdFx0XHRrZXk6ICdTQ1JFRU5TWU5DJyxcclxuXHRcdFx0dHlwZTogJ1VOUkVHSVNURVInXHJcblx0XHR9O1xyXG5cdFx0aWYgKElmYW1lLmlmYW1lQ29udGFpbmVyLmNvbnRlbnRXaW5kb3cpIHtcclxuXHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIHJlcXVlc3RTaXplKCkge1xyXG5cdFx0Y29uc3QgbWVzc2FnZSA9IHtcclxuXHRcdFx0a2V5OiAnU0NSRUVOU1lOQycsXHJcblx0XHRcdHR5cGU6ICdTWU5DJyxcclxuXHRcdFx0YWN0aW9uOiAncmVxdWVzdFNpemUnXHJcblx0XHR9O1xyXG5cdFx0aWYgKElmYW1lLmlmYW1lQ29udGFpbmVyLmNvbnRlbnRXaW5kb3cpIHtcclxuXHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIHJlcXVlc3RTY3JlZW5zaG90KCkge1xyXG5cdFx0Y29uc3QgbWVzc2FnZSA9IHtcclxuXHRcdFx0a2V5OiAnU0NSRUVOU1lOQycsXHJcblx0XHRcdHR5cGU6ICdTWU5DJyxcclxuXHRcdFx0YWN0aW9uOiAncmVxdWVzdFNjcmVlbnNob3QnXHJcblx0XHR9O1xyXG5cdFx0aWYgKElmYW1lLmlmYW1lQ29udGFpbmVyLmNvbnRlbnRXaW5kb3cpIHtcclxuXHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIHN0YXJ0U2NyZWVuc3luYygpIHtcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB7XHJcblx0XHRcdGtleTogJ1NDUkVFTlNZTkMnLFxyXG5cdFx0XHR0eXBlOiAnU1lOQycsXHJcblx0XHRcdGFjdGlvbjogJ3N0YXJ0U2NyZWVuc3luYydcclxuXHRcdH07XHJcblx0XHRpZiAoSWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdykge1xyXG5cdFx0XHRJZmFtZS5pZmFtZUNvbnRhaW5lci5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHByaXZhdGUgc3RvcFNjcmVlbnN5bmMoKSB7XHJcblx0XHRjb25zdCBtZXNzYWdlID0ge1xyXG5cdFx0XHRrZXk6ICdTQ1JFRU5TWU5DJyxcclxuXHRcdFx0dHlwZTogJ1NZTkMnLFxyXG5cdFx0XHRhY3Rpb246ICdzdG9wU2NyZWVuc3luYydcclxuXHRcdH07XHJcblx0XHRpZiAoSWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdykge1xyXG5cdFx0XHRJZmFtZS5pZmFtZUNvbnRhaW5lci5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsICcqJyk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHByaXZhdGUgZ2V0U2NyZWVuc2hvdCgpIHtcclxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB7XHJcblx0XHRcdGtleTogJ1NDUkVFTlNZTkMnLFxyXG5cdFx0XHR0eXBlOiAnU1lOQycsXHJcblx0XHRcdGFjdGlvbjogJ2dldFNjcmVlbnNob3QnXHJcblx0XHR9O1xyXG5cdFx0aWYgKElmYW1lLmlmYW1lQ29udGFpbmVyLmNvbnRlbnRXaW5kb3cpIHtcclxuXHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwcml2YXRlIG9uSWZyYW1lTG9hZCgpIHtcclxuXHRcdC8vIHJlZ2lzdGVyIG1lc3NhZ2VcclxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHR0aGlzLnJlZ2lzdGVyKCk7XHJcblx0XHR9LCAzMDAwKTtcclxuXHR9XHJcblx0Ly8g6K6/5a6i56uv5o6l5pS2SDXpobXpnaLnmoTmtojmga9cclxuXHRwcml2YXRlIG9uTWVzc2FnZUluKGV2ZW50OiB7IGRhdGE6IElPbk1lc3NhZ2UgfSkge1xyXG5cdFx0aWYgKCFldmVudC5kYXRhIHx8ICFldmVudC5kYXRhLmtleSkgcmV0dXJuO1xyXG5cdFx0aWYgKGV2ZW50LmRhdGEua2V5ICE9PSAnU0NSRUVOU1lOQycpIHJldHVybjtcclxuXHRcdGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdSRUdJU1RFUicpIHtcclxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IHtcclxuXHRcdFx0XHRrZXk6ICdTQ1JFRU5TWU5DJyxcclxuXHRcdFx0XHR0eXBlOiAnUkVHSVNURVInXHJcblx0XHRcdH07XHJcblx0XHRcdGlmIChJZmFtZS5pZmFtZUNvbnRhaW5lci5jb250ZW50V2luZG93KSB7XHJcblx0XHRcdFx0SWZhbWUuaWZhbWVDb250YWluZXIuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCAnKicpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnaUZyYW1lQ29udGVudExvYWRlZCcpIHtcclxuXHRcdFx0dGhpcy5vbklmcmFtZUxvYWQoKTtcclxuXHRcdH1cclxuXHRcdGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdTWU5DJykge1xyXG5cdFx0XHRpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdzY3JvbGwnKSB7XHJcblx0XHRcdFx0Ly8g5rua5Yqo55S75biDXHJcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmVlbnN5bmNXaGl0ZWJvYXJkJyk7XHJcblx0XHRcdFx0aWYgKGNhbnZhcykge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQ7XHJcblx0XHRcdFx0XHRwYXJlbnQuc3R5bGUudG9wID0gYC0ke2V2ZW50LmRhdGEudmFsdWV9cHhgO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyDlj5HpgIHmtojmga/nu5nluqfluK1cclxuXHRcdFx0XHRpZiAoSWZhbWUuc3luYykge1xyXG5cdFx0XHRcdFx0SWZhbWUub25TY3JlZW5TeW5jTWVzc2FnZShcclxuXHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogJ3Njcm9sbCcsXHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGV2ZW50LmRhdGEudmFsdWVcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0J3NjcmVlbnN5bmMnXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ3NpemUnKSB7XHJcblx0XHRcdFx0Ly8g5bCG5pys5Zywc2l6Zei/lOWbnue7meS4iuWxglxyXG5cdFx0XHRcdGlmIChJZmFtZS5vbkxvY2FsU2l6ZSkge1xyXG5cdFx0XHRcdFx0SWZhbWUub25Mb2NhbFNpemUoZXZlbnQuZGF0YS52YWx1ZSBhcyBhbnkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoSWZhbWUuc3luYykge1xyXG5cdFx0XHRcdFx0SWZhbWUub25TY3JlZW5TeW5jTWVzc2FnZShcclxuXHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogJ3NpemUnLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBldmVudC5kYXRhLnZhbHVlXHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdCdzY3JlZW5zeW5jJ1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdzY3JlZW5zaG90Jykge1xyXG5cdFx0XHRcdGlmIChJZmFtZS5zeW5jKSB7XHJcblx0XHRcdFx0XHRJZmFtZS5vblNjcmVlblN5bmNNZXNzYWdlKFxyXG5cdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0YWN0aW9uOiAnc2NyZWVuc2hvdCcsXHJcblx0XHRcdFx0XHRcdFx0ZG9tRGF0YTogZXZlbnQuZGF0YS5kb21EYXRhLFxyXG5cdFx0XHRcdFx0XHRcdHN5bmNJZDogZXZlbnQuZGF0YS5zeW5jSWRcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0J3NjcmVlbnN5bmMnXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2lnbm9yZUVsZW1lbnRzJykge1xyXG5cdFx0XHRcdGlmIChJZmFtZS5zeW5jKSB7XHJcblx0XHRcdFx0XHRJZmFtZS5vblNjcmVlblN5bmNNZXNzYWdlKFxyXG5cdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0YWN0aW9uOiAnaWdub3JlRWxlbWVudHMnLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBldmVudC5kYXRhLnZhbHVlXHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdCdzY3JlZW5zeW5jJ1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICd0b3VjaFBvcycpIHtcclxuXHRcdFx0XHRpZiAoSWZhbWUuc3luYykge1xyXG5cdFx0XHRcdFx0SWZhbWUub25TY3JlZW5TeW5jTWVzc2FnZShcclxuXHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogJ3RvdWNoUG9zJyxcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogZXZlbnQuZGF0YS52YWx1ZVxyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHQnc2NyZWVuc3luYydcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50LmRhdGEuYWN0aW9uID09PSAnZW5kU2NyZWVuU3luYycpIHtcclxuXHRcdFx0XHRpZiAoSWZhbWUuc3luYykge1xyXG5cdFx0XHRcdFx0SWZhbWUub25TY3JlZW5TeW5jTWVzc2FnZShcclxuXHRcdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRcdGFjdGlvbjogJ2VuZFNjcmVlblN5bmMnXHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdCdzY3JlZW5zeW5jJ1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdC8vIOmAmuefpeS4iuWxguWFs+mXreWQjOWxj+e7hOS7tlxyXG5cdFx0XHRcdFx0aWYgKElmYW1lLm9uU2NyZWVuU3luY0VuZCkge1xyXG5cdFx0XHRcdFx0XHRJZmFtZS5vblNjcmVlblN5bmNFbmQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdnb3RTY3JlZW5zaG90Jykge1xyXG5cdFx0XHRcdGlmIChJZmFtZS5zeW5jKSB7XHJcblx0XHRcdFx0XHRJZmFtZS5vblNjcmVlblN5bmNNZXNzYWdlKFxyXG5cdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0YWN0aW9uOiAnZ290U2NyZWVuc2hvdCcsXHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IGV2ZW50LmRhdGEudmFsdWVcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0J3NjcmVlbnN5bmMnXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSWZhbWU7XHJcbiIsImltcG9ydCB7IElPbk1lc3NhZ2UsIElTaXplIH0gZnJvbSAnLi90eXBpbmcnO1xyXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50JztcclxuaW1wb3J0IGlGcmFtZVBsYXllciBmcm9tICcuL2lGcmFtZVBsYXllcic7XHJcbmltcG9ydCBpRnJhbWVSZWNvcmRlciBmcm9tICcuL2lGcmFtZVJlY29yZGVyJztcclxuaW1wb3J0ICcuL3N0eWxlcy9pbmRleC5zY3NzJztcclxuaW1wb3J0IHsgSVNjcmVlbk9wdGlvbnMgfSBmcm9tICcuL3R5cGluZyc7XHJcbmNsYXNzIFNjcmVlblBhZ2UgZXh0ZW5kcyBDb21wb25lbnQge1xyXG5cdHByaXZhdGUgZWw6IEhUTUxFbGVtZW50O1xyXG5cdHByaXZhdGUgcm9vdEVsOiBIVE1MRWxlbWVudDtcclxuXHRwcml2YXRlIHdpZHRoOiBudW1iZXIgPSAwO1xyXG5cdHByaXZhdGUgaGVpZ2h0OiBudW1iZXIgPSAwO1xyXG5cdHByaXZhdGUgaXNDdXN0b21lcjogYm9vbGVhbjtcclxuXHRwcml2YXRlIHN5bmM6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSB1cmw6IHN0cmluZztcclxuXHRwcml2YXRlIHRvdWNoSW1hZ2U6IHN0cmluZztcclxuXHRwcml2YXRlIGlmcmFtZVBsYXllcjogaUZyYW1lUGxheWVyIHwgbnVsbCA9IG51bGw7XHJcblx0cHJpdmF0ZSBpZnJhbWVSZWNvcmRlcjogaUZyYW1lUmVjb3JkZXIgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIG9uTG9jYWxTaXplOiAoc2l6ZTogSVNpemUpID0+IHZvaWQ7XHJcblx0cHJpdmF0ZSBvblNjcmVlblN5bmNNZXNzYWdlOiAoZGF0YTogSU9uTWVzc2FnZSwgdHlwZTogc3RyaW5nKSA9PiB2b2lkO1xyXG5cdHByaXZhdGUgb25TY3JlZW5TeW5jRW5kOiAoKSA9PiB2b2lkO1xyXG5cdGNvbnN0cnVjdG9yKHJvb3RFbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM6IElTY3JlZW5PcHRpb25zKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0Y29uc3QgeyBpc0N1c3RvbWVyLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHN5bmMgPSBmYWxzZSwgdXJsID0gJycsIHRvdWNoSW1hZ2UsIG9uTG9jYWxTaXplLCBvblNjcmVlblN5bmNNZXNzYWdlLCBvblNjcmVlblN5bmNFbmQgfSA9IG9wdGlvbnM7XHJcblx0XHR0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHR0aGlzLmVsLmNsYXNzTmFtZSA9ICdzY3JlZW5fc3luY19jb250YWluZXIgcnItaWdub3JlJztcclxuXHRcdHRoaXMuZWwuaWQgPSAnc2NyZWVuX3N5bmNfY29udGFpbmVyJztcclxuXHRcdHRoaXMucm9vdEVsID0gcm9vdEVsO1xyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0aGlzLnN5bmMgPSBzeW5jO1xyXG5cdFx0dGhpcy51cmwgPSB1cmw7XHJcblx0XHR0aGlzLmlzQ3VzdG9tZXIgPSBpc0N1c3RvbWVyO1xyXG5cdFx0dGhpcy50b3VjaEltYWdlID0gdG91Y2hJbWFnZTtcclxuXHRcdHRoaXMub25Mb2NhbFNpemUgPSBvbkxvY2FsU2l6ZTtcclxuXHRcdHRoaXMub25TY3JlZW5TeW5jTWVzc2FnZSA9IG9uU2NyZWVuU3luY01lc3NhZ2U7XHJcblx0XHR0aGlzLm9uU2NyZWVuU3luY0VuZCA9IG9uU2NyZWVuU3luY0VuZDtcclxuXHRcdHRoaXMuY3JlYXRlRG9tKCk7XHJcblx0fVxyXG5cdC8qKiDliJvlu7rlrp7kvosgKi9cclxuXHRwdWJsaWMgY3JlYXRlRG9tKCkge1xyXG5cdFx0aWYgKCF0aGlzLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0dGhpcy5pZnJhbWVQbGF5ZXIgPSBuZXcgaUZyYW1lUGxheWVyKHsgdG91Y2hJbWFnZTogdGhpcy50b3VjaEltYWdlLCBzeW5jOiB0aGlzLnN5bmMgfSk7XHJcblx0XHRcdHRoaXMuZWwuaW5uZXJIVE1MICs9IENvbXBvbmVudC5hZ2VudFN5bmNWaWV3KHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQsIHN5bmM6IHRoaXMuc3luYyB9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuZWwuaW5uZXJIVE1MICs9IENvbXBvbmVudC5jdXN0b21lclN5bmNWaWV3KHsgc3luYzogdGhpcy5zeW5jLCB1cmw6IHRoaXMudXJsIH0pO1xyXG5cdFx0XHR0aGlzLmlmcmFtZVJlY29yZGVyID0gbmV3IGlGcmFtZVJlY29yZGVyKHRoaXMuZWwsIHtcclxuXHRcdFx0XHR3aWR0aDogdGhpcy53aWR0aCxcclxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG5cdFx0XHRcdGlzQ3VzdG9tZXI6IHRoaXMuaXNDdXN0b21lcixcclxuXHRcdFx0XHRvbkxvY2FsU2l6ZTogdGhpcy5vbkxvY2FsU2l6ZSxcclxuXHRcdFx0XHRvblNjcmVlblN5bmNNZXNzYWdlOiB0aGlzLm9uU2NyZWVuU3luY01lc3NhZ2UsXHJcblx0XHRcdFx0b25TY3JlZW5TeW5jRW5kOiB0aGlzLm9uU2NyZWVuU3luY0VuZFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5pZnJhbWVSZWNvcmRlci5pbml0aUZyYW1lUmVjb3JkZXIoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpbml0KCkge1xyXG5cdFx0dGhpcy5jcmVhdGVDb21wb25lbnQoKTtcclxuXHRcdHRoaXMucmVuZGVyKCk7XHJcblx0fVxyXG5cclxuXHQvKiog5riy5p+T6aG16Z2iICovXHJcblx0cHJpdmF0ZSByZW5kZXIoKSB7XHJcblx0XHRjb25zb2xlLmxvZygncmVuZGVyJywgdGhpcy5lbCk7XHJcblx0XHR0aGlzLnJvb3RFbC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcclxuXHRcdHRoaXMuaWZyYW1lUGxheWVyPy5yZW5kZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lmcmFtZV93cmFwZXInKSEpO1xyXG5cdFx0dGhpcy5pZnJhbWVQbGF5ZXI/LmluaXRSZXBsYXllcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWZyYW1lX3dyYXBlcl9jb250YWluZXInKSEpO1xyXG5cdH1cclxuXHJcblx0LyoqIOe7keWumuS6i+S7tiAqL1xyXG5cdHByaXZhdGUgYmluZEV2ZW50KCkge31cclxuXHJcblx0cHJpdmF0ZSBjcmVhdGVDb21wb25lbnQoKSB7XHJcblx0XHR0aGlzLmlmcmFtZVBsYXllcj8uY3JlYXRlQ29tcG9uZW50KCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0TWVzc2FnZUluKG1lc3NhZ2U6IGFueSkge1xyXG5cdFx0dGhpcy5pZnJhbWVSZWNvcmRlcj8uc2V0TWVzc2FnZUluKG1lc3NhZ2UpO1xyXG5cdFx0dGhpcy5pZnJhbWVQbGF5ZXI/LnNldE1lc3NhZ2VJbihtZXNzYWdlKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjcmVlblBhZ2U7XHJcbiIsImltcG9ydCB7IElPbk1lc3NhZ2UsIElaY29TeW5jU2NyZWVuLCBJT25NZXNzYWdlT3V0LCBJU2VuZEN1c3RvbWVyTWVzYWdnZSB9IGZyb20gJy4vdHlwaW5nJztcclxuaW1wb3J0IFdoaXRlQm9hcmQgZnJvbSAnLi4vV2hpdGVCb2FyZCc7XHJcbmltcG9ydCBTY3JlZW5QYWdlIGZyb20gJy4uL1NjcmVlblBhZ2UnO1xyXG5pbXBvcnQgeyBUb29sTW9kZSwgVG9vbHNQcm9wcywgSVNpemUgfSBmcm9tICcuLi9XaGl0ZUJvYXJkL3R5cGluZyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaY29TeW5jU2NyZWVuIHtcclxuXHRwcml2YXRlIHN0YXRpYyBpc0N1c3RvbWVyOiBib29sZWFuID0gZmFsc2U7IC8vIOWdkOW4rSBvciDorr/lrqJcclxuXHRwcml2YXRlIHN0YXRpYyB1cmw6IHN0cmluZyA9ICcnOyAvLyDpnIDopoHlkIzlsY/nmoTpobXpnaLlnLDlnYBcclxuXHRwcml2YXRlIHN0YXRpYyBpc0hpZGVNYXJrVG9vbDogYm9vbGVhbiA9IGZhbHNlOyAvLyDmmK/lkKbpmpDol4/moIfms6hcclxuXHRwcml2YXRlIHN0YXRpYyBoNU1lc3NhZ2VJbjogYW55O1xyXG5cdHByaXZhdGUgc3RhdGljIG1hcmtlck1lc3NhZ2VJbjogYW55O1xyXG5cdHByaXZhdGUgc3RhdGljIHJlbW90ZVdpZHRoOiBudW1iZXIgPSAzNzU7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVtb3RlSGVpZ2h0OiBudW1iZXIgPSA2Njc7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVtb3RlU2Nyb2xsSGVpZ2h0OiBudW1iZXIgPSA2Njc7XHJcblx0cHJpdmF0ZSBzdGF0aWMgbG9jYWxXaWR0aDogbnVtYmVyID0gMzc1O1xyXG5cdHByaXZhdGUgc3RhdGljIGxvY2FsSGVpZ2h0OiBudW1iZXIgPSA2Njc7XHJcblx0cHJpdmF0ZSBzdGF0aWMgbG9jYWxTY3JvbGxIZWlnaHQ6IG51bWJlciA9IDY2NztcclxuXHRwcml2YXRlIHN0YXRpYyBvblNjcmVlblN5bmNNZXNzYWdlOiAoZGF0YTogSU9uTWVzc2FnZSkgPT4gdm9pZDsgLy8g6L6T5Ye65pWw5o2uXHJcblx0cHJpdmF0ZSBzdGF0aWMgb25TY3JlZW5TeW5jRW5kOiAoKSA9PiB2b2lkOyAvLyDlkIzlsY/nu5PmnZ/lm57osINcclxuXHRwcml2YXRlIHN0YXRpYyBzZW5kQ3VzdG9tZXJNZXNzYWdlOiBJU2VuZEN1c3RvbWVyTWVzYWdnZTtcclxuXHRwcml2YXRlIHN0YXRpYyBpc0xvY2FsU2l6ZUdvdDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgc3RhdGljIGlzUmVtb3RlU2l6ZUdvdDogYm9vbGVhbiA9IHRydWU7XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNTdGFydGVkU3luYzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdHByaXZhdGUgc3RhdGljIHN5bmM6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHdoaXRlQm9hcmQ6IFdoaXRlQm9hcmQgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIHNjcmVlblBhZ2U6IFNjcmVlblBhZ2UgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIHJvb3RDb250YWluZXI6IEhUTUxFbGVtZW50O1xyXG5cdHByaXZhdGUgbWFya1Rvb2xzOiBUb29sc1Byb3BzW10gPSBbXHJcblx0XHR7IGlkOiAxLCBtb2RlOiBUb29sTW9kZS5QRU4sIGlzQWN0aXZlOiB0cnVlIH0sXHJcblx0XHR7IGlkOiAyLCBtb2RlOiBUb29sTW9kZS5MSU5FLCBpc0FjdGl2ZTogZmFsc2UgfSxcclxuXHRcdHsgaWQ6IDMsIG1vZGU6IFRvb2xNb2RlLlJFTU9WRSwgaXNBY3RpdmU6IGZhbHNlIH0sXHJcblx0XHR7IGlkOiA0LCBtb2RlOiBUb29sTW9kZS5DUklDTEUsIGlzQWN0aXZlOiBmYWxzZSB9LFxyXG5cdFx0eyBpZDogNSwgbW9kZTogVG9vbE1vZGUuVEVYVCwgaXNBY3RpdmU6IGZhbHNlIH0sXHJcblx0XHR7IGlkOiA2LCBtb2RlOiBUb29sTW9kZS5SRUNUQU5HTEUsIGlzQWN0aXZlOiBmYWxzZSB9XHJcblx0XTtcclxuXHRwcml2YXRlIHN0YXRpYyB0b3VjaEltYWdlOiBzdHJpbmcgPVxyXG5cdFx0J2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjBQU0l4TmpJMk56WXdPVFV6T0RBMklpQmpiR0Z6Y3owaWFXTnZiaUlnZG1sbGQwSnZlRDBpTUNBd0lERXdNalFnTVRBeU5DSWdkbVZ5YzJsdmJqMGlNUzR4SWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhBdGFXUTlJakU0TWpBaUlIZHBaSFJvUFNJeU1EQWlJR2hsYVdkb2REMGlNakF3SWo0OGNHRjBhQ0JrUFNKTk5URXlJRFV4TW0wdE5URXlJREJoTlRFeUlEVXhNaUF3SURFZ01DQXhNREkwSURBZ05URXlJRFV4TWlBd0lERWdNQzB4TURJMElEQmFJaUJtYVd4c1BTSWpNVE5EUmpNeElpQm1hV3hzTFc5d1lXTnBkSGs5SWk0ME1ERWlJSEF0YVdROUlqRTRNakVpUGp3dmNHRjBhRDQ4Y0dGMGFDQmtQU0pOTlRFeUlEVXhNbTB0TXpReExqTXpNek16TXlBd1lUTTBNUzR6TXpNek16TWdNelF4TGpNek16TXpNeUF3SURFZ01DQTJPREl1TmpZMk5qWTJJREFnTXpReExqTXpNek16TXlBek5ERXVNek16TXpNeklEQWdNU0F3TFRZNE1pNDJOalkyTmpZZ01Gb2lJR1pwYkd3OUlpTXhORVJHTWpVaUlIQXRhV1E5SWpFNE1qSWlQand2Y0dGMGFENDhMM04yWno0PSc7XHJcblx0Y29uc3RydWN0b3Iocm9vdEVsOiBzdHJpbmcsIG9wdGlvbnM6IElaY29TeW5jU2NyZWVuKSB7XHJcblx0XHRjb25zdCB7IGlzQ3VzdG9tZXIsIHVybCA9ICcnLCB3aWR0aCwgaGVpZ2h0LCBvblNjcmVlblN5bmNFbmQsIHNlbmRDdXN0b21NZXNzYWdlLCBvblNjcmVlblN5bmNNZXNzYWdlIH0gPSBvcHRpb25zO1xyXG5cdFx0Y29uc3Qgc2NyZWVuV2lkdGggPSB3aWR0aCA/IHdpZHRoIDogaXNDdXN0b21lciA/IFpjb1N5bmNTY3JlZW4ubG9jYWxXaWR0aCA6IFpjb1N5bmNTY3JlZW4ucmVtb3RlV2lkdGg7XHJcblx0XHRjb25zdCBzY3JlZW5IZWlnaHQgPSBoZWlnaHQgPyBoZWlnaHQgOiBpc0N1c3RvbWVyID8gWmNvU3luY1NjcmVlbi5sb2NhbEhlaWdodCA6IFpjb1N5bmNTY3JlZW4ucmVtb3RlSGVpZ2h0O1xyXG5cdFx0WmNvU3luY1NjcmVlbi5yZW1vdGVXaWR0aCA9IHNjcmVlbldpZHRoO1xyXG5cdFx0WmNvU3luY1NjcmVlbi5yZW1vdGVIZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XHJcblx0XHRaY29TeW5jU2NyZWVuLmxvY2FsV2lkdGggPSBzY3JlZW5XaWR0aDtcclxuXHRcdFpjb1N5bmNTY3JlZW4ubG9jYWxIZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XHJcblx0XHR0aGlzLnJvb3RDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290RWwpIHx8IGRvY3VtZW50LmJvZHk7XHJcblx0XHRjb25zdCBtYWluQ29udGlhbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRtYWluQ29udGlhbmVyLmlkID0gJ3NjcmVlbi1zeW5jLW1haW4td3JhcHBlcic7XHJcblx0XHRtYWluQ29udGlhbmVyLmNsYXNzTmFtZSA9ICdzY3JlZW4tc3luYy1tYWluLXdyYXBwZXInO1xyXG5cdFx0dGhpcy5yb290Q29udGFpbmVyLmFwcGVuZENoaWxkKG1haW5Db250aWFuZXIpO1xyXG5cdFx0WmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyID0gaXNDdXN0b21lcjtcclxuXHRcdFpjb1N5bmNTY3JlZW4ub25TY3JlZW5TeW5jRW5kID0gb25TY3JlZW5TeW5jRW5kO1xyXG5cdFx0WmNvU3luY1NjcmVlbi5vblNjcmVlblN5bmNNZXNzYWdlID0gb25TY3JlZW5TeW5jTWVzc2FnZTtcclxuXHRcdFpjb1N5bmNTY3JlZW4uc2VuZEN1c3RvbWVyTWVzc2FnZSA9IHNlbmRDdXN0b21NZXNzYWdlO1xyXG5cdFx0dGhpcy5zY3JlZW5QYWdlID0gbmV3IFNjcmVlblBhZ2UobWFpbkNvbnRpYW5lciwge1xyXG5cdFx0XHRpc0N1c3RvbWVyLFxyXG5cdFx0XHR3aWR0aDogc2NyZWVuV2lkdGgsXHJcblx0XHRcdGhlaWdodDogc2NyZWVuSGVpZ2h0LFxyXG5cdFx0XHRzeW5jOiBmYWxzZSxcclxuXHRcdFx0dXJsOiAnJyxcclxuXHRcdFx0dG91Y2hJbWFnZTogWmNvU3luY1NjcmVlbi50b3VjaEltYWdlLFxyXG5cdFx0XHRvbkxvY2FsU2l6ZTogdGhpcy5vbkxvY2FsU2l6ZSxcclxuXHRcdFx0b25TY3JlZW5TeW5jTWVzc2FnZSxcclxuXHRcdFx0b25TY3JlZW5TeW5jRW5kXHJcblx0XHR9KTtcclxuXHRcdHRoaXMuY3JlYXRlRG9tKCk7XHJcblx0XHR0aGlzLmluaXRTY3JlZW4oKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgY3JlYXRlRG9tKCkge1xyXG5cdFx0dGhpcy5zY3JlZW5QYWdlPy5pbml0KCk7XHJcblx0XHRjb25zdCB3aGlhdGVCb2FyZENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0d2hpYXRlQm9hcmRDb250YWluZXIuaWQgPSAnd2hpdGVib2FyZF93cmFwZXInO1xyXG5cdFx0d2hpYXRlQm9hcmRDb250YWluZXIuY2xhc3NOYW1lID0gJ3doaXRlYm9hcmRfd3JhcGVyJztcclxuXHRcdHdoaWF0ZUJvYXJkQ29udGFpbmVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XHJcblx0XHR3aGlhdGVCb2FyZENvbnRhaW5lci5zdHlsZS50b3AgPSAnMCc7XHJcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NyZWVuX3N5bmNfY29udGFpbmVyJyk/LmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKHdoaWF0ZUJvYXJkQ29udGFpbmVyKTtcclxuXHRcdGlmIChaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIgJiYgWmNvU3luY1NjcmVlbi5pc0xvY2FsU2l6ZUdvdCkge1xyXG5cdFx0XHR0aGlzLndoaXRlQm9hcmQgPSBuZXcgV2hpdGVCb2FyZChcclxuXHRcdFx0XHR3aGlhdGVCb2FyZENvbnRhaW5lcixcclxuXHRcdFx0XHR0aGlzLm1hcmtUb29scyxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLmxvY2FsV2lkdGgsXHJcblx0XHRcdFx0WmNvU3luY1NjcmVlbi5sb2NhbEhlaWdodCxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIsXHJcblx0XHRcdFx0WmNvU3luY1NjcmVlbi5zeW5jLFxyXG5cdFx0XHRcdFpjb1N5bmNTY3JlZW4uaXNTdGFydGVkU3luYyxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLm9uU2NyZWVuU3luY01lc3NhZ2UsXHJcblx0XHRcdFx0WmNvU3luY1NjcmVlbi5zZW5kQ3VzdG9tZXJNZXNzYWdlXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKCFaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIgJiYgWmNvU3luY1NjcmVlbi5pc1JlbW90ZVNpemVHb3QgJiYgIVpjb1N5bmNTY3JlZW4uaXNIaWRlTWFya1Rvb2wpIHtcclxuXHRcdFx0dGhpcy53aGl0ZUJvYXJkID0gbmV3IFdoaXRlQm9hcmQoXHJcblx0XHRcdFx0d2hpYXRlQm9hcmRDb250YWluZXIsXHJcblx0XHRcdFx0dGhpcy5tYXJrVG9vbHMsXHJcblx0XHRcdFx0WmNvU3luY1NjcmVlbi5yZW1vdGVXaWR0aCxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLnJlbW90ZUhlaWdodCxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIsXHJcblx0XHRcdFx0dHJ1ZSxcclxuXHRcdFx0XHRaY29TeW5jU2NyZWVuLmlzU3RhcnRlZFN5bmMsXHJcblx0XHRcdFx0WmNvU3luY1NjcmVlbi5vblNjcmVlblN5bmNNZXNzYWdlLFxyXG5cdFx0XHRcdFpjb1N5bmNTY3JlZW4uc2VuZEN1c3RvbWVyTWVzc2FnZVxyXG5cdFx0XHQpO1xyXG5cdFx0XHR0aGlzLndoaXRlQm9hcmQuaW5pdCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpbml0U2NyZWVuKCkge1xyXG5cdFx0aWYgKCFaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0dGhpcy5zdGFydFNjcmVlbnN5bmMoKTtcclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5nZXRDdXN0b21lclNpemUoKTtcclxuXHRcdFx0XHR0aGlzLnJlcXVlc3RTY3JlZW5zaG90KCk7XHJcblx0XHRcdH0sIDEwMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyDluqfluK3nq6/lk43lupTorr/lrqLnq6/lsLrlr7hcclxuXHRwdWJsaWMgb25SZW1vdGVTaXplKHNpemU6IElTaXplKSB7XHJcblx0XHRaY29TeW5jU2NyZWVuLnJlbW90ZVdpZHRoID0gc2l6ZS53aWR0aDtcclxuXHRcdFpjb1N5bmNTY3JlZW4ucmVtb3RlSGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblx0XHRaY29TeW5jU2NyZWVuLnJlbW90ZVNjcm9sbEhlaWdodCA9IHNpemUuc2Nyb2xsSGVpZ2h0O1xyXG5cdFx0WmNvU3luY1NjcmVlbi5pc1JlbW90ZVNpemVHb3QgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly8g6K6/5a6i56uv5pys5Zyw5bC65a+4XHJcblx0cHVibGljIG9uTG9jYWxTaXplKHNpemU6IElTaXplKSB7XHJcblx0XHRaY29TeW5jU2NyZWVuLmxvY2FsV2lkdGggPSBzaXplLndpZHRoO1xyXG5cdFx0WmNvU3luY1NjcmVlbi5sb2NhbEhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG5cdFx0WmNvU3luY1NjcmVlbi5sb2NhbFNjcm9sbEhlaWdodCA9IHNpemUuc2Nyb2xsSGVpZ2h0O1xyXG5cdFx0WmNvU3luY1NjcmVlbi5pc0xvY2FsU2l6ZUdvdCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0U2NyZWVuU2l6ZSgpOiBJU2l6ZSB7XHJcblx0XHRpZiAoWmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0d2lkdGg6IFpjb1N5bmNTY3JlZW4ucmVtb3RlV2lkdGgsXHJcblx0XHRcdFx0aGVpZ2h0OiBaY29TeW5jU2NyZWVuLnJlbW90ZUhlaWdodCxcclxuXHRcdFx0XHRzY3JvbGxIZWlnaHQ6IFpjb1N5bmNTY3JlZW4ucmVtb3RlU2Nyb2xsSGVpZ2h0XHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHdpZHRoOiBaY29TeW5jU2NyZWVuLmxvY2FsV2lkdGgsXHJcblx0XHRcdFx0aGVpZ2h0OiBaY29TeW5jU2NyZWVuLmxvY2FsSGVpZ2h0LFxyXG5cdFx0XHRcdHNjcm9sbEhlaWdodDogWmNvU3luY1NjcmVlbi5sb2NhbFNjcm9sbEhlaWdodFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIHNldFNjcmVlblNpemUoKTogSVNpemUge1xyXG5cdFx0aWYgKFpjb1N5bmNTY3JlZW4uaXNDdXN0b21lcikge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHdpZHRoOiBaY29TeW5jU2NyZWVuLnJlbW90ZVdpZHRoLFxyXG5cdFx0XHRcdGhlaWdodDogWmNvU3luY1NjcmVlbi5yZW1vdGVIZWlnaHQsXHJcblx0XHRcdFx0c2Nyb2xsSGVpZ2h0OiBaY29TeW5jU2NyZWVuLnJlbW90ZVNjcm9sbEhlaWdodFxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR3aWR0aDogWmNvU3luY1NjcmVlbi5sb2NhbFdpZHRoLFxyXG5cdFx0XHRcdGhlaWdodDogWmNvU3luY1NjcmVlbi5sb2NhbEhlaWdodCxcclxuXHRcdFx0XHRzY3JvbGxIZWlnaHQ6IFpjb1N5bmNTY3JlZW4ubG9jYWxTY3JvbGxIZWlnaHRcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRUb29sSGlkZShzdGF0dXM6IGJvb2xlYW4pIHtcclxuXHRcdHRoaXMud2hpdGVCb2FyZD8uc2V0VG9vbEhpZGUoc3RhdHVzKTtcclxuXHR9XHJcblxyXG5cdC8vIOW6p+W4reerr+mAmuefpeiuv+Wuouerr+W8gOWni+WQjOWxj1xyXG5cdHByaXZhdGUgc3RhcnRTY3JlZW5zeW5jKCkge1xyXG5cdFx0aWYgKCFaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0dGhpcy5vbk1lc3NhZ2VPdXRJbm5lcih7IGFjdGlvbjogJ3N0YXJ0U2NyZWVuc3luYycgfSwgJ3NjcmVlbnN5bmMnKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8g5bqn5bit56uv6YCa55+l6K6/5a6i56uv5YGc5q2i5ZCM5bGPXHJcblx0cHJpdmF0ZSBzdG9wU2NyZWVuc3luYygpIHtcclxuXHRcdGlmICghWmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyKSB7XHJcblx0XHRcdHRoaXMub25NZXNzYWdlT3V0SW5uZXIoeyBhY3Rpb246ICdzdG9wU2NyZWVuc3luYycgfSwgJ3NjcmVlbnN5bmMnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIOW6p+W4reerr+iOt+WPluiuv+Wuouerr+Wxj+W5leWwuuWvuFxyXG5cdHByaXZhdGUgZ2V0Q3VzdG9tZXJTaXplKCkge1xyXG5cdFx0aWYgKCFaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0dGhpcy5vbk1lc3NhZ2VPdXRJbm5lcih7IGFjdGlvbjogJ3JlcXVlc3RTaXplJyB9LCAnc2NyZWVuc3luYycpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyDluqfluK3nq6/ojrflj5borr/lrqLnq6/miKrlsY9cclxuXHRwcml2YXRlIHJlcXVlc3RTY3JlZW5zaG90KCkge1xyXG5cdFx0aWYgKCFaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0dGhpcy5vbk1lc3NhZ2VPdXRJbm5lcih7IGFjdGlvbjogJ3JlcXVlc3RTY3JlZW5zaG90JyB9LCAnc2NyZWVuc3luYycpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8g5bqn5bit56uv5ZKM6K6/5a6i56uv5b285q2k5Y+R6YCB5raI5oGvXHJcblx0cHJpdmF0ZSBvbk1lc3NhZ2VPdXRJbm5lcihtZXNzYWdlOiBJT25NZXNzYWdlLCB0eXBlOiBzdHJpbmcsIHJvbGUgPSAnYWxsJykge1xyXG5cdFx0aWYgKFpjb1N5bmNTY3JlZW4uaXNDdXN0b21lciAmJiAhWmNvU3luY1NjcmVlbi5pc1N0YXJ0ZWRTeW5jICYmIG1lc3NhZ2UgJiYgbWVzc2FnZS5hY3Rpb24gIT09ICdzaXplJyAmJiBtZXNzYWdlLmFjdGlvbiAhPT0gJ2VuZFNjcmVlblN5bmMnICYmIG1lc3NhZ2UuYWN0aW9uICE9PSAnZ290U2NyZWVuc2hvdCcpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignb25NZXNzYWdlT3V0SW5uZXIgOiAnLCBaY29TeW5jU2NyZWVuLmlzU3RhcnRlZFN5bmMsIG1lc3NhZ2UpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAoWmNvU3luY1NjcmVlbi5vblNjcmVlblN5bmNNZXNzYWdlKSB7XHJcblx0XHRcdFpjb1N5bmNTY3JlZW4ub25TY3JlZW5TeW5jTWVzc2FnZShPYmplY3QuYXNzaWduKHt9LCB7IHR5cGU6IHR5cGUgfSwgbWVzc2FnZSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignbm8gbWVzc2FnZSBzZW5kZXIgcHJvdmlkZWQhJyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiog5raI5oGv5YiG5Y+RICovXHJcblx0cHJpdmF0ZSBvbkluY29taW5nTWVzc2FnZShtZXNzYWdlOiBJT25NZXNzYWdlKSB7XHJcblx0XHRpZiAoIW1lc3NhZ2UpIHJldHVybjtcclxuXHRcdGlmIChtZXNzYWdlLnR5cGUgPT09ICdzY3JlZW5zeW5jJykge1xyXG5cdFx0XHRpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdzY3JvbGwnIHx8IG1lc3NhZ2UuYWN0aW9uID09PSAnc2NyZWVuc2hvdCcgfHwgbWVzc2FnZS5hY3Rpb24gPT09ICdpZ25vcmVFbGVtZW50cycgfHwgbWVzc2FnZS5hY3Rpb24gPT09ICd0b3VjaFBvcycpIHtcclxuXHRcdFx0XHRpZiAoIVpjb1N5bmNTY3JlZW4uaXNDdXN0b21lcikge1xyXG5cdFx0XHRcdFx0WmNvU3luY1NjcmVlbi5oNU1lc3NhZ2VJbiA9IG1lc3NhZ2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSAnc2l6ZScpIHtcclxuXHRcdFx0XHRpZiAoIVpjb1N5bmNTY3JlZW4uaXNDdXN0b21lcikge1xyXG5cdFx0XHRcdFx0dGhpcy5vblJlbW90ZVNpemUobWVzc2FnZS52YWx1ZSBhcyBhbnkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3N0YXJ0U2NyZWVuc3luYycpIHtcclxuXHRcdFx0XHRpZiAoWmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyKSB7XHJcblx0XHRcdFx0XHRaY29TeW5jU2NyZWVuLmlzU3RhcnRlZFN5bmMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0WmNvU3luY1NjcmVlbi5oNU1lc3NhZ2VJbiA9IG1lc3NhZ2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKG1lc3NhZ2UuYWN0aW9uID09PSAnc3RvcFNjcmVlbnN5bmMnKSB7XHJcblx0XHRcdFx0aWYgKFpjb1N5bmNTY3JlZW4uaXNDdXN0b21lcikge1xyXG5cdFx0XHRcdFx0WmNvU3luY1NjcmVlbi5pc1N0YXJ0ZWRTeW5jID0gZmFsc2U7XHJcblx0XHRcdFx0XHRaY29TeW5jU2NyZWVuLmg1TWVzc2FnZUluID0gbWVzc2FnZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdyZXF1ZXN0U2l6ZScpIHtcclxuXHRcdFx0XHRpZiAoWmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyKSB7XHJcblx0XHRcdFx0XHRaY29TeW5jU2NyZWVuLmg1TWVzc2FnZUluID0gbWVzc2FnZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdyZXF1ZXN0U2NyZWVuc2hvdCcpIHtcclxuXHRcdFx0XHRpZiAoWmNvU3luY1NjcmVlbi5pc0N1c3RvbWVyKSB7XHJcblx0XHRcdFx0XHRaY29TeW5jU2NyZWVuLmg1TWVzc2FnZUluID0gbWVzc2FnZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAobWVzc2FnZS5hY3Rpb24gPT09ICdnZXRTY3JlZW5zaG90Jykge1xyXG5cdFx0XHRcdGlmIChaY29TeW5jU2NyZWVuLmlzQ3VzdG9tZXIpIHtcclxuXHRcdFx0XHRcdFpjb1N5bmNTY3JlZW4uaDVNZXNzYWdlSW4gPSBtZXNzYWdlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmhhbmRsZWQgc2NyZWVuc3luYyBtZXNzZ2FlIGluIDogJywgbWVzc2FnZSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAnd2hpdGVib2FyZCcpIHtcclxuXHRcdFx0WmNvU3luY1NjcmVlbi5tYXJrZXJNZXNzYWdlSW4gPSBtZXNzYWdlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcigndW5oYW5kbGVkIG1lc3NnYWUgaW4gOiAnLCBtZXNzYWdlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3luY1VybCgpIHtcclxuXHRcdC8vIHVybCDkuK3nmoQvLyDmm7/mjaLmiJAgL1xyXG5cdFx0Ly8gaHR0cHM6Ly9pdmNzLWRldi1rOHMuemVhbGNvbW0uY24vL2N1c3RvbWVyLy8jL2xpbmtcclxuXHRcdC8vIGh0dHBzOi8vaXZjcy1kZXYtazhzLnplYWxjb21tLmNuL2N1c3RvbWVyLyMvbGlua1xyXG5cdFx0Y29uc3QgaW5kZXggPSBaY29TeW5jU2NyZWVuLnVybC5pbmRleE9mKCc6Ly8nKSArIDM7XHJcblx0XHRjb25zdCBwcm90b2NvbCA9IFpjb1N5bmNTY3JlZW4udXJsLnN1YnN0cmluZygwLCBpbmRleCk7XHJcblx0XHRsZXQgcGF0aCA9IFpjb1N5bmNTY3JlZW4udXJsLnN1YnN0cmluZyhpbmRleCkucmVwbGFjZUFsbCgnLy8vJywgJy8nKTtcclxuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2VBbGwoJy8vJywgJy8nKTtcclxuXHRcdHJldHVybiBwcm90b2NvbCArIHBhdGg7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0TWVzc2FnZUluKG1lc3NhZ2U6IElPbk1lc3NhZ2UpIHtcclxuXHRcdGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gJ3NpemUnKSB7XHJcblx0XHRcdHRoaXMub25SZW1vdGVTaXplKG1lc3NhZ2UudmFsdWUgYXMgYW55KTtcclxuXHRcdH1cclxuXHRcdHRoaXMub25JbmNvbWluZ01lc3NhZ2UobWVzc2FnZSk7XHJcblx0XHR0aGlzLnNjcmVlblBhZ2U/LnNldE1lc3NhZ2VJbihtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBkZXN0b3J5KCkge1xyXG5cdFx0Y29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmVlbi1zeW5jLW1haW4td3JhcHBlcicpO1xyXG5cdFx0Y29uc29sZS5sb2coJ2Rlc3Rvcnk6JywgdGhpcy5yb290Q29udGFpbmVyKTtcclxuXHRcdGlmIChjb250YWluZXIgJiYgdGhpcy5yb290Q29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMucm9vdENvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgWmNvU3luY1NjcmVlbiBmcm9tICcuL1pjb1NjcmVlblN5bmMnO1xyXG5cclxuLy8gKCgpID0+IHtcclxuLy8gXHRjb25zdCBzZW5kQ3VzdG9tTWVzc2FnZSA9ICgpID0+IHt9O1xyXG4vLyBcdGNvbnN0IG9uU2NyZWVuU3luY01lc3NhZ2UgPSAoKSA9PiB7fTtcclxuLy8gXHRjb25zdCBvblNjcmVlblN5bmNFbmQgPSAoKSA9PiB7fTtcclxuLy8gXHRjb25zdCBtZXNzYWdlSW4gPSB7fTtcclxuLy8gXHRjb25zdCBpbml0ID0gKCkgPT4ge1xyXG4vLyBcdFx0Y29uc3QgemNvU3luY1NjcmVlbiA9IG5ldyBaY29TeW5jU2NyZWVuKCdyb290JywgeyBpc0N1c3RvbWVyOiBmYWxzZSwgdXJsOiAnJywgd2lkdGg6IDM5MCwgaGVpZ2h0OiA4NDQsIG1lc3NhZ2VJbiwgb25TY3JlZW5TeW5jRW5kLCBzZW5kQ3VzdG9tTWVzc2FnZSwgb25TY3JlZW5TeW5jTWVzc2FnZSB9KTtcclxuLy8gXHR9O1xyXG5cclxuLy8gXHRpbml0KCk7XHJcbi8vIH0pKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBaY29TeW5jU2NyZWVuO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///231\n') }, 870: g => { g.exports = require("fabric") } }, __webpack_module_cache__ = {}; function __webpack_require__ (g) { var I = __webpack_module_cache__[g]; if (void 0 !== I) return I.exports; var C = __webpack_module_cache__[g] = { exports: {} }; return __webpack_modules__[g](C, C.exports, __webpack_require__), C.exports } __webpack_require__.d = (g, I) => { for (var C in I) __webpack_require__.o(I, C) && !__webpack_require__.o(g, C) && Object.defineProperty(g, C, { enumerable: !0, get: I[C] }) }, __webpack_require__.o = (g, I) => Object.prototype.hasOwnProperty.call(g, I), __webpack_require__.r = g => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(g, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(g, "__esModule", { value: !0 }) }; var __webpack_exports__ = __webpack_require__(231); module.exports = __webpack_exports__ })();